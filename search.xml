<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F11%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构栈先进后出(Last in First out) =&gt;有序集合新添加与待删除都是在栈尾，称作栈顶，另一端为栈底队列先进先出(First in First out) =&gt;有序项尾部添加新元素，头部移除元素，最新添加的元素必须排在队列的末尾链表有序的元素集合 =&gt; 不同于数组，元素在内存中不连续放置每个元素由一个元素本身节点和一个指向下一个元素的引用(指针 / 链接)组成集合由一组无序且唯一的项组成字典以【键，值】对为数据形态的数据结构 =&gt; 键名用来查询特定元素散列根据关键码值 ( Key Value ) 直接进行访问通过把关键码值映射到表中的一个位置来访问记录，以加快查找速度映射函数叫做散列函数，存放记录的数组叫做散列数组树由 n ( n &gt; = 1 ) 个有限节点组成的一个具有层次关系的集合，呈一对多关系根节点至少有两个儿子公式第 n 层的节点数最多为$$2^n$$个节点n 层二叉树最多有$$2^0+…+2^n=2^{n+1}$$个节点第一个非叶子节点：length / 2一个节点的孩子节点：2n、2n+1基本结构插入、遍历、深度12345678910111213function Node(data,left,right)&#123; this.data = data this.left = left this.right = right&#125;Node.prototype = &#123; show: function()&#123; console.log(this.data); &#125;&#125;function Tree遍历中序遍历： 左侧子节点 =&gt; 节点本身 =&gt; 右侧子节点先序遍历： 节点本身 =&gt; 左侧子节点 =&gt; 右侧子节点后序遍历： 左侧子节点 =&gt; 节点本身 =&gt; 右侧子节点图网络结构的抽象模型图是一组由边连接的节点任何二元关系都可以用图来表示，呈多对多关系算法排序算法冒泡排序： O(n²)比较任何两个相邻的项，如果第一个比第二个大，则交换它们；元素项向上移动至正确的顺序，好似气泡上升至表面一般，因此得名选择排序每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，以此循环，直至排序完毕插入排序：O(n²)将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，此算法适用于少量数据的排序，时间复杂度为 O(n^2)归并排序将原始序列切分成较小的序列，只到每个小序列无法再切分，然后执行合并，即将小序列归并成大的序列，合并过程进行比较排序，只到最后只有一个排序完毕的大序列，时间复杂度为 O(n log n)快速排序: O(nlog^n)通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行上述递归排序，以此达到整个数据变成有序序列，时间复杂度为 O(n log n)搜索算法顺序算法让目标元素与列表中的每一个元素逐个比较，直到找出与给定元素相同的元素为止，缺点是效率低下二分搜索在一个有序列表，以中间值为基准拆分为两个子列表，拿目标元素与中间值作比较从而再在目标的子列表中递归此方法，直至找到目标元素其他斐波那契数列1和2的斐波那契数是1n(n &gt; 2) 的斐波那契数是 (n-1)的斐波那契数 + n(n-2)的斐波那契数贪心算法在对问题求解时，不考虑全局，总是做出局部最优解的方法动态规划在对问题求解时，由以求出的局部最优解来推导全局最优解复杂度概念算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述时间复杂度大O符号表示法T(n) = O(f(n))： 算法的渐进时间复杂度f(n) 表示每行代码执行次数之和O 表示正比例关系1234for(i=1;i&lt;=n;++i)&#123; j =i; j++;&#125;时间复杂度为O(n)常见的时间复杂度量级从上至下依次的时间复杂度越来越大，执行的效率越来越低常数阶O(1)对数阶O(logN)线性阶O(n)线性对数阶O(nlogN)平方阶O(n²)立方阶O(n³)K次方阶O(n^k)【n的k次方，符号不会敲】指数阶(2^n)常用的时间复杂度量级常数阶O(1)无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)12345int i = 1;int j = 2;++i;j++;int m = i + j;线性阶O(n)for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度12345for(i=1; i&lt;=n; ++i)&#123; j = i; j++;&#125;对数阶O(logN)普通应用都是10，计算机学科是2，编程语言里面是e常用编程语言中Math.log一般都是以E为底（MATLAB里面是以e为底的）ln是以e为底数，lg是以10为底数此处log底数为212345int i = 1;while(i&lt;n)&#123; i = i * 2;&#125;在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n【这里是log 2的n次方，符号不会敲】也就是说当循环 log2n【这里是log 2的n次方，符号不会敲】 次以后，这个代码就结束了线性对数阶O(nlogN)线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)12345678for(m=1; m&lt;n; m++)&#123; i = 1; while(i&lt;n) &#123; i = i * 2; &#125;&#125;平方阶O(n²)O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)12345678for(x=1; i&lt;=n; x++)&#123; for(i=1; i&lt;=n; i++) &#123; j = i; j++; &#125;&#125;O(n²)将其中一层循环的n改成m12345678for(x=1; i&lt;=m; x++)&#123; for(i=1; i&lt;=n; i++) &#123; j = i; j++; &#125;&#125;O(m*n)空间复杂度空间复杂度 O(1)12345int i = 1;int j = 2;++i;j++;int m = i + j;空间复杂度 O(n)123456int[] m = new int[n]for(i=1; i&lt;=n; ++i)&#123; j = i; j++;&#125;###]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2019%2F11%2F10%2FLinux-samba%2F</url>
    <content type="text"><![CDATA[samba服务yum install sambayumyum clean allyum 会把下载的软件包和header存储在cache中，而不自动删除如果觉得占用磁盘空间，可以使用yum clean指令进行清除，更精确 的用法是yum clean headers清除headeryum clean packages清除下载的rpm包yum clean all一全部清除yum check-update列出所有可更新的软件清单yum update更新所有软件yum install &lt;package_name&gt;仅安装指定的软件yum update &lt;package_name&gt;仅更新指定的软件yum list列出所有可安裝的软件清单TIPs环回网卡的作用可以在实验中用到，有的实验需要网卡处于连接状态，而此时你的物理网卡没有连接网线，于是就可以使用“环回网卡”来欺骗操作系统 - 网卡已经连接了。同理，虚拟光驱有时候也用于欺骗，即，光盘已经挂载上了~microsoft loopback adapter就是安装在本机上的一块虚拟网卡，它跟本机上的其它物理网卡、和物理网卡连接的网络是没有关系的，你可以理解成这块网卡上的网线接到了另外一个空白网络。它的作用仅仅是用来给那些需要本机配置有网络的服务程序调试用，它不能与实体网络进行通信。举个最简单的例子，你的电脑没有网卡，想给本机安装WINDOWS的DNS服务试着玩，但DNS服务在启动时若检测到本机没有网络会报错停止，这时你安装块loopback adapter网卡就有用了]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端基础]]></title>
    <url>%2F2019%2F10%2F25%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTML 篇图片中 title 和 alt 区别？通常当鼠标滑动到元素上的时候显示alt是的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。Html5 有哪些新特性、移除了哪些元素新增元素：* 绘画`canvas` * 用于媒介回放的`video 和 audio`元素 * 本地离线存储`localStorage`长期存储数据，浏览器关闭后数据不丢失 * `sessionStorage`的数据在浏览器关闭后自动删除 * 语义化更好的内容元素，比如`article 、footer、header、nav、section` * 表单控件 ，`calendar 、 date 、 time 、 email 、 url 、 search` * 新的技术`webworker 、 websocket 、 Geolocation` 移除的元素：纯表现的元素：basefont 、 big 、 center 、 font 、 s 、 strike 、 tt 、 u对可用性产生负面影响的元素：frame 、 frameset 、 noframes支持 HTML5 新标签：IE8/IE7/IE6支持通过document.createElement方法产生的标签可以利用这一特性让这些浏览器支持HTML5新标签浏览器支持新标签后，还需要添加标签默认的样式-浏览器是怎么对 Html5 的离线储存资源进行管理和加载的呢如何使用：页面头部像下面一样加入一个manifest的属性；在cache.manifest文件的编写离线存储的资源在离线状态时，操作window.applicationCache进行需求实现在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。iframe 有那些缺点？iframe会阻塞主页面的Onload事件搜索引擎的检索程序无法解读这种页面，不利于 SEOiframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题HTML W3C 的标准标签闭合、标签小写、不乱嵌套、使用外链 css 和 js 、结构行为表现的分离Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?&lt;!DOCTYPE&gt;声明位于文档中的最前面，处于html标签之前。告知浏览器的解析器， 用什么文档类型、规范来解析这个文档严格模式的排版和JS运作模式是 以该浏览器支持的最高标准运行在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现HTML 全局属性(global attribute)有哪些class:为元素设置类标识data-*: 为元素增加自定义属性draggable: 设置元素是否可拖拽id: 元素 id ，文档内唯一lang: 元素内容的的语言style: 行内 css 样式title: 元素相关的建议信息viewport 的 content 属性作用123456789101112131415&lt;meta name=&quot;viewport&quot; content=&quot;&quot; /&gt; width viewport的宽度[device-width | pixel_value]width如果直接设置pixel_value数值，大部分的安卓手机不支持，但是ios支持； height – viewport 的高度 （范围从 223 到 10,000 ） user-scalable [yes | no]是否允许缩放 initial-scale [数值] 初始化比例（范围从 &gt; 0 到 10） minimum-scale [数值] 允许缩放的最小比例 maximum-scale [数值] 允许缩放的最大比例 target-densitydpi 值有以下（一般推荐设置中等响度密度或者低像素密度，后者设置具体的值dpi_value，另外webkit内核已不准备再支持此属性） -- dpi_value 一般是70-400//没英寸像素点的个数 -- device-dpi设备默认像素密度 -- high-dpi 高像素密度 -- medium-dpi 中等像素密度 -- low-dpi 低像素密度复制代码附带问题：怎样处理 移动端 1px 被 渲染成 2px 问题?局部处理：mate标签中的viewport属性 ，initial-scale设置为 1rem按照设计稿标准走，外加利用transfrome 的 scale(0.5)缩小一倍即可；全局处理：mate标签中的viewport属性 ，initial-scale设置为 0.5rem按照设计稿标准走即可meta 相关123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt; &lt;!--H5标准声明，使用 HTML5 doctype，不区分大小写--&gt;&lt;head lang=”en”&gt; &lt;!--标准的 lang 属性写法--&gt;&lt;meta charset=’utf-8′&gt; &lt;!--声明文档使用的字符编码--&gt;&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt; &lt;!--优先使用指定浏览器使用特定的文档模式--&gt;&lt;meta name=”description” content=”不超过150个字符”/&gt; &lt;!--页面描述--&gt;&lt;meta name=”keywords” content=””/&gt; &lt;!-- 页面关键词--&gt;&lt;meta name=”author” content=”name, email@gmail.com”/&gt; &lt;!--网页作者--&gt;&lt;meta name=”robots” content=”index,follow”/&gt; &lt;!--搜索引擎抓取--&gt;&lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-sc&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt; &lt;!--iOS 设备 begin--&gt;&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt; &lt;!--添加到主屏后的标是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏--&gt;&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;&lt;meta name=”renderer” content=”webkit”&gt; &lt;!-- 启用360浏览器的极速模式(webkit)--&gt;&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt; &lt;!--避免IE使用兼容模式--&gt;&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt; &lt;!--不让百度转码--&gt;&lt;meta name=”HandheldFriendly” content=”true”&gt; &lt;!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器--&gt;&lt;meta name=”MobileOptimized” content=”320″&gt; &lt;!--微软的老式浏览器--&gt;&lt;meta name=”screen-orientation” content=”portrait”&gt; &lt;!--uc强制竖屏--&gt;&lt;meta name=”x5-orientation” content=”portrait”&gt; &lt;!--QQ强制竖屏--&gt;&lt;meta name=”full-screen” content=”yes”&gt; &lt;!--UC强制全屏--&gt;&lt;meta name=”x5-fullscreen” content=”true”&gt; &lt;!--QQ强制全屏--&gt;&lt;meta name=”browsermode” content=”application”&gt; &lt;!--UC应用模式--&gt;&lt;meta name=”x5-page-mode” content=”app”&gt; &lt;!-- QQ应用模式--&gt;&lt;meta name=”msapplication-tap-highlight” content=”no”&gt; &lt;!--windows phone设置页面不缓存--&gt;&lt;meta http-equiv=”pragma” content=”no-cache”&gt;&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;&lt;meta http-equiv=”expires” content=”0″&gt;复制代码了解更多参考：https://blog.csdn.net/kongjiea/article/details/17092413div+css 的布局较 table 布局有什么优点改版的时候更方便 只要改css文件。页面加载速度更快、结构化清晰、页面显示简洁。表现与结构相分离。易于优化（ seo ）搜索引擎更友好，排名更容易靠前。src 与 href 的区别src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部-href 是 Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加 -link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式CSS 篇link 与 @import 的区别link是HTML方式，@import是CSS方式link最大限度支持并行下载，@import过多嵌套导致串行下载，出现 FOUC (文档样式短暂失效)link可以通过rel=&quot;alternate stylesheet&quot;指定候选样式浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式@import必须在样式规则之前，可以在css文件中引用其他文件总体来说：link优于@import，link优先级也更高BFC 有什么用创建规则：* 根元素 * 浮动元素（`float`不取值为`none`） * 绝对定位元素（`position`取值为`absolute`或`fixed`） * `display`取值为`inline-block 、 table-cell 、 table-caption 、 flex 、inline-flex`之一的元素 * `overflow`不取值为`visible`的元素 作用可以包含浮动元素不被浮动元素覆盖阻止父子元素的margin折叠-清除浮动的几种方式父级div定义height结尾处加空div标签clear:both父级div定义伪类:after和zoom父级div定义overflow:hidden父级div也浮动，需要定义宽度结尾处加br标签clear:bothCss3 新增伪类 - 伪元素p:first-of-type选择属于其父元素的首个元素的每个元素。p:last-of-type选择属于其父元素的最后元素的每个元素。p:only-of-type选择属于其父元素唯一的元素的每个元素。p:only-child选择属于其父元素的唯一子元素的每个元素。p:nth-child(2)选择属于其父元素的第二个子元素的每个元素。:enabled已启用的表单元素。:disabled已禁用的表单元素。:checked单选框或复选框被选中。::before在元素之前添加内容。::after在元素之后添加内容,也可以用来做清除浮动。::first-line添加一个特殊的样式到文本的首字母。::first-letter添加一行特殊样式到首行。相信大家也看出来他们的不同，伪类语法一个：，它是为了弥补 css 常规类选择器的不足伪元素语法两个：，它是凭空创建的一个虚拟容器生成的元素IE 盒子模型 、W3C 盒子模型W3C 盒模型： 内容(content)、填充( padding )、边界( margin )、 边框( border )；* `box-sizing: content-box` * width = content width; IE 盒子模型： IE 的 content 部分把 border 和 padding 计算了进去;box-sizing: border-boxwidth = border + padding + content width-display:inline-block 什么时候不会显示间隙？移除空格使用margin负值使用font-size:0letter-spacingword-spacing行内元素 float:left 后是否变为块级元素？行内元素设置成浮动之后变得更加像是inline-block（行内块级元素，设置 成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是 100% ），这时候给行内元素设置padding-top和padding-bottom或者width 、 height都是有效果的如果需要手动写动画，你认为最小时间间隔是多久，为什么？多数显示器默认频率是 60Hz ，即 1 秒刷新 60 次，所以理论上最小间隔为 1/60*1000ms ＝ 16.7msCSS 不同选择器的权重(CSS 层叠的规则)！important规则最重要，大于其它规则行内样式规则，加 1000对于选择器中给定的各个 ID 属性值，加 100对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加 10对于选择其中给定的各个元素标签选择器，加 1如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则stylus/sass/less 区别均具有“变量”、“混合”、“嵌套”、“继承”、“颜色混合”五大基本特性Sass和LESS语法较为严谨，LESS要求一定要使用大括号“{}”，Sass和Stylus可以通过缩进表示层次与嵌套关系Sass无全局变量的概念，LESS和Stylus有类似于其它语言的作用域概念Sass是基于Ruby语言的，而LESS和Stylus可以基于NodeJS NPM下载相应库后进行编译；这也是为什么安装 Sass 的时候有时候会报错，需要安装 python 脚本优点：就不用我多说了，谁用谁知道，真香。rgba()和 opacity 的透明效果有什么不同？rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，而rgba()只作用于元素的颜色或其背景色。（设置 rgba 透明的元素的子元素不会继承透明效果！）水平居中的方法元素为行内元素，设置父元素text-align:center如果元素宽度固定，可以设置左右margin 为 auto;如果元素为绝对定位，设置父元素position 为 relative，元素设left:0;right:0;margin:auto;使用flex-box布局，指定justify-content属性为centerdisplay设置为tabel-ceil垂直居中的方法将显示方式设置为表格，display:table-cell,同时设置vertial-align：middle使用flex布局，设置为align-item：center绝对定位中设置bottom:0,top:0,并设置margin:auto绝对定位中固定高度时设置top:50%，margin-top值为高度一半的负值文本垂直居中设置line-height为height值浏览器 篇浏览器内核的理解主要分两个部分：渲染引擎、js引擎渲染引擎：负责取得网页的内容（html css img …），以及计算网页的显示方式，然后会输出至显示器或者打印机。浏览器的内核不同对于网页的语法解释也不同，所以渲染的效果也不一样js引擎：解析和执行 javascript 来实现网页的动态效果最开始渲染引擎和 js 引擎并没有区分的很明确，后来 js 引擎越来越独立，内核就倾向于只值渲染引擎IE : trident内核Firefox ： gecko内核Safari : webkit内核Opera:以前是presto内核，Opera现已改用Google - Chrome的Blink内核Chrome:Blink(基于webkit，Google与Opera Software共同开发)HTTP 请求+作用？Get方法：发送一个请求来获取服务器资源POST方法：向服务器提交数据PUT方法：与POST方法很像，也是提交数据，但PUT制定了资源在服务器上的位置，常用在修改数据HEAD方法：只请求页面的首部信息DELETE方法：删除服务器上的资源OPTIONS方法：用于获取当前URL支持的请求方式TRACE方法：用于激活一个远程的应用层请求消息回路CONNECT方法：把请求链接转换到透明的TCP/IP的通道HTTP 状态码1XX：信息状态码* `100 continue`继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息 2XX：成功状态码200 ok正常返回信息201 created请求成功并且服务器创建了新资源202 accepted服务器已经接收请求，但尚未处理3XX：重定向301 move per请求的网页已经永久重定向302 found临时重定向303 see other临时冲重定向，且总是使用 get 请求新的 url304 not modified自从上次请求后，请求的网页未修改过4XX：客户端错误400 bad request服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求401 unauthorized请求未授权403 forbidden禁止访问404 not found找不到如何与 url 匹配的资源5XX：服务器错误* `500 internal server error`最常见的服务器端的错误 * `503 service unacailable`服务器端暂时无法处理请求（可能是过载活维护） -从浏览器地址栏输入 URL 后发生了什么？基础版本1.的浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；2.服务器交给后台处理完成后返回数据，浏览器接收文件（ HTML、JS、CSS 、图象等）；3.浏览器对加载到的资源（ HTML、JS、CSS 等）进行语法解析，建立相应的内部数据结构（如 HTML 的 DOM ）；4.载入解析到的资源文件，渲染页面，完成。详细版1.从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）2.开启网络线程到发出一个完整的HTTP请求（这一部分涉及到 dns 查询，TCP/IP请求，五层因特网协议栈等知识）3.从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）4.后台和前台的HTTP交互（这一部分包括HTTP头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）5.单独拎出来的缓存问题，HTTP的缓存（这部分包括http缓存头部，ETag ， catchcontrol等）6.浏览器接收到HTTP数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout 、 painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded 和 DOMContentLoaded等）7.CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC， IFC 等概念）8.JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）9.其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）详细升级版1.在浏览器地址栏输入URL2.浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤* 2.1 如果资源未缓存，发起新请求 * 2.2 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 2.3 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control： * 2.3.1`HTTP1.0`提供`Expires`，值为一个绝对时间表示缓存新鲜日期 * 2.3.2`HTTP1.1`增加了`Cache-Control: max-age=`,值为以秒为单位的最大新鲜时间 * * 3.浏览器解析URL获取协议，主机，端口，path4.浏览器组装一个HTTP（GET）请求报文5.浏览器获取主机ip地址，过程如下：* 5.1 浏览器缓存 * 5.2 本机缓存 * 5.3 hosts文件 * 5.4 路由器缓存 * 5.5 ISP DNS缓存 * 5.6 DNS递归查询（可能存在负载均衡导致每次IP不一致） 6.打开一个socket与目标IP地址，端口建立 TCP 链接，三次握手如下：6.1 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口6.2 服务器发回SYN=1，ACK=x+1,Seq=Y的相应包6.3 客户端发送ACK=Y+1，Seq=z7.TCP链接建立后发送HTTP请求8.服务器接收请求后解析，将请求转发到服务器程序，如虚拟主机使用HTTP Host头部判断请求的服务程序9.服务器检测HTTP请求头是否包含缓存验证信息，如果验证缓存新鲜，返回 304 等对应状态10.出合理程序读取完整请求并准备HTTP相应，可能需要查询数据库等操作11.服务器将相应报文通过TCP链接发送回浏览器12.浏览器接收HTTP相应，然后根据情况选择关闭TCP链接或者保留重用，关闭 TCP 链接的四次握手如下：* 12.1 主动方发送`Fin=1,ACK=z,Seq=x`报文 * 12.2 被动方发送`ACK=X+1,Seq=Y`报文 * 12.3 被动方发送`Fin=1,ACK=X,Seq=Y`报文 * 12.4 主动方发送`ACK=Y,Seq=x`报文 13.浏览器检查相应状态码14.如果资源可缓存，进行缓存15.对相应进行解码16.根据资源类型决定如何处理17.解析HTML文档，构建DOM树，下载资源，构建CSSOM树，执行 js 脚本，这些操作每月严格的先后顺序18.构建 DOM 树：* 18.1 Tokenizing：根据HTML规范将字符流解析为标记 * 18.2 Lexing：词法分析将标记转换为对象并定义属性和规则 * 18.3 DOM construction：根据HTML标记关系将对象组成DOM树 19.解析过程中遇到图片、样式表、js 文件，启动下载20.构建CSSOM树：* 20.1`Tokenizing`：字符流转换为标记流 * 20.2`Node`：根据标记创建节点 * 20.3`CSSOM`：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树21.1 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script , meta这样本身不可见的标签。2)被 css 隐藏的节点，如 display: none21.2 对每一个可见节点，找到恰当的CSSOM规则并应用21.3 发布可视节点的内容和计算样式22.js 解析如下22.1 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading22.2 HTML 解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容22.3 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己 script 和之前的文档元素22.4 当文档完成解析，document.readState变成interactive22.5 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()22.6 浏览器在Document对象上触发DOMContentLoaded事件22.7 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete，window触发load事件23.显示页面（HTML 解析过程中会逐步显示页面）cookies ， sessionStorage 和 localStorage 的区别cookie是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）cookie数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递（优化点）sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存存储大小：* `cookie`数据大小不能超过4k * `sessionStorage 和 localStorage`虽然也有存储大小的限制，但比 cookie 大得多，可以达到5M或更大 有期时间：localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据sessionStorage数据在当前浏览器窗口关闭后自动删除cookie 设置的 cookie过期时间之前一直有效，即使窗口或浏览器关闭浏览器缓存浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下先根据这个资源的一些http header判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。当协商缓存也没命中时，服务器就会将资源发送回客户端。当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；当f5刷新网页时，跳过强缓存，但是会检查协商缓存；强缓存-协商缓存：这篇文章介绍挺细的：https://juejin.cn/post/6844903763665240072#heading-5JS 篇说几条写 JavaScript 的基本规范不要在同一行声明多个变量请是用 ===/!== 来比较true/false或者数值使用对象字面量替代new Array这种形式不要使用全局函数Switch语句必须带有default分支If语句必须使用大括号for-in循环中的变量 应该使用let关键字明确限定作用域，从而避免作用域污染绕不过去的闭包闭包就是能够读取其他函数内部变量的函数闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域闭包的特性：* 函数内再嵌套函数 * 内部函数可以引用外层的参数和变量 * 参数和变量不会被垃圾回收机制回收 优点：能够实现封装和缓存等缺点：消耗内存、使用不当会内存溢出，解决方法：在退出函数之前，将不使用的局部变量全部删除说说你对作用域链的理解作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期JavaScript 原型，原型链 ? 有什么特点？每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时,如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念关系：instance.constructor.prototype = instance._proto_特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的,就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到Object内建对象请解释什么是事件委托/事件代理事件代理（ Event Delegation ），又称之为事件委托。是JavaScript中常用的绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能可以大量节省内存占用，减少事件注册，比如在table上代理所有td 的 click事件就非常棒可以实现当新增子对象时无需再次对其绑定Javascript 如何实现继承？构造继承原型继承实例继承拷贝继承原型prototype机制或apply 和 call方法去实现较简单，建议使用构造函数与原型混合方式1234567891011function Parent()&#123;this.name = &apos;wang&apos;;&#125;function Child()&#123; this.age = 28;&#125;Child.prototype = new Parent();//继承了Parent，通过原型var demo = new Child();alert(demo.age);alert(demo.name);//得到被继承的属性复制代码谈谈 This 对象的理解this总是指向函数的直接调用者（而非间接调用者）如果有new关键字，this指向new出来的那个对象在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent 中的this总是指向全局对象Window事件模型W3C中定义事件的发生经历三个阶段：捕获阶段（capturing）、目标阶段 （targetin）、冒泡阶段（bubbling）冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件阻止冒泡：在W3c中，使用stopPropagation()方法；在 IE 下设置cancelBubble =true阻止捕获：阻止事件的默认行为，例如click - a后的跳转。在W3c中，使用preventDefault()方法，在 IE 下设置window.event.returnValue = falsenew 操作符具体干了什么呢?创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型属性和方法被加入到this引用的对象中新创建的对象由this所引用，并且最后隐式的返回thisAjax 原理Ajax的原理简单来说是在用户和服务器之间加了—个中间层( AJAX 引擎)，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据Ajax的过程只涉及JavaScript 、 XMLHttpRequest 和 DOM 。 XMLHttpRequest是ajax的核心机制如何解决跨域问题?首先了解下浏览器的同源策略 同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS 、 CSFR等攻击。所谓同源是指&quot;协议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源通过jsonp跨域12345678910var script = document.createElement(&apos;script&apos;);script.type = &apos;text/javascript&apos;;// 传参并指定回调执行函数为onBackscript.src = &apos;http://www.....:8080/login?user=admin&amp;callback=onBack&apos;;document.head.appendChild(script);// 回调执行函数function onBack(res) &#123; alert(JSON.stringify(res));&#125;复制代码document.domain + iframe跨域1234567891011//父窗口：(http://www.domain.com/a.html)&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = &apos;domain.com&apos;; var user = &apos;admin&apos;;&lt;/script&gt;//子窗口：(http://child.domain.com/b.html)document.domain = &apos;domain.com&apos;;// 获取父窗口中变量alert(&apos;get js data from parent ---&gt; &apos; + window.parent.user);复制代码nginx代理跨域nodejs中间件代理跨域后端在头部信息里面设置安全域名说说你对 AMD 和 Commonjs 的理解CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载 模块，允许指定回调函数AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports 或 exports的属性赋值来达到暴露模块对象的目的js 的 7 种基本数据类型Undefined 、 Null 、Boolean 、Number 、String 、Bigint 、Symbol感谢：字符搬运工 同学纠正介绍 js 有哪些内置对象Object是JavaScript中所有对象的父对象数据封装类对象：Object 、 Array 、 Boolean 、 Number 和 String其他对象：Function 、 Arguments 、 Math 、 Date 、 RegExp 、 ErrorJS 有哪些方法定义对象对象字面量：var obj = {};构造函数：var obj = new Object();Object.create():var obj = Object.create(Object.prototype);你觉得 jQuery 源码有哪些写的好的地方jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率null，undefined 的区别undefined表示不存在这个值。undefined:是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。尝试读取时会返回undefined例如变量被声明了，但没有赋值时，就等于undefinednull表示一个对象被定义了，值为“空值”null: 是一个对象(空对象, 没有任何属性和方法)例如作为函数的参数，表示该函数的参数不是对象；在验证null时，一定要使用 === ，因为 == 无法分别null 和 undefined谈谈你对 ES6 的理解新增模板字符串（为JavaScript提供了简单的字符串插值功能）箭头函数for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let 和 const命令，用来声明变量。还有就是引入module模块的概念更多 ES 新语法：阮一峰的 ES 入门：https://es6.ruanyifeng.com/#docs/style面向对象编程思想基本思想是使用对象，类，继承，封装等基本概念来进行程序设计易维护易扩展开发工作的重用性、继承性高，降低重复工作量。缩短了开发周期如何通过 JS 判断一个数组instanceof运算符是用来测试一个对象是否在其原型链原型构造函数的属性123var arr = [];arr instanceof Array; // true复制代码isArray123Array.isArray([]) //trueArray.isArray(1) //false复制代码constructor属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数123var arr = [];arr.constructor == Array; //true复制代码Object.prototype12345678Object.prototype.toString.call([]) == &apos;[object Array]&apos;// 写个方法var isType = function (obj) &#123; return Object.prototype.toString.call(obj).slice(8,-1); //return Object.prototype.toString.apply([obj]).slice(8,-1);&#125;isType([]) //Array复制代码异步编程的实现方式回调函数* 优点：简单、容易理解 * 缺点：不利于维护，代码耦合高 事件监听(采用时间驱动模式，取决于某个事件是否发生)优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数缺点：事件驱动型，流程不够清晰发布/订阅(观察者模式)类似于事件监听，但是可以通过‘消息中心‘，了解现在有多少发布者，多少订阅者Promise对象优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数；缺点：编写和理解，相对比较难Generator函数优点：函数体内外的数据交换、错误处理机制缺点：流程管理不方便async函数优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。缺点：错误处理机制-对原生 Javascript 了解方向数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScriptsort 快速打乱数组12345var arr = [1,2,3,4,5,6,7,8,9,10];arr.sort(()=&gt; Math.random() - 0.5)//利用sort return 大于等于0不交换位置，小于0交换位置// [5, 8, 4, 3, 2, 9, 10, 6, 1, 7]复制代码数组去重操作ES6 Setfor循环indexOffor循环includessort详细操作前往：https://juejin.cn/post/6844904035619700750JS 原生拖拽节点给需要拖拽的节点绑定mousedown , mousemove , mouseup事件mousedown事件触发后，开始拖拽mousemove时，需要通过event.clientX 和 clientY获取拖拽位置，并实时更新位置mouseup时，拖拽结束需要注意浏览器边界值，设置拖拽范围深拷贝、浅拷贝所有的基础数据类型的赋值操作都是深拷贝通常利用上面这点，来对引用数据类型做递归深拷贝浅拷贝：Object.assign或者 扩展运算符深拷贝：JSON.parse(JSON.stringify(object))深层递归* 局限性：会忽略 undefined，不能序列化函数，不能解决循环引用的对象 -详细信息更多：https://juejin.cn/post/6906369563793817607**节流防抖节流：每隔一段时间执行一次，通常用在高频率触发的地方，降低频率。–如：鼠标滑动 拖拽防抖：一段时间内连续触发，不执行，直到超出限定时间执行最后一次。–如：input模糊搜索更多节流、防抖，细节介绍：https://juejin.cn/post/6844903592898330638变量提升当执行JS代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境js b() // call b console.log(a) // undefined var a = &#39;Hello world&#39; function b() { console.log(&#39;call b&#39;) }变量提升 这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用123456789b() // call b secondfunction b() &#123; console.log(&apos;call b fist&apos;)&#125;function b() &#123; console.log(&apos;call b second&apos;)&#125;var b = &apos;Hello world&apos;复制代码js 单线程单线程 - 只有一个线程，只能做一件事原因 - 避免DOM渲染的冲突* 浏览器需要渲染`DOM` * `JS`可以修改`DOM`结构 * `JS`执行的时候，浏览器`DOM`渲染会暂停 * 两段`JS`也不能同时执行（都修改`DOM`就冲突了） * `webworker`支持多线程，但是不能访问`DOM` 解决方案 - 异步说说 event loop首先，js是单线程的，主要的任务是处理用户的交互，而用户的交互无非就 是响应DOM的增删改，使用事件队列的形式，一次事件循环只处理一个事件 响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件， 那么事件队列的事件从哪里被push进来的呢。那就是另外一个线程叫事件触 发线程做的事情了，他的作用主要是在定时触发器线程、异步HTTP请求线程 满足特定条件下的回调函数push到事件队列中，等待js引擎空闲的时候去 执行，当然js引擎执行过程中有优先级之分，首先js引擎在一次事件循环中， 会先执行 js 线程的主任务，然后会去查找是否有微任务microtask（promise），如果有那就优先执行微任务，如果没有，在去查找 宏任务macrotask（setTimeout、setInterval）进行执行更详细的介绍前往：https://juejin.cn/post/6844903598573240327描述下 thisthis，函数执行的上下文，可以通过apply ， call ， bind改变this的指向。对于匿名函数或者直接调用的函数来说，this 指向全局上下文（浏览 器为window，NodeJS为 global），剩下的函数调用，那就是谁调用它，this就指向谁。当然还有es6的箭头函数，箭头函数的指向取决于该箭头函 数声明的位置，在哪里声明，this就指向哪里ajax、axios、fetch 区别ajax：本身是针对MVC的编程,不符合现在前端MVVM的浪潮基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）axios：从浏览器中创建XMLHttpRequest从node.js发出http请求支持Promise API拦截请求和响应转换请求和响应数据取消请求自动转换JSON数据客户端支持防止CSRF/XSRFfetch：只对网络请求报错，对 400 ， 500 都当做成功的请求，需要封装去处理默认不会带cookie，需要添加配置项（尴尬）本身无自带abort，无法超时控制，可以使用 AbortController 解决取消请求问题。没有办法原生监测请求的进度，而XHR可以更多 fetch 知识前往：阮一峰 fetch优化 篇SEO 优化合理的title 、 description 、 keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可语义化的HTML代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取重要内容不要用js输出：爬虫不会执行 js 获取内容少用iframe：搜索引擎不会抓取iframe中的内容非装饰性图片必须加alt提高网站速度：网站速度是搜索引擎排序的一个重要指标server 优化减少HTTP请求，合并文件、雪碧图减少DNS查询，使用缓存减少Dom元素的数量使用CDN配置ETag,http 缓存的手段对组件使用Gzip压缩减少cookie的大小css 优化将样式表放在页面顶部使用less scss表达式使用link不适用@import引入样式压缩css禁止使用gif图片实现loading效果（降低 CPU 消耗，提升渲染性能）使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流）对于一些小图标，可以使用base64位编码，以减少网络请求。页面头部的&lt;style&gt; &lt;script&gt;会阻塞页面；（因为 Renderer 进程中 JS 线程和渲染线程是互斥的）当需要设置的样式很多时设置className而不是直接操作stylejs 方面将脚本放到页面底部将js外部引入压缩js使用Eslint语法检测减少Dom的操作熟练使用设计模式禁止使用iframe（阻塞父文档onload事件）页面中空的href 和 src会阻塞页面其他资源的加载网页gzip ， CDN托管，data缓存 ，图片服务器webpack 优化点代码压缩插件UglifyJsPlugin服务器启用gzip压缩按需加载资源文件require.ensure优化devtool中的source-map剥离css文件，单独打包去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致开发环境不做无意义的工作如提取css计算文件 hash 等配置devtool优化构建时的搜索路径 指明需要构建目录及不需要构建目录其他优化点为什么利用多个域名来存储网站资源会更有效？CDN缓存更方便突破浏览器并发限制节约cookie带宽节约主域名的连接数，优化页面响应速度防止不必要的安全问题Other 篇从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？dns缓存cdn缓存浏览器缓存服务器缓存常见 web 安全及防护原理sql注入原理：就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令* 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双 &quot;-&quot; 进行转换等 * 永远不要使用动态拼装SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取 * 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接 * 不要把机密信息明文存放，请加密或者 hash 掉密码和敏感的信息 XSS防范方法：Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点首先代码里对用户输入的地方和变量都需要仔细检查长度和对 ”&lt;”,”&gt;”,”;”,”’” 等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag弄出来。这一个层面做好，至少可以堵住超过一半的XSS攻击XSS与CSRF有什么区别：XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤，1.登录受信任网站 A ，并在本地生成Cookie。2.在不登出 A 的情况下，访问危险网站 B服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数通过验证码的方法-用过哪些设计模式单例模式策略模式代理模式迭代器模式发布—订阅模式更多设计模式 15 种：https://www.cnblogs.com/imwtr/p/9451129.htmlNode 的应用场景特点* 它是一个`javascript`运行环境 * 依赖于`chrome V8`引擎进行代码解释 * 事件驱动 * 非阻塞 I/o * 单进程，单线程 优点对于文件的读写处理效率极高高并发（node最重要的优点）缺点只支持单核CPU，不能充分利用CPU可靠性低，一旦代码某个环节崩溃，整个系统都崩溃-那些操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在setTimeout的第一个参数使用字符串而非函数的话，会引发内存泄漏闭包使用不当简单介绍下 webpackWebPack是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML 、 Javascript 、 CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。谈谈你对 gulp 的了解gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成gulp的核心概念：流流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作Gulp的特点：* 易于使用：通过代码优于配置的策略，`gulp`让简单的任务简单，复杂的任务可管理 * 构建快速 利用`Node.js`流的威力，你可以快速构建项目并减少频繁的 IO 操作 * 易于学习 通过最少的`API`，掌握`gulp`毫不费力，构建工作尽在掌握：如同一系列流管道 -渐进增强和优雅降级渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容谈一谈你理解的函数式编程简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是”第一等公民”、只用”表达式”想了解更多，移步这里：https://zhuanlan.zhihu.com/p/57708956Vue 的双向绑定数据的原理vue.js则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter ， getter，在数据变动时发布消息给订阅者，触发相应的监听回调写个简单 Loaderloader就是一个node模块，它输出了一个函数。当某种资源需要用这个loader转换时，这个函数会被调用。并且，这个函数可以通过提供给它的this上下文访问Loader API 。 reverse-txt-loader1234567891011121314// 定义module.exports = function(src) &#123; //src是原文件内容（abcde），下面对内容进行处理，这里是反转 var result = src.split(&apos;&apos;).reverse().join(&apos;&apos;); //返回JavaScript源码，必须是String或者Buffer return `module.exports = &apos;$&#123;result&#125;&apos;`;&#125;//使用&#123;test: /\.txt$/,use: [&#123;&apos;./path/reverse-txt-loader&apos;&#125;]&#125;,作者：@baby 张链接：https://juejin.cn/post/6914831351271292936来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络基础知识]]></title>
    <url>%2F2019%2F10%2F24%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1）什么是链接？链接是指两个设备之间的连接。它包括用于一个设备能够与另一个设备通信的电缆类型和协议。2）OSI 参考模型的层次是什么？有 7 个 OSI 层：物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。3）什么是骨干网？骨干网络是集中的基础设施，旨在将不同的路由和数据分发到各种网络。它还处理带宽管理和各种通道。4）什么是 LAN？LAN 是局域网的缩写。它是指计算机与位于小物理位置的其他网络设备之间的连接。5）什么是节点？节点是指连接发生的点。它可以是作为网络一部分的计算机或设备。为了形成网络连接，需要两个或更多个节点。6）什么是路由器？路由器可以连接两个或更多网段。这些是在其路由表中存储信息的智能网络设备，例如路径，跳数等。有了这个信息，他们就可以确定数据传输的最佳路径。路由器在 OSI 网络层运行。7）什么是点对点链接？它是指网络上两台计算机之间的直接连接。除了将电缆连接到两台计算机的 NIC卡之外，点对点连接不需要任何其他网络设备。8）什么是匿名 FTP？匿名 FTP 是授予用户访问公共服务器中的文件的一种方式。允许访问这些服务器中的数据的用户不需要识别自己，而是以匿名访客身份登录。9）什么是子网掩码？子网掩码与 IP 地址组合，以识别两个部分：扩展网络地址和主机地址。像 IP 地址一样，子网掩码由 32 位组成。10）UTP 电缆允许的最大长度是多少？UTP 电缆的单段具有 90 到 100 米的允许长度。这种限制可以通过使用中继器和开关来克服11）什么是数据封装？数据封装是在通过网络传输信息之前将信息分解成更小的可管理块的过程。在这个过程中，源和目标地址与奇偶校验一起附加到标题中。12）描述网络拓扑网络拓扑是指计算机网络的布局。它显示了设备和电缆的物理布局，以及它们如何连接到彼此。13）什么是 VPN？VPN 意味着虚拟专用网络，这种技术允许通过网络（如 Internet）创建安全通道。例如，VPN 允许您建立到远程服务器的安全拨号连接。14）简要描述 NAT。NAT 是网络地址转换。这是一种协议，为公共网络上的多台计算机提供一种方式来共享到 Internet 的单一连接。15）OSI 参考模型下网络层的工作是什么？网络层负责数据路由，分组交换和网络拥塞控制。路由器在此层下运行。16）网络拓扑如何影响您在建立网络时的决策？网络拓扑决定了互连设备必须使用什么媒介。它还作为适用于设置的材料，连接器和终端的基础。17）什么是 RIP？RIP，路由信息协议的简称由路由器用于将数据从一个网络发送到另一个网络。它通过将其路由表广播到网络中的所有其他路由器来有效地管理路由数据。它以跳数为单位确定网络距离。18）什么是不同的方式来保护计算机网络？有几种方法可以做到这一点。在所有计算机上安装可靠和更新的防病毒程序。确保防火墙的设置和配置正确。用户认证也将有很大的帮助。所有这些组合将构成一个高度安全的网络。19）什么是 NIC？NIC 是网络接口卡（网卡）的缩写。这是连接到 PC 以连接到网络沈北。每个 NIC都有自己的 MAC 地址，用于标识网络上的 PC。20）什么是 WAN？WAN 代表广域网。它是地理上分散的计算机和设备的互连。它连接位于不同地区和国家/地区的网络。21）OSI 物理层的重要性是什么？物理层进行从数据位到电信号的转换，反之亦然。这是网络设备和电缆类型的考虑和设置。22）TCP/IP 下有多少层？有四层：网络层，互联网层，传输层和应用层。23）什么是代理服务器，它们如何保护计算机网络？代理服务器主要防止外部用户识别内部网络的 IP 地址。不知道正确的 IP 地址，甚至无法识别网络的物理位置。代理服务器可以使外部用户几乎看不到网络。24）OSI 会话层的功能是什么？该层为网络上的两个设备提供协议和方法，通过举行会话来相互通信。这包括设置会话，管理会话期间的信息交换以及终止会话时的解除过程。25）实施容错系统的重要性是什么？有限吗？容错系统确保持续的数据可用性。这是通过消除单点故障来实现的。但是，在某些情况下，这种类型的系统将无法保护数据，例如意外删除。26）10Base-T 是什么意思？10 是指数据传输速率，在这种情况下是 10Mbps。“Base”是指基带。T 表示双绞线，这是用于该网络的电缆。27）什么是私有 IP 地址？专用 IP 地址被分配用于内部网。这些地址用于内部网络，不能在外部公共网络上路由。这些确保内部网络之间不存在任何冲突，同时私有 IP 地址的范围同样可重复使用于多个内部网络，因为它们不会“看到”彼此。28）什么是 NOS？NOS 或网络操作系统是专门的软件，其主要任务是向计算机提供网络连接，以便能够与其他计算机和连接的设备进行通信。29）什么是 DoS？DoS 或拒绝服务攻击是试图阻止用户访问互联网或任何其他网络服务。这种攻击可能有不同的形式，由一群永久者组成。这样做的一个常见方法是使系统服务器过载，使其无法再处理合法流量，并将被强制重置。30）什么是 OSI，它在电脑网络中扮演什么角色？OSI（开放系统互连）作为数据通信的参考模型。它由 7 层组成，每层定义了网络设备如何相互连接和通信的特定方面。一层可以处理所使用的物理介质，而另一层则指示如何通过网络实际传输数据。31）电缆被屏蔽并具有双绞线的目的是什么？其主要目的是防止串扰。串扰是电磁干扰或噪声，可能影响通过电缆传输的数据。32）地址共享的优点是什么？通过使用地址转换而不是路由，地址共享提供了固有的安全性优势。这是因为互联网上的主机只能看到提供地址转换的计算机上的外部接口的公共 IP 地址，而不是内部网络上的私有 IP 地址。33）什么是 MAC 地址？MAC 或媒介访问控制，可以唯一地标识网络上的设备。它也被称为物理地址或以太网地址。MAC 地址由 6 个字节组成。34）在 OSI 参考模型方面，TCP/IP 应用层的等同层或多层是什么？TCP/IP 应用层实际上在 OSI 模型上具有三个对等体：会话层，表示层和应用层。35）如何识别给定 IP 地址的 IP 类？通过查看任何给定 IP 地址的第一个八位字节，您可以识别它是 A 类，B 类还是 C类。如果第一个八位字节以 0 位开头，则该地址为 Class A.如果以位 10 开头，则该地址为 B 类地址。如果从 110 开始，那么它是 C 类网络。36）OSPF 的主要目的是什么？OSPF 或开放最短路径优先，是使用路由表确定数据交换的最佳路径的链路状态路由协议。37）什么是防火墙？防火墙用于保护内部网络免受外部攻击。这些外部威胁可能是黑客谁想要窃取数据或计算机病毒，可以立即消除数据。它还可以防止来自外部网络的其他用户访问专用网络。38）描述星形拓扑星形拓扑由连接到节点的中央集线器组成。这是最简单的设置和维护之一。39）什么是网关？网关提供两个或多个网段之间的连接。它通常是运行网关软件并提供翻译服务的计算机。该翻译是允许不同系统在网络上通信的关键。40）星型拓扑的缺点是什么？星形拓扑的一个主要缺点是，一旦中央集线器或交换机被损坏，整个网络就变得不可用了。41）什么是 SLIP？SLIP 或串行线路接口协议实际上是在 UNIX 早期开发的旧协议。这是用于远程访问的协议之一。42）给出一些私有网络地址的例子。10.0.0.0，子网掩码为 255.0.0.0172.16.0.0，子网掩码为 255.240.0.0千人ccie认证交流群463904693领取最新CCIE考试题库CCIE 认证经验分享千人群：463904693192.168.0.0，子网掩码为 255.255.0.043）什么是 tracert？Tracert 是一个 Windows 实用程序，可用于跟踪从路由器到目标网络的数据采集的路由。它还显示了在整个传输路由期间采用的跳数。44）网络管理员的功能是什么？网络管理员有许多责任，可以总结为 3 个关键功能：安装网络，配置网络设置以及网络的维护/故障排除。45）描述对等网络的一个缺点。当您正在访问由网络上的某个工作站共享的资源时，该工作站的性能会降低。46）什么是混合网络？混合网络是利用客户端 - 服务器和对等体系结构的网络设置。47）什么是 DHCP？DHCP 是动态主机配置协议的缩写。其主要任务是自动为网络上的设备分配 IP 地址。它首先检查任何设备尚未占用的下一个可用地址，然后将其分配给网络设备。48）ARP 的主要工作是什么？ARP 或地址解析协议的主要任务是将已知的 IP 地址映射到 MAC 层地址。49）什么是 TCP/IP？TCP/IP 是传输控制协议/互联网协议的缩写。这是一组协议层，旨在在不同类型的计算机网络（也称为异构网络）上进行数据交换。50）如何使用路由器管理网络？路由器内置了控制台，可让您配置不同的设置，如安全和数据记录。您可以为计算机分配限制，例如允许访问的资源，或者可以浏览互联网的某一天的特定时间。您甚至可以对整个网络中看不到的网站施加限制。51）当您希望在不同平台（如 UNIX 系统和 Windows 服务器之间）传输文件时，可以应用什么协议？使用 FTP（文件传输协议）在这些不同的服务器之间进行文件传输。这是可能的，因为 FTP 是平台无关的。52）默认网关的使用是什么？默认网关提供了本地网络连接到外部网络的方法。用于连接外部网络的默认网关通常是外部路由器端口的地址。53）保护网络的一种方法是使用密码。什么可以被认为是好的密码？良好的密码不仅由字母组成，还包括字母和数字的组合。结合大小写字母的密码比使用所有大写字母或全部小写字母的密码有利。密码必须不能被黑客很容易猜到，比如日期，姓名，收藏夹等等。54）UTP 电缆的正确终止率是多少？非屏蔽双绞线网线的正常终止是 100 欧姆。55）什么是 netstat？Netstat 是一个命令行实用程序。它提供有关连接当前 TCP/IP 设置的有用信息。56）C 类网络中的网络 ID 数量是多少？对于 C 类网络，可用的网络 ID 位数为 21。可能的网络 ID 数目为 2，提高到 21或 2,097,152。每个网络 ID 的主机 ID 数量为 2，增加到 8 减去 2，或 254。57）使用长于规定长度的电缆时会发生什么？电缆太长会导致信号丢失。这意味着数据传输和接收将受到影响，因为信号长度下降。58）什么常见的软件问题可能导致网络缺陷？软件相关问题可以是以下任何一种或其组合：- 客户端服务器问题- 应用程序冲突- 配置错误- 协议不匹配- 安全问题- 用户政策和权利问题59）什么是 ICMP？ICMP 是 Internet 控制消息协议。它为 TCP/IP 协议栈内的协议提供消息传递和通信。这也是管理由 PING 等网络工具使用的错误信息的协议。60）什么是 Ping？Ping 是一个实用程序，允许您检查网络上的网络设备之间的连接。您可以使用其IP 地址或设备名称（如计算机名称）ping 设备。61）什么是点对点（P2P）？对等是不在服务器上回复的网络。该网络上的所有 PC 都是单独的工作站。62）什么是 DNS？DNS 是域名系统。该网络服务的主要功能是为 TCP/IP 地址解析提供主机名。63）光纤与其他介质有什么优势？光纤的一个主要优点是不太容易受到电气干扰。它还支持更高的带宽，意味着可以发送和接收更多的数据。长距离信号降级也非常小。64）集线器和交换机有什么区别？集线器充当多端口中继器。然而，随着越来越多的设备连接到它，它将无法有效地管理通过它的流量。交换机提供了一个更好的替代方案，可以提高性能，特别是在所有端口上预期有高流量时。65）Windows RRAS 服务支持的不同网络协议是什么？支持三种主要的网络协议：NetBEUI，TCP/IP 和 IPX。66）A，B 和 C 类网络中的最大网络和主机是什么？对于 A 类，有 126 个可能的网络和 16,777,214 个主机对于 B 类，有 16,384 个可能的网络和 65,534 个主机对于 C 类，有 2,097,152 个可能的网络和 254 个主机67）直通电缆的标准颜色顺序是什么？橙色/白色，橙色，绿色/白色，蓝色，蓝色/白色，绿色，棕色/白色，棕色。68）什么协议落在 TCP/IP 协议栈的应用层之下？以下是 TCP/IP 应用层协议：FTP，TFTP，Telnet 和 SMTP。69）您需要连接两台电脑进行文件共享。是否可以这样做，而不使用集线器或路由器？是的，您可以使用一根电缆将两台计算机连接在一起。在这种情况下可以使用交叉型电缆。在这种设置中，一条电缆的数据传输引脚连接到另一条电缆的数据接收引脚，反之亦然。70）什么是 ipconfig？Ipconfig 是一个常用于识别网络上计算机的地址信息的实用程序。它可以显示物理地址以及 IP 地址。71）直通和交叉电缆有什么区别？直通电缆用于将计算机连接到交换机，集线器或路由器。交叉电缆用于将两个类似设备连接在一起，如 PC 到 PC 或集线器到集线器。72）什么是客户端/服务器？客户端/服务器是一种类型的网络，其中一个或多个计算机充当服务器。服务器提供集中的资源库，如打印机和文件。客户端是指访问服务器的工作站。73）描述网络。网络是指用于数据通信的计算机和外围设备之间的互连。可以使用有线电缆或通过无线链路进行网络连接。74）将 NIC 卡从一台 PC 移动到另一台 PC 时，MAC 地址是否也被转移？是的，那是因为 MAC 地址是硬连线到 NIC 电路，而不是 PC。这也意味着当 NIC卡被另一个替换时，PC 可以具有不同的 MAC 地址。75）解释聚类支持群集支持是指网络操作系统在容错组中连接多台服务器的能力。这样做的主要目的是在一台服务器发生故障的情况下，集群中的下一个服务器将继续进行所有处理。76）在包含两个服务器和二十个工作站的网络中，安装防病毒程序的最佳位置是哪里？必须在所有服务器和工作站上安装防病毒程序，以确保保护。这是因为个人用户可以访问任何工作站，并在插入可移动硬盘驱动器或闪存驱动器时引入计算机病毒。77）描述以太网。以太网是当今使用的流行网络技术之一。它是在 20 世纪 70 年代初开发的，并且基于 IEEE 中规定的规范。以太网在局域网中使用。78）实现环形拓扑有什么缺点？如果网络上的一个工作站发生故障，可能会导致整个网络丢失。另一个缺点是，当需要在网络的特定部分进行调整和重新配置时，整个网络也必须被暂时关闭。79）CSMA/CD 和 CSMA/CA 有什么区别？CSMA/CD 或碰撞检测，每当碰撞发生时重新发送数据帧。CSMA/CA 或碰撞避免，将首先在数据传输之前广播意图发送。80）什么是 SMTP？SMTP 是简单邮件传输协议的缩写。该协议处理所有内部邮件，并在 TCP/IP 协议栈上提供必要的邮件传递服务。81）什么是组播路由？组播路由是一种有针对性的广播形式，将消息发送到所选择的用户组，而不是将其发送到子网上的所有用户。82）加密在网络上的重要性是什么？加密是将信息转换成用户不可读的代码的过程。然后使用秘密密钥或密码将其翻译或解密回其正常可读格式。加密有助于确保中途截获的信息仍然不可读，因为用户必须具有正确的密码或密钥。83）如何安排和显示 IP 地址？IP 地址显示为一系列由周期或点分隔的四位十进制数字。这种安排的另一个术语是点分十进制格式。一个例子是 192.168.101.284）解释认证的重要性。认证是在用户登录网络之前验证用户凭据的过程。它通常使用用户名和密码进行。这提供了限制来自网络上的有害入侵者的访问的安全手段。85）隧道模式是什么意思？这是一种数据交换模式，其中两个通信计算机本身不使用 IPSec。相反，将 LAN连接到中转网络的网关创建了一个使用 IPSec 协议来保护通过它的所有通信的虚拟隧道。86）建立 WAN 链路涉及的不同技术有哪些？模拟连接 - 使用常规电话线；数字连接 - 使用数字电话线；交换连接 - 使用发送方和接收方之间的多组链接来移动数据。87）网格拓扑的一个优点是什么？在一个链接失败的情况下，总会有另一个链接可用。网状拓扑实际上是最容错的网络拓扑之一。88）在排除计算机网络问题时，可能会发生什么常见的硬件相关问题？大部分网络由硬件组成。这些领域的问题可能包括硬盘故障，NIC 损坏甚至硬件启动。不正确的硬件配置也是其中一个疑难问题。89）可以做什么来修复信号衰减问题？处理这种问题的常见方法是使用中继器和集线器，因为它将有助于重新生成信号，从而防止信号丢失。检查电缆是否正确终止也是必须的。90）动态主机配置协议如何协助网络管理？网络管理员不必访问每台客户端计算机来配置静态 IP 地址，而是可以应用动态主机配置协议来创建称为可以动态分配给客户端的范围的 IP 地址池。91）解释网络概念的概况？配置文件是为每个用户设置的配置设置。例如，可以创建将用户置于组中的配置文件。92）什么是 Sneakernet？Sneakernet 被认为是最早的联网形式，其中使用可移动介质（如磁盘，磁带）物理传输数据。93）IEEE 在计算机网络中的作用是什么？IEEE 或电气和电子工程师学会是由电气和电子设备标准发布和管理的工程师组成的组织。这包括网络设备，网络接口，cablings 和连接器。94）TCP/IP Internet 层下有哪些协议？该层管理的协议有 4 种。这些是 ICMP，IGMP，IP 和 ARP。95）谈到网络，什么是权限？权限是指在网络上执行特定操作的授权许可。网络上的每个用户可以分配个人权限，具体取决于该用户必须允许的内容。96）建立 VLAN 的一个基本要求是什么？需要一个 VLAN，因为在交换机级别只有一个广播域，这意味着每当新用户连接时，该信息都会传播到整个网络。交换机上的 VLAN 有助于在交换机级别创建单独的广播域。它用于安全目的。97）什么是 IPv6？IPv6 或 Internet 协议版本 6 被开发以替代 IPv4。目前，IPv4 正在用于控制互联网流量，但 IPv4 已经饱和。IPv6 能够克服这个限制。98）什么是 RSA 算法？RSA 是 Rivest-Shamir-Adleman 算法的缩写。它是目前最常用的公钥加密算法。99）什么是网格拓扑？网格拓扑是一种设置，其中每个设备都直接连接到网络上的每个其他设备。因此，它要求每个设备具有至少两个网络连接。100）100Base-FX 网络的最大段长度是多少？使用 100Base-FX 的网段的最大允许长度为 412 米。整个网络的最大长度为 5 公里。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git命令]]></title>
    <url>%2F2019%2F10%2F17%2FGit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[命令大全reset–mixed：回退到某个版本，只保留源码，回退commit和stage信息–soft：回退到某个版本，只回退了commit的信息，不会恢复stage(如果还要提交，直接commit即可)–hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容HEAD^^：回退到前N次的提交，是上述的快捷表示branch[-v]：查看本地分支-D[本地分支名]：删除本地的分支–remote/-r：查看本地分支追踪的是哪一个远程分支-a：查看所有远程分支–track newLocalBranch remoteName/remoteBranch：取回远程主机的更新后，可以在它的基础上，使用gitcheckout命令创建一个新的分支，并使新建的本地分支，追踪指定的远程分支–set-upstream master origin/next：手动建立起追踪关系logdiffadd.添加当前”git status”下显示的除删除文件外的所有修改–all：添加所有修改，包括删除文件clonegit clone &lt;版本库的网址&gt; [本地目录名]：该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数-o克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定$git clone -o jQuery https://github.com/jquery/jquery.git$git remotejQueryremote不带选项的时候，git remote命令列出所有远程主机$git remoteorigin-v参看远程主机的网址$git remote -vorigin git@github.com:jquery/jquery.git(fetch)origin git@github.com:jquery/jquery.git(push)git remote show &lt;主机名&gt;查看该远程主机的详细信息，一般远程主机名默认命名为origingit remote add &lt;主机名&gt; &lt;网址&gt;用于添加远程主机git remote rm &lt;主机名&gt;用于删除远程主机git remote rename &lt;原主机名&gt; &lt;新主机名&gt;用于重命名远程主机名fetchgerritgit fetch &lt;远程主机名&gt;一旦远程主机的版本库有了更新(Git属于叫做commit)，需要将这些更新取回本地，这时就要用到git fetch命令，通常用来查看其他人的进程，对本地的代码没有影响。默认取回所有分支的更新git fetch &lt;远程主机名&gt; &lt;分支名&gt;指定分支名，取回特定分支的更新$git fetch origin master：取回oringin主机的master分支pullgit pull &lt;远程主机名&gt; &lt;远程分支名&gt;：&lt;本地分支名&gt;取回远程主机某个分支的更新，再与本地的指定分支合并git pull &lt;远程主机名&gt; &lt;远程分支名&gt;如果远程分支是与当前分支合并，则冒号后面的部分可以省略命令表示取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。$git fetch origin$git merge origin/nextgit pull origin如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名git pull如果当前分支只有一个追踪分支，连远程分支名都可以省略git pull -p如果远程主机删除了某个分支，默认情况下，git pull不会在拉取远程分支的时候，删除对应的本地分支。加上参数-p就会在本地删除远程已经删除的分支–rebase &lt;远程主机名&gt; &lt;远程分支名&gt; : &lt;本地分支名&gt;pushgit push &lt;远程主机名&gt; &lt;远程分支名&gt;：&lt;本地分支名&gt;*]]></content>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript6]]></title>
    <url>%2F2019%2F10%2F16%2FES6%2F</url>
    <content type="text"><![CDATA[Babel转码器Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。即，你可以用ES6的方式编写程序，又不用担心现有环境是否支持。下面是一个例子1234567//转码前input.map(item =&gt; item + 1);//转码后input.map(function(item)&#123; return item + 1;&#125;);上面的原始代码用了箭头函数，这个特性还没有得到广泛支持，Babel将其转为普通函数，就能在现有的JavaScript环境执行配置文件.babelrcBabel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。该文件用来设置转码规则和插件，基本格式如下1234&#123; "presets":[], "plugins":[]&#125;presets字段let和const命令let命令基本用法ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效1234567&#123; let a = 10; var b = 1;&#125;a //ReferenceError: a is not defined.b //1上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。for循环的计数器，就很合适使用let命令。1234for (let i = 0; i &lt; arr.length; i++) &#123;&#125;console.log(i);//ReferenceError: i is not defined上面代码的计数器i，只在for循环体内有效。下面的代码如果使用var，最后输出的是10。1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。不存在变量提升let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。12345console.log(foo); // 输出undefinedconsole.log(bar); // 报错ReferenceErrorvar foo = 2;let bar = 2;上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125;上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125;上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。12typeof x; // ReferenceErrorlet x;上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。1typeof undeclared_variable // "undefined"上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。有些“死区”比较隐蔽，不太容易发现。12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。1234function bar(x = 2, y = x) &#123; return [x, y];&#125;bar(); // [2, 2]ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。不允许重复声明let不允许在相同作用域内，重复声明同一个变量。1234567891011// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125;因此，不能在函数内部重新声明参数。123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125;块级作用域为什么需要块级作用域?ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景，内层变量可能会覆盖外层变量。12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = "hello world"; &#125;&#125;f(); // undefined上面代码中，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。第二种场景，用来计数的循环变量泄露为全局变量。1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。ES6的块级作用域let实际上为JavaScript新增了块级作用域。1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125;上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用var定义变量n，最后输出的值就是10。ES6允许块级作用域的任意嵌套。1&#123;&#123;&#123;&#123;&#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;;上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;;内层作用域可以定义外层作用域的同名变量。1234&#123;&#123;&#123;&#123; let insane = 'Hello World'; &#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;;块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。1234567891011// IIFE写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125;块级作用域与函数声明函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。12345678910// 情况一if (true) &#123; function f() &#123;&#125;&#125;// 情况二try &#123; function f() &#123;&#125;&#125; catch(e) &#123;&#125;上面代码的两种函数声明，根据ES5的规定都是非法的。但是，浏览器没有遵守这个规定，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。123456// ES5严格模式'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 报错ES6引入了块级作用域，明确允许在块级作用域之中声明函数。123456// ES6严格模式'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 不报错并且ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。123456789function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());上面代码在ES5中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。12345678// ES5版本function f() &#123; console.log('I am outside!'); &#125;(function () &#123; function f() &#123; console.log('I am inside!'); &#125; if (false) &#123; &#125; f();&#125;());ES6的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响，实际运行的代码如下。12345// ES6版本function f() &#123; console.log('I am outside!'); &#125;(function () &#123; f();&#125;());很显然，这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。允许在块级作用域内声明函数。函数声明类似于var，即会提升到全局作用域或函数作用域的头部。同时，函数声明还会提升到所在的块级作用域的头部。注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。前面那段代码，在Chrome环境下运行会报错。1234567891011// ES6的浏览器环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function上面的代码报错，是因为实际运行的是下面的代码。1234567891011// ES6的浏览器环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; var f = undefined; if (false) &#123; function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。123456789101112131415// 函数声明语句&#123; let a = 'secret'; function f() &#123; return a; &#125;&#125;// 函数表达式&#123; let a = 'secret'; let f = function () &#123; return a; &#125;;&#125;另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。12345678910// 不报错'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 报错'use strict';if (true) function f() &#123;&#125;const命令const声明一个只读的常量。一旦声明，常量的值就不能改变。12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable.上面代码表明改变常量的值会报错。const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。12const foo;// SyntaxError: Missing initializer in const declaration上面代码表示，对于const来说，只声明不赋值，就会报错。const的作用域与let命令相同：只在声明所在的块级作用域内有效。12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not definedconst命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。1234if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125;上面代码在常量MAX声明之前就调用，结果报错。const声明的常量，也与let一样不可重复声明。123456var message = "Hello!";let age = 25;// 以下两行都会报错const message = "Goodbye!";const age = 30;对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。1234567const foo = &#123;&#125;;foo.prop = 123;foo.prop// 123foo = &#123;&#125;; // TypeError: "foo" is read-only上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。下面是另一个例子。1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。如果真的想将对象冻结，应该使用Object.freeze方法。12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123;上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, value) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;;ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。全局对象的属性全局对象是最顶层的对象，在浏览器环境指的是window对象，在Node.js指的是global对象。ES5之中，全局对象的属性与全局变量是等价的。12345window.a = 1;a // 1a = 2;window.a // 2上面代码中，全局对象的属性赋值与全局变量的赋值，是同一件事。（对于Node来说，这一条只对REPL环境适用，模块环境之中，全局变量必须显式声明成global对象的属性。）未声明的全局变量，自动成为全局对象window的属性，这被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了两个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道，其次程序员很容易不知不觉地就创建了全局变量（比如打字出错）。另一方面，从语义上讲，语言的顶层对象是一个有实体含义的对象，也是不合适的。ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是全局对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与全局对象的属性脱钩。1234567var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined上面代码中，全局变量a由var命令声明，所以它是全局对象的属性；全局变量b由let命令声明，所以它不是全局对象的属性，返回undefined。变量的解构赋值数组的解构赋值基本用法ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。以前，为变量赋值，只能直接指定值。123var a = 1;var b = 2;var c = 3;ES6允许写成下面这样。1var [a, b, c] = [1, 2, 3];上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // []如果解构不成功，变量的值就等于undefined。12var [foo] = [];var [bar, foo] = [1];以上两种情况都属于解构不成功，foo的值都会等于undefined。另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4上面两个例子，都属于不完全解构，但是可以成功。如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;;上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。解构赋值不仅适用于var命令，也适用于let和const命令。123var [v1, v2, ..., vN ] = array;let [v1, v2, ..., vN ] = array;const [v1, v2, ..., vN ] = array;对于Set结构，也可以使用数组的解构赋值。12let [x, y, z] = new Set(["a", "b", "c"]);x // "a"事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。1234567891011function* fibs() &#123; var a = 0; var b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;var [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5上面代码中，fibs是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。注：Iterator：迭代器function*（构造器函数）： ES6中定义了一种新的函数.用function定义生成器函数,这种函数会返回一个generator对象.生成器函数在执行时可以暂停，然后又可以在暂停处接着执行。默认值解构赋值允许指定默认值。12345var [foo = true] = [];foo // true[x, y = 'b'] = ['a']; // x='a', y='b'[x, y = 'b'] = ['a', undefined]; // x='a', y='b'注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。12345var [x = 1] = [undefined];x // 1var [x = 1] = [null];x // null上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。12345function f() &#123; console.log('aaa');&#125;let [x = f()] = [1];上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。123456let x;if ([1][0] === undefined) &#123; x = f();&#125; else &#123; x = [1][0];&#125;默认值可以引用解构赋值的其他变量，但该变量必须已经声明。1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。对象的解构赋值解构不仅可以用于数组，还可以用于对象。123var &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。123456var &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"var &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。如果变量名与属性名不一致，必须写成下面这样。1234567var &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world'这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。1var &#123; foo: foo, bar: bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。123var &#123; foo: baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // "aaa"foo // error: foo is not defined上面代码中，真正被赋值的是变量baz，而不是模式foo。注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。12345let foo;let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration "foo"let baz;let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration "baz"上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。12345let foo;(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功上面代码中，let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。和数组一样，解构也可以用于嵌套结构的对象。12345678910var obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;var &#123; p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"注意，这时p是模式，不是变量，因此不会被赋值。12345678910111213var node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // error: loc is undefinedstart // error: start is undefined上面代码中，只有line是变量，loc和start都是模式，不会被赋值。下面是嵌套赋值的例子。1234567let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true]对象的解构也可以指定默认值。123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x:y = 3&#125; = &#123;&#125;;y // 3var &#123;x:y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong"默认值生效的条件是，对象的属性值严格等于undefined。12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null上面代码中，如果x属性等于null，就不严格相等于undefined，导致默认值不会生效。如果解构失败，变量的值等于undefined。12var &#123;foo&#125; = &#123;bar: 'baz'&#125;;foo // undefined如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。12// 报错var &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;;上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。12var _tmp = &#123;baz: 'baz'&#125;;_tmp.foo.bar // 报错如果要将一个已经声明的变量用于解构赋值，必须非常小心。1234// 错误的写法var x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。12// 正确的写法(&#123;x&#125; = &#123;x: 1&#125;);上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。123(&#123;&#125; = [true, false]);(&#123;&#125; = 'abc');(&#123;&#125; = []);上面的表达式虽然毫无意义，但是语法是合法的，可以执行。对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。1let &#123; log, sin, cos &#125; = Math;上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。1234var arr = [1, 2, 3];var &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3上面代码对数组进行对象结构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》一章。字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o"类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。12let &#123;length : len&#125; = 'hello';len // 5数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError函数参数的解构赋值函数的参数也可以使用解构赋值。12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。下面是另一个例子。12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ]函数参数的解构也可以使用默认值。12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0]上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。注意，下面的写法会得到不一样的结果。12345678function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0]上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。undefined就会触发函数参数的默认值。12[1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ]圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。不能使用原括号的情况以下三种解构赋值不得使用圆括号。（1）变量声明语句中，不能带有圆括号。123456789// 全部报错var [(a)] = [1];var &#123;x: (c)&#125; = &#123;&#125;;var (&#123;x: c&#125;) = &#123;&#125;;var &#123;(x: c)&#125; = &#123;&#125;;var &#123;(x): c&#125; = &#123;&#125;;var &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。（2）函数参数中，模式不能带有圆括号。函数参数也属于变量声明，因此不能带有圆括号。12// 报错function f([(z)]) &#123; return z; &#125;（3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。123// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5];上面代码将整个模式放在圆括号之中，导致报错。12// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;];上面代码将嵌套模式的一层，放在圆括号之中，导致报错。可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。用途变量的解构赋值用途很多。（1）交换变量的值1[x, y] = [y, x];上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。（2）从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;var [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;var &#123; foo, bar &#125; = example();（3）函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来。1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;);（4）提取JSON数据解构赋值对提取JSON对象中的数据，尤其有用。12345678910var jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309]上面代码可以快速提取JSON数据的值。（5）函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;;指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。（6）遍历Map结构任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。123456789var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world如果只想获取键名，或者只想获取键值，可以写成下面这样。123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125;（7）输入模块的指定方法加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map");字符串的扩展ES6加强了对Unicode的支持，并且扩展了字符串对象字符的Unicode表示法JavaScript允许采用\uxxxx形式表示一个字符，其中“xxxx”表示字符的码点。12"\u0061"// "a"但是，这种表示法只限于\u0000——\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。12345"\uD842\uDFB7"// "𠮷""\u20BB7"// " 7"上面代码表示，如果直接在“\u”后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript会理解成“\u20BB+7”。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。1234567891011"\u&#123;20BB7&#125;"// "𠮷""\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"// "ABC"let hello = 123;hell\u&#123;6F&#125; // 123'\u&#123;1F680&#125;' === '\uD83D\uDE80'// true上面代码中，最后一个例子表明，大括号表示法与四字节的UTF-16编码是等价的。有了这种表示法之后，JavaScript共有6种方法可以表示一个字符。12345'\z' === 'z' // true'\172' === 'z' // true'\x7A' === 'z' // true'\u007A' === 'z' // true'\u&#123;7A&#125;' === 'z' // trueProxy和ReflectProxy概述Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。12345678910var obj = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;!`); return Reflect.set(target, key, value, receiver); &#125;&#125;);上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。123456obj.count = 1// setting count!++obj.count// getting count!// setting count!// 2上面代码说明，Proxy实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。ES6原生提供Proxy构造函数，用来生成Proxy实例。1var proxy = new Proxy(target, handler);Proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。下面是另一个拦截读取属性行为的例子。123456789var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。如果handler没有设置任何拦截，那就等同于直接通向原对象。12345var target = &#123;&#125;;var handler = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.a = 'b';target.a // "b"上面代码中，handler是一个空对象，没有任何拦截效果，访问handeler就等同于访问target。一个技巧是将Proxy对象，设置到object.proxy属性，从而可以在object对象上调用。1var object = &#123; proxy: new Proxy(target, handler) &#125;;Proxy实例也可以作为其他对象的原型对象。12345678var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);let obj = Object.create(proxy);obj.time // 35上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。同一个拦截器函数，可以设置拦截多个操作。12345678910111213141516171819202122232425var handler = &#123; get: function(target, name) &#123; if (name === 'prototype') &#123; return Object.prototype; &#125; return 'Hello, ' + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123;value: args[1]&#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2) // 1new fproxy(1,2) // &#123;value: 2&#125;fproxy.prototype === Object.prototype // truefproxy.foo // "Hello, foo"下面是Proxy支持的拦截操作一览。对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。（1）get(target, propKey, receiver)拦截对象属性的读取，比如proxy.foo和proxy[&#39;foo&#39;]。最后一个参数receiver是一个对象，可选，参见下面Reflect.get的部分。（2）set(target, propKey, value, receiver)拦截对象属性的设置，比如proxy.foo = v或proxy[&#39;foo&#39;] = v，返回一个布尔值。（3）has(target, propKey)拦截propKey in proxy的操作，以及对象的hasOwnProperty方法，返回一个布尔值。（4）deleteProperty(target, propKey)拦截delete proxy[propKey]的操作，返回一个布尔值。（5）ownKeys(target)拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回对象所有自身的属性，而Object.keys()仅返回对象可遍历的属性。（6）getOwnPropertyDescriptor(target, propKey)拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。（7）defineProperty(target, propKey, propDesc)拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。（8）preventExtensions(target)拦截Object.preventExtensions(proxy)，返回一个布尔值。（9）getPrototypeOf(target)拦截Object.getPrototypeOf(proxy)，返回一个对象。（10）isExtensible(target)拦截Object.isExtensible(proxy)，返回一个布尔值。（11）setPrototypeOf(target, proto)拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。（12）apply(target, object, args)拦截Proxy实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。（13）construct(target, args)拦截Proxy实例作为构造函数调用的操作，比如new proxy(...args)。Promise了解 Promise 吗？JS异步编程的一种解决方案，比传统的解决方案————回调函数和事件————更合理更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果从语法上讲，promise是一个对象，从它可以获取异步操作的消息从本意上讲，它是承诺，承诺过一段时间会给一个结果promise有三种状态pending（等待态）fulfiled（成功态）rejected（失败态）状态一旦改变，就不会再变。创造promise实例后，会立即执行Promise的两个特点对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，英文意思就是“承诺”，表示其他手段无法改变一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。这与事件Event完全不同，事件的特点就是，如果你错过了它，再去监听，是得不到结果的。Promise的缺点无法取消Promise，一旦新建就会立即执行，无法中途取消如果不设置回调函数，Promise内部抛出的错误，不会反应到外部当处于Pending状态时，无法得知目前进展到哪一个阶段如果某些事件不断反复发生，一般来说，使用stream模式是比部署Promise更好的选择promise的写法new Promise(请求1)​ .then(请求2,(请求结果1))​ .then(请求3,(请求结果2))​ .then(请求4,(请求结果3))​ .then(请求5,(请求结果4))​ .then(请求6,(请求结果5))​ .catch(处理异常(异常信息))Promise的API123456789101112131415//根据传入的value不同而返回不同的值，如果传入的是对象的话则会返回一个状态为成功的promise对象promise.resolve(value)//根据传入的value不同而返回不同的值，如果传入的是对象的话则会返回一个状态为失败的promise对象promise.reject(value)Promise.prototype.then()Promise.prototype.catch()Promise.race()Promise.all()Promise 解决的痛点是什么？回调地狱，代码难以维护，常常第一个的函数的输出是第二个函数的输入这种现象promise可以支持多个并发的请求，获取并发请求中的数据promise可以解决可读性的问题，异步的嵌套带来的可读性的问题promise可以解决信任问题Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。setTimeout、事件监听、回调函数、Generator函数、async/awaitPromise 如何使用？创造一个Promise实例Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数可用Promise的try和catch方法预防异常12345678910111213let p = new Promise((resolve,reject) =&gt; &#123; //做异步操作 setTimeout(() =&gt;&#123; console.log(' 执行完成 '); resolve(' 成功 '); &#125;,2000);&#125;);Promise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：resolve：异步操作执行成功后的回调函数reject：异步操作执行失败后的回调函数Promise 常用的方法有哪些？它们的作用是什么？Promise.resolve(value)类方法，该方法返回一个以value值解析后的Promise对象如果这个值是个thenable（即带有then方法），返回Promise 在事件循环中的执行过程是怎样的？promise是事件循环中的微任务（micotask），在每次事情循环中会先清空了微任务的队列Promise 的业界实现都有哪些？Qbluebird能不能手写一个 Promise 的 polyfill123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112const PENDING = "pending";const RESOLVED = "resolved";const REJECTED = "rejected";function MyPromise(fn)&#123; const that = this; that.state = PENDING; that.value = null; that.resolvedCallbacks = []; that.rejectedCallbacks = []; function resolve(value)&#123; //判断传入的值是否为Promise类型 if( value instanceof MyPromise)&#123; return value.then(resolve,reject) &#125; //为了保证函数的执行顺序，需要将两个函数体代码使用setTimeout包裹起来 setTimeout(()=&gt;&#123; //只有等待状态才可以改变状态 if(that.state == PENDING)&#123; //将当前状态更改为对应状态，并且将传入的值赋值给value that.state = RESOLVED; that.value = value; //遍历回调函数组并执行 that.resolvedCallbacks.map(cb =&gt; cb(that.value)); &#125; &#125;,0) &#125; function reject(value)&#123; setTimeout(()=&gt;&#123; if(that.state == PENDING)&#123; that.state == REJECTED; that.value == value; that.rejectedCallbacks.map( cb =&gt; cb(that.value)); &#125; &#125;) &#125; try&#123; fn(resolve,reject) &#125;catch(e)&#123; reject(e) &#125;&#125;MyPromise.prototype.then = function(onFulfilled,onRejected)&#123; const that = this; //判断两个参数是否为函数类型，这两个参数是可选参数 //当参数不是函数类型时，需要创建一个函数赋值给对应的参数，同时也实现了透传 onFulfilled = typeof onFulfilled === 'function' ? onFulfilled:v =&gt; v; onRejected = typeof onRejected === 'function' ? onRejected:r =&gt; &#123;throw r&#125;; if(that.state === PENDING)&#123; //返回了一个新的Promise对象，并在Promise中传入一个函数 //规范规定，执行onFulfilled 或者 onRejected 函数会返回一个x，并且执行Promise解决过程，这是为了不同的Promise都可以兼容使用，比如JQuery的 Promise 能兼容 ES6 的Promise return(promise2 = new MyPromise((resolve,reject)=&gt;&#123; that.rejectedCallbacks.push(()=&gt;&#123; try&#123; const x = onFulfilled(that.value) resolutionProcedure(promise2,x,resolve,reject) &#125;catch(r)&#123; reject(r) &#125; &#125;); that.rejectedCallbacks.push(()=&gt;&#123; try &#123; const x = onRejected(that.value) resolutionProcedure(promise2, x, resolve, reject) &#125; catch (r) &#123; reject(r) &#125; &#125;); &#125;)) &#125; if(that.state === RESOLVED)&#123; return (promise2 = new MyPromise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; try &#123; const x = onFulfilled(that.value) resolutionProcedure(promise2, x, resolve, reject) &#125; catch (reason) &#123; reject(r) &#125; &#125;) &#125;)) &#125; if(that.state === REJECTED)&#123; return (promise2 = new MyPromise((resolve, reject)=&gt;&#123; try &#123; const x = onRejected(that.value); resolutionProcedure(promise2, x, resolve, reject) &#125;catch(r)&#123; reject(r) &#125; &#125;)) &#125; function resolutionProcedure(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; return reject(new TypeError('Error')) &#125; if (x instanceof MyPromise) &#123; x.then(function(value) &#123; resolutionProcedure(promise2, value, resolve, reject) &#125;, reject) &#125; &#125; &#125; // 创建一个实例 new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1) &#125;, 0) &#125;).then(value =&gt; &#123; console.log(value) &#125;)axios什么是axiosaxios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端执行GET请求123456789101112131415161718192021// 向具有指定ID的用户发出请求axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); // 也可以通过 params 对象传递参数axios.get('/user', &#123;params: &#123; ID: 12345&#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;);执行POST请求12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone'&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;);执行多个并发请求123456789101112function getUserAccount() &#123;return axios.get('/user/12345');&#125; function getUserPermissions() &#123;return axios.get('/user/12345/permissions');&#125; axios.all([getUserAccount(), getUserPermissions()]).then(axios.spread(function (acct, perms) &#123;//两个请求现已完成&#125;));axios API可以通过相关配置传递给axios来进行请求axios(config)123456789// 发送一个 POST 请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone'&#125;&#125;);axios(url[,config])12// 发送一个 GET 请求 (GET请求是默认请求模式)axios('/user/12345');请求方法别名为了方便起见,已经为所有支持的请求方法提供了别名axios.request (config)axios.get（url [，config]）axios.delete（url [，config]）axios.head（url [，config]）axios.post（url [，data [，config]]）axios.put（url [，data [，config]]）axios.patch（url [，data [，config]]）注意:当使用别名方法时,不需要在config中指定url,method和data属性并发帮助函数处理并发请求axios.all（iterable）axios.spread（callback）创建实例使用自定义配置创建axios的新实例axios.create（[config]）12345var instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;);实例方法axios＃request（config）axios＃get（url [，config]）axios＃delete（url [，config]）axios＃head（url [，config]）axios＃post（url [，data [，config]]）axios＃put（url [，data [，config]]）axios＃patch（url [，data [，config]]）请求拦截TIPSErrorReferenceError(引用错误)：代表当一个不存在变量被引用时发生的错误，在作用域中找不到TypeError(类型错误)：在作用域中找到了但是做了它不可能做的事情]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端知识点]]></title>
    <url>%2F2019%2F09%2F28%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1、CSS禁用鼠标点击12345.disabled &#123; pointer-events: none; cursor: default; opacity: 0.6;&#125;2、get/post的理解和他们之间的区别http超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。HTTP的工作方式是客户机与服务器之间的请求-应答协议。web浏览器可能是客户端也可能作为服务器端。HTTP方法：HEAD：与GET相同，但只返回HTTP报头，不返回文档主体PUT：上传指定的URI表示DELETE：删除指定的资源OPTIONS：返回服务器的支持的HTTP方法CONNECT：把请求连接转换到透明的TCP/IP通道POST：向指定的资源提交要被处理的数据1234// 查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2GET：从指定的资源请求数据https://juejin.im/post/5d8989296fb9a06b1f147070?utm_source=gold_browser_extension]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端面试题]]></title>
    <url>%2F2019%2F09%2F28%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前端综合http从输入地址开始到浏览器渲染做了什么？浏览器进行地址解析浏览器得到url地址后开始解析，获取该地址的端口号、域名、协议、路径等信息有些信息不是必须的，浏览器会默认补齐将解析的域名进行dns解析将第一步的解析信息转换成对应的IP地址，这就是DNS解析，分为以下步骤首先查看浏览器中是否有对应的DNS缓存，如果有则直接使用如果没有查看操作系统DNS是否有对应的值（ｈｏｓｔ文件）如果还是没有则向本地DNS服务商发送查询请求如果仍然没有则直接Root Server域名服务器请求解析通过IP地址寻找服务器地址获取到IP地址后寻找IP地址对应的服务器与服务器进行三次握手建立连接浏览器请求报文到达服务器之后，服务器接口会对请求报文进行处理，执行接口对应的代码，处理完成响应客户端。由于ｈｔｔｐ是无状态的，正常情况下，客户端收到响应后就会直接断开连接，然后一次HTTP事务就完成了。但是ｈｔｔｐ １.０有一个ｋｅｅｐ－ａｌｉｖｅ的请求字段，可以在一定时间内不断开（有时时间甚至很长）。HTTP １.１直接就默认开启了ｋｅｅｐ－ａｌｉｖｅ选项。这导致了一个严重的后果是服务器已经处理完请求，但是客户端不会主动断开连接，这就导致服务器资源一直被占用。这时服务器就不得不自己主动断开连接，而主动断开连接，而主动断开连接的一方会出现TIME_WAIT,占用连接池，这就是产生SYN Flood攻击的原因浏览器发送数据，等待服务器的响应服务器响应并返回数据浏览器接受到数据浏览器开始渲染页面JavascriptJavaScript基本数据类型有哪些NumberBooleanStringNullUnderfinedSymbol＝＝与＝＝＝的区别＝＝会自动转换数据类型再进行比较＝＝＝不会转换数据类型，数据类型不一致时直接false，一致再比较事件委托代理在构建应用程序时，有时需要将事件绑定到页面上的按钮、文本或图像，以便在用户与元素交互时执行某些操作。如果我们以一个简单的代办事项列表为例，面试官可能会告诉你，当用户点击列表中的一个列表项时执行某些操作。他们希望你用JavaScript实现这个功能，假设设有如下HTML代码：123456&lt;ul id="todo-app"&gt; &lt;li class="item"&gt;Walk the dog&lt;/li&gt; &lt;li class="item"&gt;Pay bills&lt;/li&gt; &lt;li class="item"&gt;Make dinner&lt;/li&gt; &lt;li class="item"&gt;Code for one hour&lt;/li&gt;&lt;/ul&gt;ＮｏｄｅＪＳnodejs导出导入原理？]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE 2.x]]></title>
    <url>%2F2019%2F09%2F22%2Fvue-js%2F</url>
    <content type="text"><![CDATA[API全局配置Vue.config 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列属性：silent类型：boolean默认值：false用法：1Vue.config.silent = true取消 Vue 所有的日志与警告。optionMergeStrategies类型：{ [key: string]: Function }默认值：{}用法：123456789Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) &#123; return child + 1&#125;const Profile = Vue.extend(&#123; _my_option: 1&#125;)// Profile.options._my_option = 2自定义合并策略的选项。合并策略选项分别接收在父实例和子实例上定义的该选项的值作为第一个和第二个参数，Vue 实例上下文被作为第三个参数传入。参考 自定义选项的混入策略devtools类型：boolean默认值：true (生产版为 false)用法：12// 务必在加载 Vue 之后，立即同步设置以下内容Vue.config.devtools = true配置是否允许 vue-devtools 检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。errorHandler类型：Function默认值：undefined用法：12345Vue.config.errorHandler = function (err, vm, info) &#123; // handle error // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 // 只在 2.2.0+ 可用&#125;指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 undefined 时，被捕获的错误会通过 console.error 输出而避免应用崩溃。从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了。从 2.6.0 起，这个钩子也会捕获 v-on DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理。错误追踪服务 Sentry 和 Bugsnag 都通过此选项提供了官方支持。warnHandler2.4.0 新增类型：Function默认值：undefined用法：123Vue.config.warnHandler = function (msg, vm, trace) &#123; // `trace` 是组件的继承关系追踪&#125;为 Vue 的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。ignoredElements类型：Array默认值：[]用法：1234567Vue.config.ignoredElements = [ &apos;my-custom-web-component&apos;, &apos;another-web-component&apos;, // 用一个 `RegExp` 忽略所有“ion-”开头的元素 // 仅在 2.5+ 支持 /^ion-/]须使 Vue 忽略在 Vue 之外的自定义元素 (e.g. 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 Unknown custom element 的警告。keyCodes类型：{ [key: string]: number | Array }默认值：{}用法：123456789Vue.config.keyCodes = &#123; v: 86, f1: 112, // camelCase 不可用 mediaPlayPause: 179, // 取而代之的是 kebab-case 且用双引号括起来 &quot;media-play-pause&quot;: 179, up: [38, 87]&#125;1&lt;input type=&quot;text&quot; @keyup.media-play-pause=&quot;method&quot;&gt;给 v-on 自定义键位别名。performance2.2.0 新增类型：boolean默认值：false (自 2.2.3 起)用法：设置为 true 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 performance.mark API 的浏览器上。productionTip2.2.0 新增类型：boolean默认值：true用法：设置为 false 以阻止 vue 在启动时生成生产提示。全局APIVue.extend( options )参数：{Object} options用法：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数1&lt;div id=&quot;mount-point&quot;&gt;&lt;/div&gt;12345678910111213// 创建构造器var Profile = Vue.extend(&#123; template: &apos;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&apos;, data: function () &#123; return &#123; firstName: &apos;Walter&apos;, lastName: &apos;White&apos;, alias: &apos;Heisenberg&apos; &#125; &#125;&#125;)// 创建 Profile 实例，并挂载到一个元素上。new Profile().$mount(&apos;#mount-point&apos;)结果如下：1&lt;p&gt;Walter White aka Heisenberg&lt;/p&gt;参考：组件Vue.nextTick( [callback, context] )参数：{Function} [callback]{Object} [context]用法：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。123456789101112// 修改数据vm.msg = &apos;Hello&apos;// DOM 还没有更新Vue.nextTick(function () &#123; // DOM 更新了&#125;)// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)Vue.nextTick() .then(function () &#123; // DOM 更新了 &#125;)2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。参考：异步更新队列Vue.set( target, propertyName/index, value )参数：{Object | Array} target{string | number} propertyName/index{any} value返回值：设置的值。用法：向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = &#39;hi&#39;)注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。Vue.delete( target, propertyName/index )参数：{Object | Array} target{string | number} propertyName/index仅在 2.2.0+ 版本中支持 Array + index 用法。用法：删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。在 2.2.0+ 中同样支持在数组上工作。目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。参考：深入响应式原理Vue.directive( id, [definition] )参数：{string} id{Function | Object} [definition]用法：注册或获取全局指令。12345678910111213141516// 注册Vue.directive(&apos;my-directive&apos;, &#123; bind: function () &#123;&#125;, inserted: function () &#123;&#125;, update: function () &#123;&#125;, componentUpdated: function () &#123;&#125;, unbind: function () &#123;&#125;&#125;)// 注册 (指令函数)Vue.directive(&apos;my-directive&apos;, function () &#123; // 这里将会被 `bind` 和 `update` 调用&#125;)// getter，返回已注册的指令var myDirective = Vue.directive(&apos;my-directive&apos;)参考：自定义指令Vue.filter( id, [definition] )参数：{string} id{Function} [definition]用法：注册或获取全局过滤器。1234567// 注册Vue.filter(&apos;my-filter&apos;, function (value) &#123; // 返回处理后的值&#125;)// getter，返回已注册的过滤器var myFilter = Vue.filter(&apos;my-filter&apos;)参考：过滤器Vue.component( id, [definition] )参数：{string} id{Function | Object} [definition]用法：注册或获取全局组件。注册还会自动使用给定的id设置组件的名称12345678// 注册组件，传入一个扩展过的构造器Vue.component(&apos;my-component&apos;, Vue.extend(&#123; /* ... */ &#125;))// 注册组件，传入一个选项对象 (自动调用 Vue.extend)Vue.component(&apos;my-component&apos;, &#123; /* ... */ &#125;)// 获取注册的组件 (始终返回构造器)var MyComponent = Vue.component(&apos;my-component&apos;)参考：组件Vue.use( plugin )参数：{Object | Function} plugin用法：安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。该方法需要在调用 new Vue() 之前被调用。当 install 方法被同一个插件多次调用，插件将只会被安装一次。参考：插件Vue.mixin( mixin )参数：{Object} mixin用法：全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。不推荐在应用代码中使用。参考：全局混入Vue.compile( template )参数：{string} template用法：在 render 函数中编译模板字符串。只在独立构建时有效123456789var res = Vue.compile(&apos;&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;&apos;)new Vue(&#123; data: &#123; msg: &apos;hello&apos; &#125;, render: res.render, staticRenderFns: res.staticRenderFns&#125;)参考：渲染函数Vue.observable( object )2.6.0 新增参数：{Object} object用法：让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。返回的对象可以直接用于渲染函数和计算属性内，并且会在发生改变时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：123456789const state = Vue.observable(&#123; count: 0 &#125;)const Demo = &#123; render(h) &#123; return h(&apos;button&apos;, &#123; on: &#123; click: () =&gt; &#123; state.count++ &#125;&#125; &#125;, `count is: $&#123;state.count&#125;`) &#125;&#125;在 Vue 2.x 中，被传入的对象会直接被 Vue.observable 改变，所以如这里展示的，它和被返回的对象是同一个对象。在 Vue 3.x 中，则会返回一个可响应的代理，而对源对象直接进行修改仍然是不可响应的。因此，为了向前兼容，我们推荐始终操作使用 Vue.observable 返回的对象，而不是传入源对象。参考：深入响应式原理Vue.version细节：提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。用法：123456789var version = Number(Vue.version.split(&apos;.&apos;)[0])if (version === 2) &#123; // Vue v2.x.x&#125; else if (version === 1) &#123; // Vue v1.x.x&#125; else &#123; // Unsupported versions of Vue&#125;选项/数据data类型：Object | Function限制：组件的定义只接受 function。详细：Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。实例创建之后，可以通过 vm.$data 访问原始数据对象。Vue 实例也代理了 data 对象上所有的属性，因此访问 vm.a 等价于访问 vm.$data.a。以 _ 或 $ 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。你可以使用例如 vm.$data._property 的方式访问这些属性。当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。如果需要，可以通过将 vm.$data 传入 JSON.parse(JSON.stringify(...)) 得到深拷贝的原始数据对象。示例：123456789101112131415var data = &#123; a: 1 &#125;// 直接创建一个实例var vm = new Vue(&#123; data: data&#125;)vm.a // =&gt; 1vm.$data === data // =&gt; true// Vue.extend() 中 data 必须是函数var Component = Vue.extend(&#123; data: function () &#123; return &#123; a: 1 &#125; &#125;&#125;)注意，如果你为 data 属性使用了箭头函数，则 this 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。1data: vm =&gt; (&#123; a: vm.myProp &#125;)参考：深入响应式原理props类型：Array | Object详细：props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。你可以基于对象的语法使用以下选项：type: 可以是下列原生构造函数中的一种：String、Number、Boolean、Array、Object、Date、Function、Symbol、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。Prop 类型的更多信息在此。default: any为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。required: Boolean定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。validator: Function自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在这里查阅更多 prop 验证的相关信息。示例：123456789101112131415161718192021// 简单语法Vue.component(&apos;props-demo-simple&apos;, &#123; props: [&apos;size&apos;, &apos;myMessage&apos;]&#125;)// 对象语法，提供验证Vue.component(&apos;props-demo-advanced&apos;, &#123; props: &#123; // 检测类型 height: Number, // 检测类型 + 其他验证 age: &#123; type: Number, default: 0, required: true, validator: function (value) &#123; return value &gt;= 0 &#125; &#125; &#125;&#125;)参考：PropspropsData类型：{ [key: string]: any }限制：只用于 new 创建的实例中。详细：创建实例时传递 props。主要作用是方便测试。示例：12345678910var Comp = Vue.extend(&#123; props: [&apos;msg&apos;], template: &apos;&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;&apos;&#125;)var vm = new Comp(&#123; propsData: &#123; msg: &apos;hello&apos; &#125;&#125;)computed类型：{ [key: string]: Function | { get: Function, set: Function } }详细：计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。注意如果你为一个计算属性使用了箭头函数，则 this 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。123computed: &#123; aDouble: vm =&gt; vm.a * 2&#125;计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖 (比如非响应式属性) 在该实例范畴之外，则计算属性是不会被更新的。示例：12345678910111213141516171819202122var vm = new Vue(&#123; data: &#123; a: 1 &#125;, computed: &#123; // 仅读取 aDouble: function () &#123; return this.a * 2 &#125;, // 读取和设置 aPlus: &#123; get: function () &#123; return this.a + 1 &#125;, set: function (v) &#123; this.a = v - 1 &#125; &#125; &#125;&#125;)vm.aPlus // =&gt; 2vm.aPlus = 3vm.a // =&gt; 2vm.aDouble // =&gt; 4参考：计算属性methods类型：{ [key: string]: Function }详细：methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () =&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。示例：12345678910var vm = new Vue(&#123; data: &#123; a: 1 &#125;, methods: &#123; plus: function () &#123; this.a++ &#125; &#125;&#125;)vm.plus()vm.a // 2参考：事件处理器watch类型：{ [key: string]: string | Function | Object | Array }详细：一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。示例：1234567891011121314151617181920212223242526272829303132333435363738394041var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3, d: 4, e: &#123; f: &#123; g: 5 &#125; &#125; &#125;, watch: &#123; a: function (val, oldVal) &#123; console.log(&apos;new: %s, old: %s&apos;, val, oldVal) &#125;, // 方法名 b: &apos;someMethod&apos;, // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深 c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125;, // 该回调将会在侦听开始之后被立即调用 d: &#123; handler: &apos;someMethod&apos;, immediate: true &#125;, e: [ &apos;handle1&apos;, function handle2 (val, oldVal) &#123; /* ... */ &#125;, &#123; handler: function handle3 (val, oldVal) &#123; /* ... */ &#125;, /* ... */ &#125; ], // watch vm.e.f&apos;s value: &#123;g: 5&#125; &apos;e.f&apos;: function (val, oldVal) &#123; /* ... */ &#125; &#125;&#125;)vm.a = 2 // =&gt; new: 2, old: 1注意，不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。参考：实例方法 / 数据 - vm.$watch选项/DOMel类型：string | Element限制：只在由 new 创建的实例中遵守。详细：提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。在实例挂载之后，元素可以用 vm.$el 访问。如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译。提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载 root 实例到 或者 上。如果 render 函数和 template 属性都不存在，挂载 DOM 元素的 HTML 会被提取出来用作模板，此时，必须使用 Runtime + Compiler 构建的 Vue 库。参考：生命周期图示运行时 + 编译器 vs. 只包含运行时template类型：string详细：一个字符串模板作为 Vue 实例的标识使用。模板将会 替换 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。如果值以 # 开始，则它将被用作选择符，并使用匹配元素的 innerHTML 作为模板。常用的技巧是用 包含模板。出于安全考虑，你应该只使用你信任的 Vue 模板。避免使用其他人生成的内容作为你的模板。如果 Vue 选项中包含渲染函数，该模板将被忽略。参考：生命周期图示通过插槽分发内容render类型：(createElement: () =&gt; VNode) =&gt; VNode详细：字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 createElement 方法作为第一个参数用来创建 VNode。如果组件是一个函数组件，渲染函数还会接收一个额外的 context 参数，为没有实例的函数组件提供上下文信息。Vue 选项中的 render 函数若存在，则 Vue 构造函数不会从 template 选项或通过 el 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。参考：渲染函数renderError2.2.0 新增类型：(createElement: () =&gt; VNode, error: Error) =&gt; VNode详细：只在开发者环境下工作。当 render 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 renderError。这个功能配合 hot-reload 非常实用。示例：12345678new Vue(&#123; render (h) &#123; throw new Error(&apos;oops&apos;) &#125;, renderError (h, err) &#123; return h(&apos;pre&apos;, &#123; style: &#123; color: &apos;red&apos; &#125;&#125;, err.stack) &#125;&#125;).$mount(&apos;#app&apos;)参考：渲染函数选项/生命钩子所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。beforeCreate类型：Function详细：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。参考：生命周期图示created类型：Function详细：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。参考：生命周期图示beforeMount类型：Function详细：在挂载开始之前被调用：相关的 render 函数首次被调用。该钩子在服务器端渲染期间不被调用。参考：生命周期图示mounted类型：Function详细：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted：123456mounted: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been rendered &#125;)&#125;该钩子在服务器端渲染期间不被调用。参考：生命周期图示beforeUpdate类型：Function详细：数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。参考：生命周期图示updated类型：Function详细：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。注意 updated 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 updated：123456updated: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been re-rendered &#125;)&#125;该钩子在服务器端渲染期间不被调用。参考：生命周期图示activated类型：Function详细：keep-alive 组件激活时调用。该钩子在服务器端渲染期间不被调用。参考：构建组件 - keep-alive动态组件 - keep-alivedeactivated类型：Function详细：keep-alive 组件停用时调用。该钩子在服务器端渲染期间不被调用。参考：构建组件 - keep-alive动态组件 - keep-alivebeforeDestroy类型：Function详细：实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。参考：生命周期图示destroyed类型：Function详细：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。参考：生命周期图示errorCaptured2.5.0+ 新增类型：(err: Error, vm: Component, info: string) =&gt; ?boolean详细：当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。你可以在此钩子中修改组件的状态。因此在模板或渲染函数中设置其它内容的短路条件非常重要，它可以防止当一个错误被捕获时该组件进入一个无限的渲染循环。错误传播规则默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler。一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler。选项/资源directives类型：Object详细：包含 Vue 实例可用指令的哈希表。参考：自定义指令filters类型：Object详细：包含 Vue 实例可用过滤器的哈希表。参考：Vue.filtercomponents类型：Object详细：包含 Vue 实例可用组件的哈希表。参考：组件选项/组合parent类型：Vue instance详细：指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 this.$parent 访问父实例，子实例被推入父实例的 $children 数组中。节制地使用 $parent 和 $children - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信mixins类型：Array详细：mixins 选项接受一个混入对象的数组。这些混入实例对象可以像正常的实例对象一样包含选项，他们将在 Vue.extend() 里最终选择使用相同的选项合并逻辑合并。举例：如果你的混入包含一个钩子而创建组件本身也有一个，两个函数将被调用。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。示例：123456789var mixin = &#123; created: function () &#123; console.log(1) &#125;&#125;var vm = new Vue(&#123; created: function () &#123; console.log(2) &#125;, mixins: [mixin]&#125;)// =&gt; 1// =&gt; 2参考：混入extends类型：Object | Function详细：允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数)，而无需使用 Vue.extend。这主要是为了便于扩展单文件组件。这和 mixins 类似。示例：1234567var CompA = &#123; ... &#125;// 在没有调用 `Vue.extend` 时候继承 CompAvar CompB = &#123; extends: CompA, ...&#125;provide / inject2.2.0 新增类型：provide：Object | () =&gt; Objectinject：Array | { [key: string]: string | Symbol | Object }详细：provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。inject 选项应该是：一个字符串数组，或一个对象，对象的 key 是本地的绑定名，value 是：在可用的注入内容中搜索用的 key (字符串或 Symbol)，或一个对象，该对象的：from 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol)default 属性是降级情况下使用的 value提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。示例：12345678910111213141516// 父级组件提供 &apos;foo&apos;var Provider = &#123; provide: &#123; foo: &apos;bar&apos; &#125;, // ...&#125;// 子组件注入 &apos;foo&apos;var Child = &#123; inject: [&apos;foo&apos;], created () &#123; console.log(this.foo) // =&gt; &quot;bar&quot; &#125; // ...&#125;利用 ES2015 Symbols、函数 provide 和对象 inject：1234567891011121314const s = Symbol()const Provider = &#123; provide () &#123; return &#123; [s]: &apos;foo&apos; &#125; &#125;&#125;const Child = &#123; inject: &#123; s &#125;, // ...&#125;接下来 2 个例子只工作在 Vue 2.2.1 或更高版本。低于这个版本时，注入的值会在 props 和 data 初始化之后得到。使用一个注入的值作为一个属性的默认值：12345678910const Child = &#123; inject: [&apos;foo&apos;], props: &#123; bar: &#123; default () &#123; return this.foo &#125; &#125; &#125;&#125;使用一个注入的值作为数据入口：12345678const Child = &#123; inject: [&apos;foo&apos;], data () &#123; return &#123; bar: this.foo &#125; &#125;&#125;在 2.5.0+ 的注入可以通过设置默认值使其变成可选项：12345const Child = &#123; inject: &#123; foo: &#123; default: &apos;foo&apos; &#125; &#125;&#125;如果它需要从一个不同名字的属性注入，则使用 from 来表示其源属性：12345678const Child = &#123; inject: &#123; foo: &#123; from: &apos;bar&apos;, default: &apos;foo&apos; &#125; &#125;&#125;与 prop 的默认值类似，你需要对非原始值使用一个工厂方法：12345678const Child = &#123; inject: &#123; foo: &#123; from: &apos;bar&apos;, default: () =&gt; [1, 2, 3] &#125; &#125;&#125;选项/其他name类型：string限制：只有作为组件选项时起作用。详细：允许组件模板递归地调用自身。注意，组件在全局用 Vue.component() 注册时，全局 ID 自动作为组件的 name。指定 name 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 vue-devtools，未命名组件将显示成 ，这很没有语义。通过提供 name 选项，可以获得更有语义信息的组件树。delimiters类型：Array默认值：[&quot;, &quot;]限制：这个选项只在完整构建版本中的浏览器内编译时可用。详细：改变纯文本插入分隔符。示例：12345new Vue(&#123; delimiters: [&apos;$&#123;&apos;, &apos;&#125;&apos;]&#125;)// 分隔符变成了 ES6 模板字符串的风格functional类型：boolean详细：使组件无状态 (没有 data ) 和无实例 (没有 this 上下文)。他们用一个简单的 render 函数返回虚拟节点使他们更容易渲染。参考：函数式组件model2.2.0 新增类型：{ prop?: string, event?: string }详细：允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。Example：12345678910111213141516Vue.component(&apos;my-checkbox&apos;, &#123; model: &#123; prop: &apos;checked&apos;, event: &apos;change&apos; &#125;, props: &#123; // this allows using the `value` prop for a different purpose value: String, // use `checked` as the prop which take the place of `value` checked: &#123; type: Number, default: 0 &#125; &#125;, // ...&#125;)1&lt;my-checkbox v-model=&quot;foo&quot; value=&quot;some value&quot;&gt;&lt;/my-checkbox&gt;上述代码相当于：12345&lt;my-checkbox :checked=&quot;foo&quot; @change=&quot;val =&gt; &#123; foo = val &#125;&quot; value=&quot;some value&quot;&gt;&lt;/my-checkbox&gt;inheritAttrs2.4.0 新增类型：boolean默认值：true详细：默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。注意：这个选项不影响 class 和 style 绑定。comments2.4.0 新增类型：boolean默认值：false限制：这个选项只在完整构建版本中的浏览器内编译时可用。详细：当设为 true 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。实例属性vm.$data类型：Object详细：Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象属性的访问。参考：选项 / 数据 - datavm.$props2.2.0 新增类型：Object详细：当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象属性的访问。vm.$el类型：Element只读详细：Vue 实例使用的根 DOM 元素。vm.$options类型：Object只读详细：用于当前 Vue 实例的初始化选项。需要在选项中包含自定义属性时会有用处：123456new Vue(&#123; customOption: &apos;foo&apos;, created: function () &#123; console.log(this.$options.customOption) // =&gt; &apos;foo&apos; &#125;&#125;)vm.$parent类型：Vue instance只读详细：父实例，如果当前实例有的话。vm.$root类型：Vue instance只读详细：当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。vm.$children类型：Array只读详细：当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的。如果你发现自己正在尝试使用 $children 来进行数据绑定，考虑使用一个数组配合 v-for 来生成子组件，并且使用 Array 作为真正的来源。vm.$slots类型：{ [name: string]: ?Array }只读详细：用来访问被插槽分发的内容。每个具名插槽 有其相应的属性 (例如：v-slot:foo 中的内容将会在 vm.$slots.foo 中被找到)。default 属性包括了所有没有被包含在具名插槽中的节点，或 v-slot:default 的内容。注意: v-slot:foo 在 2.6 以上的版本才支持。对于之前的版本，你可以使用废弃了的语法.在使用渲染函数书写一个组件时，访问 vm.$slots 最有帮助。示例：12345678910111213&lt;blog-post&gt; &lt;template v-slot:header&gt; &lt;h1&gt;About Me&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;Here&apos;s some page content, which will be included in vm.$slots.default, because it&apos;s not inside a named slot.&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Copyright 2016 Evan You&lt;/p&gt; &lt;/template&gt; &lt;p&gt;If I have some content down here, it will also be included in vm.$slots.default.&lt;/p&gt;.&lt;/blog-post&gt;123456789101112Vue.component(&apos;blog-post&apos;, &#123; render: function (createElement) &#123; var header = this.$slots.header var body = this.$slots.default var footer = this.$slots.footer return createElement(&apos;div&apos;, [ createElement(&apos;header&apos;, header), createElement(&apos;main&apos;, body), createElement(&apos;footer&apos;, footer) ]) &#125;&#125;)参考： 组件通过插槽分发内容渲染函数 - 插槽vm.$scopedSlots2.1.0 新增类型：{ [name: string]: props =&gt; Array | undefined }只读详细：用来访问作用域插槽。对于包括 默认 slot 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。vm.$scopedSlots 在使用渲染函数开发一个组件时特别有用。注意：从 2.6.0 开始，这个属性有两个变化：作用域插槽函数现在保证返回一个 VNode 数组，除非在返回值无效的情况下返回 undefined。所有的 $slots 现在都会作为函数暴露在 $scopedSlots 中。如果你在使用渲染函数，不论当前插槽是否带有作用域，我们都推荐始终通过 $scopedSlots 访问它们。这不仅仅使得在未来添加作用域变得简单，也可以让你最终轻松迁移到所有插槽都是函数的 Vue 3。参考： 组件作用域插槽渲染函数 - 插槽vm.$refs类型：Object只读详细：一个对象，持有注册过 ref 特性 的所有 DOM 元素和组件实例。参考：子组件引用特殊特性 - refvm.$isServer类型：boolean只读详细：当前 Vue 实例是否运行于服务器。参考：服务端渲染vm.$attrs2.4.0 新增类型：{ [key: string]: string }只读详细：包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用。vm.$listeners2.4.0 新增类型：{ [key: string]: Function | Array }只读详细：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。实例方法/数据vm.$watch( expOrFn, callback, [options] )参数：{string | Function} expOrFn{Function | Object} callback1&#123;Object&#125; [options]{boolean} deep{boolean} immediate返回值：{Function} unwatch用法：观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。注意：在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。示例：1234567891011121314151617// 键路径vm.$watch(&apos;a.b.c&apos;, function (newVal, oldVal) &#123; // 做点什么&#125;)// 函数vm.$watch( function () &#123; // 表达式 `this.a + this.b` 每次得出一个不同的结果时 // 处理函数都会被调用。 // 这就像监听一个未被定义的计算属性 return this.a + this.b &#125;, function (newVal, oldVal) &#123; // 做点什么 &#125;)vm.$watch 返回一个取消观察函数，用来停止触发回调：123var unwatch = vm.$watch(&apos;a&apos;, cb)// 之后取消观察unwatch()选项：deep为了发现对象内部值的变化，可以在选项参数中指定 deep: true 。注意监听数组的变动不需要这么做。12345vm.$watch(&apos;someObject&apos;, callback, &#123; deep: true&#125;)vm.someObject.nestedValue = 123// callback is fired选项：immediate在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调：1234vm.$watch(&apos;a&apos;, callback, &#123; immediate: true&#125;)// 立即以 `a` 的当前值触发回调注意在带有 immediate 选项时，你不能在第一次回调时取消侦听给定的 property。123456789// 这会导致报错var unwatch = vm.$watch( &apos;value&apos;, function () &#123; doSomething() unwatch() &#125;, &#123; immediate: true &#125;)如果你仍然希望在回调内部调用一个取消侦听的函数，你应该先检查其函数的可用性：12345678910var unwatch = vm.$watch( &apos;value&apos;, function () &#123; doSomething() if (unwatch) &#123; unwatch() &#125; &#125;, &#123; immediate: true &#125;)vm.$set( target, propertyName/index, value )参数：{Object | Array} target{string | number} propertyName/index{any} value返回值：设置的值。用法：这是全局 Vue.set 的别名。参考：Vue.setvm.$delete( target, propertyName/index )参数：{Object | Array} target{string | number} propertyName/index用法：这是全局 Vue.delete 的别名。参考：Vue.delete实例方法 / 事件vm.$on( event, callback )参数：{string | Array} event (数组只在 2.2.0+ 中支持){Function} callback用法：监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。示例：12345vm.$on(&apos;test&apos;, function (msg) &#123; console.log(msg)&#125;)vm.$emit(&apos;test&apos;, &apos;hi&apos;)// =&gt; &quot;hi&quot;vm.$once( event, callback )参数：{string} event{Function} callback用法：监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。vm.$off( [event, callback] )参数：{string | Array} event (只在 2.2.2+ 支持数组){Function} [callback]用法：移除自定义事件监听器。如果没有提供参数，则移除所有的事件监听器；如果只提供了事件，则移除该事件所有的监听器；如果同时提供了事件与回调，则只移除这个回调的监听器。vm.$emit( eventName, […args] )参数：{string} eventName[...args]触发当前实例上的事件。附加参数都会传给监听器回调。示例：只配合一个事件名使用 $emit：1234567Vue.component(&apos;welcome-button&apos;, &#123; template: ` &lt;button v-on:click=&quot;$emit(&apos;welcome&apos;)&quot;&gt; Click me to be welcomed &lt;/button&gt; `&#125;)123&lt;div id=&quot;emit-example-simple&quot;&gt; &lt;welcome-button v-on:welcome=&quot;sayHi&quot;&gt;&lt;/welcome-button&gt;&lt;/div&gt;12345678new Vue(&#123; el: &apos;#emit-example-simple&apos;, methods: &#123; sayHi: function () &#123; alert(&apos;Hi!&apos;) &#125; &#125;&#125;)Click me to be welcomed配合额外的参数使用 $emit：123456789101112131415161718Vue.component(&apos;magic-eight-ball&apos;, &#123; data: function () &#123; return &#123; possibleAdvice: [&apos;Yes&apos;, &apos;No&apos;, &apos;Maybe&apos;] &#125; &#125;, methods: &#123; giveAdvice: function () &#123; var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length) this.$emit(&apos;give-advice&apos;, this.possibleAdvice[randomAdviceIndex]) &#125; &#125;, template: ` &lt;button v-on:click=&quot;giveAdvice&quot;&gt; Click me for advice &lt;/button&gt; `&#125;)123&lt;div id=&quot;emit-example-argument&quot;&gt; &lt;magic-eight-ball v-on:give-advice=&quot;showAdvice&quot;&gt;&lt;/magic-eight-ball&gt;&lt;/div&gt;12345678new Vue(&#123; el: &apos;#emit-example-argument&apos;, methods: &#123; showAdvice: function (advice) &#123; alert(advice) &#125; &#125;&#125;)Click me for advice实例方法 / 生命周期vm.$mount( [elementOrSelector] )参数：{Element | string} [elementOrSelector]{boolean} [hydrating]返回值：vm - 实例自身用法：如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 vm.$mount() 手动地挂载一个未挂载的实例。如果没有提供 elementOrSelector 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。这个方法返回实例自身，因而可以链式调用其它实例方法。示例：12345678910111213var MyComponent = Vue.extend(&#123; template: &apos;&lt;div&gt;Hello!&lt;/div&gt;&apos;&#125;)// 创建并挂载到 #app (会替换 #app)new MyComponent().$mount(&apos;#app&apos;)// 同上new MyComponent(&#123; el: &apos;#app&apos; &#125;)// 或者，在文档之外渲染并且随后挂载var component = new MyComponent().$mount()document.getElementById(&apos;app&apos;).appendChild(component.$el)参考：生命周期图示服务端渲染vm.$forceUpdate()示例：迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。vm.$nextTick( [callback] )参数：{Function} [callback]用法：将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不是原生支持 Promise (IE：你们都看我干嘛)，你得自行 polyfill。示例：12345678910111213141516new Vue(&#123; // ... methods: &#123; // ... example: function () &#123; // 修改数据 this.message = &apos;changed&apos; // DOM 还没有更新 this.$nextTick(function () &#123; // DOM 现在更新了 // `this` 绑定到当前实例 this.doSomethingElse() &#125;) &#125; &#125;&#125;)参考Vue.nextTick异步更新队列vm.$destroy()用法：完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。触发 beforeDestroy 和 destroyed 的钩子。在大多数场景中你不应该调用这个方法。最好使用 v-if 和 v-for 指令以数据驱动的方式控制子组件的生命周期。参考：生命周期图示指令v-text预期：string详细：更新元素的 textContent。如果要更新部分的 textContent ，需要使用 插值。示例：123&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;&lt;!-- 和下面的一样 --&gt;&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;参考：数据绑定语法 - 插值v-html预期：string详细：更新元素的 innerHTML 。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译 。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。在单文件组件里，scoped 的样式不会应用在 v-html 内部，因为那部分 HTML 没有被 Vue 的模板编译器处理。如果你希望针对 v-html 的内容设置带作用域的 CSS，你可以替换为 CSS Modules 或用一个额外的全局 元素手动设置类似 BEM 的作用域策略。示例：1&lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt;参考：数据绑定语法 - 插值v-show预期：any用法：根据表达式之真假值，切换元素的 display CSS 属性。当条件变化时该指令触发过渡效果。参考：条件渲染 - v-showv-if预期：any用法：根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 ` ，将提出它的内容作为条件块。当条件变化时该指令触发过渡效果。当和 v-if 一起使用时，v-for 的优先级比 v-if 更高。详见列表渲染教程参考：条件渲染 - v-ifv-else不需要表达式限制：前一兄弟元素必须有 v-if 或 v-else-if。用法：为 v-if 或者 v-else-if 添加“else 块”。123456&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don&apos;t&lt;/div&gt;参考：条件渲染 - v-elsev-else-if2.1.0 新增类型：any限制：前一兄弟元素必须有 v-if 或 v-else-if。用法：表示 v-if 的 “else if 块”。可以链式调用。123456789101112&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt; A&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt; B&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt;参考：条件渲染 - v-else-ifv-for预期：Array | Object | number | string | Iterable (2.6 新增)用法：基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 alias in expression ，为当前遍历的元素提供别名：123&lt;div v-for=&quot;item in items&quot;&gt; &#123;&#123; item.text &#125;&#125;&lt;/div&gt;另外也可以为数组索引指定别名 (或者用于对象的键)：123&lt;div v-for=&quot;(item, index) in items&quot;&gt;&lt;/div&gt;&lt;div v-for=&quot;(val, key) in object&quot;&gt;&lt;/div&gt;&lt;div v-for=&quot;(val, name, index) in object&quot;&gt;&lt;/div&gt;v-for 默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素，你需要提供一个 key 的特殊属性：123&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &#123;&#123; item.text &#125;&#125;&lt;/div&gt;从 2.6 起，v-for 也可以在实现了可迭代协议的值上使用，包括原生的 Map 和 Set。不过应该注意的是 Vue 2.x 目前并不支持可响应的 Map 和 Set 值，所以无法自动探测变更。当和 v-if 一起使用时，v-for 的优先级比 v-if 更高。详见列表渲染教程v-for 的详细用法可以通过以下链接查看教程详细说明。参考：列表渲染keyv-on缩写：@预期：Function | Inline Statement | Object参数：event修饰符：.stop - 调用 event.stopPropagation()。.prevent - 调用 event.preventDefault()。.capture - 添加事件侦听器时使用 capture 模式。.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。.native - 监听组件根元素的原生事件。.once - 只触发一次回调。.left - (2.2.0) 只当点击鼠标左键时触发。.right - (2.2.0) 只当点击鼠标右键时触发。.middle - (2.2.0) 只当点击鼠标中键时触发。.passive - (2.3.0) 以 { passive: true } 模式添加侦听器用法：绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。用在普通元素上时，只能监听原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 $event 属性：v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;。从 2.4.0 开始，v-on 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。示例：1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 方法处理器 --&gt;&lt;button v-on:click=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 动态事件 (2.6.0+) --&gt;&lt;button v-on:[event]=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 内联语句 --&gt;&lt;button v-on:click=&quot;doThat(&apos;hello&apos;, $event)&quot;&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;button @click=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 动态事件缩写 (2.6.0+) --&gt;&lt;button @[event]=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!-- 串联修饰符 --&gt;&lt;button @click.stop.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 键修饰符，键别名 --&gt;&lt;input @keyup.enter=&quot;onEnter&quot;&gt;&lt;!-- 键修饰符，键代码 --&gt;&lt;input @keyup.13=&quot;onEnter&quot;&gt;&lt;!-- 点击回调只会触发一次 --&gt;&lt;button v-on:click.once=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 对象语法 (2.4.0+) --&gt;&lt;button v-on=&quot;&#123; mousedown: doThis, mouseup: doThat &#125;&quot;&gt;&lt;/button&gt;在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)：1234567&lt;my-component @my-event=&quot;handleThis&quot;&gt;&lt;/my-component&gt;&lt;!-- 内联语句 --&gt;&lt;my-component @my-event=&quot;handleThis(123, $event)&quot;&gt;&lt;/my-component&gt;&lt;!-- 组件中的原生事件 --&gt;&lt;my-component @click.native=&quot;onClick&quot;&gt;&lt;/my-component&gt;参考：事件处理器组件 - 自定义事件v-bind缩写：:预期：any (with argument) | Object (without argument)参数：attrOrProp (optional)修饰符：.prop - 被用于绑定 DOM 属性 (property)。(差别在哪里？).camel - (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持).sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。用法：动态地绑定一个或多个特性，或一个组件 prop 到表达式。在绑定 class 或 style 特性时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。没有参数时，可以绑定到一个包含键值对的对象。注意此时 class 和 style 绑定不支持数组和对象。示例：1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 绑定一个属性 --&gt;&lt;img v-bind:src=&quot;imageSrc&quot;&gt;&lt;!-- 动态特性名 (2.6.0+) --&gt;&lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;img :src=&quot;imageSrc&quot;&gt;&lt;!-- 动态特性名缩写 (2.6.0+) --&gt;&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;&lt;!-- 内联字符串拼接 --&gt;&lt;img :src=&quot;&apos;/path/to/images/&apos; + fileName&quot;&gt;&lt;!-- class 绑定 --&gt;&lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;&lt;!-- style 绑定 --&gt;&lt;div :style=&quot;&#123; fontSize: size + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;&lt;!-- 绑定一个有属性的对象 --&gt;&lt;div v-bind=&quot;&#123; id: someProp, &apos;other-attr&apos;: otherProp &#125;&quot;&gt;&lt;/div&gt;&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;&lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;&lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;&lt;!-- XLink --&gt;&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;.camel 修饰符允许在使用 DOM 模板时将 v-bind 属性名称驼峰化，例如 SVG 的 viewBox 属性：1&lt;svg :view-box.camel=&quot;viewBox&quot;&gt;&lt;/svg&gt;在使用字符串模板或通过 vue-loader/vueify 编译时，无需使用 .camel。参考：Class 与 Style 绑定组件 - Props组件 - .sync 修饰符v-model预期：随表单控件类型不同而不同。限制：components修饰符：.lazy - 取代 input 监听 change 事件.number - 输入字符串转为有效的数字.trim - 输入首尾空格过滤用法：在表单控件或者组件上创建双向绑定。细节请看下面的教程链接。参考：表单控件绑定组件 - 在输入组件上使用自定义事件v-slot缩写：#预期：可放置在函数参数位置的 JavaScript 表达式 (在支持的环境下可使用解构)。可选，即只需要在为插槽传入 prop 的时候使用。参数：插槽名 (可选，默认值是 default)限用于`组件 (对于一个单独的带 prop 的默认插槽)用法：提供具名插槽或需要接收 prop 的插槽。示例：1234567891011121314151617181920212223242526&lt;!-- 具名插槽 --&gt;&lt;base-layout&gt; &lt;template v-slot:header&gt; Header content &lt;/template&gt; Default slot content &lt;template v-slot:footer&gt; Footer content &lt;/template&gt;&lt;/base-layout&gt;&lt;!-- 接收 prop 的具名插槽 --&gt;&lt;infinite-scroll&gt; &lt;template v-slot:item=&quot;slotProps&quot;&gt; &lt;div class=&quot;item&quot;&gt; &#123;&#123; slotProps.item.text &#125;&#125; &lt;/div&gt; &lt;/template&gt;&lt;/infinite-scroll&gt;&lt;!-- 接收 prop 的默认插槽，使用了解构 --&gt;&lt;mouse-position v-slot=&quot;&#123; x, y &#125;&quot;&gt; Mouse position: &#123;&#123; x &#125;&#125;, &#123;&#123; y &#125;&#125;&lt;/mouse-position&gt;更多细节请查阅以下链接。参考：组件 - 插槽RFC-0001v-pre不需要表达式用法：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。示例：1&lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;/span&gt;v-cloak不需要表达式用法：这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。示例：123[v-cloak] &#123; display: none;&#125;123&lt;div v-cloak&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;不会显示，直到编译结束。v-once不需要表达式详细：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。12345678910111213&lt;!-- 单个元素 --&gt;&lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;!-- 有子元素 --&gt;&lt;div v-once&gt; &lt;h1&gt;comment&lt;/h1&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;!-- 组件 --&gt;&lt;my-component v-once :comment=&quot;msg&quot;&gt;&lt;/my-component&gt;&lt;!-- `v-for` 指令--&gt;&lt;ul&gt; &lt;li v-for=&quot;i in list&quot; v-once&gt;&#123;&#123;i&#125;&#125;&lt;/li&gt;&lt;/ul&gt;参考：数据绑定语法- 插值组件 - 对低开销的静态组件使用 v-once特殊特性key预期：number | stringkey 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。最常见的用例是结合 v-for：123&lt;ul&gt; &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;...&lt;/li&gt;&lt;/ul&gt;它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：完整地触发组件的生命周期钩子触发过渡例如：123&lt;transition&gt; &lt;span :key=&quot;text&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;&lt;/transition&gt;当 text 发生改变时， 会随时被更新，因此会触发过渡。ref预期：stringref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：12345&lt;!-- `vm.$refs.p` will be the DOM node --&gt;&lt;p ref=&quot;p&quot;&gt;hello&lt;/p&gt;&lt;!-- `vm.$refs.child` will be the child component instance --&gt;&lt;child-component ref=&quot;child&quot;&gt;&lt;/child-component&gt;当 v-for 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。参考：子组件引用is预期：string | Object (组件的选项对象)用于动态组件且基于 DOM 内模板的限制来工作。示例：12345678&lt;!-- 当 `currentView` 改变时，组件也跟着改变 --&gt;&lt;component v-bind:is=&quot;currentView&quot;&gt;&lt;/component&gt;&lt;!-- 这样做是有必要的，因为 `&lt;my-row&gt;` 放在一个 --&gt;&lt;!-- `&lt;table&gt;` 内可能无效且被放置到外面 --&gt;&lt;table&gt; &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;&lt;/table&gt;更多的使用细节，请移步至下面的链接。See also：动态组件DOM 模板解析说明slot 废弃推荐 2.6.0 新增的 v-slot。预期：string用于标记往哪个具名插槽中插入子组件内容。参考：具名插槽slot-scope 废弃推荐 2.6.0 新增的 v-slot。预期：function argument expression用法：用于将元素或组件表示为作用域插槽。特性的值应该是可以出现在函数签名的参数位置的合法的 JavaScript 表达式。这意味着在支持的环境中，你还可以在表达式中使用 ES2015 解构。它在 2.5.0+ 中替代了 scope。此属性不支持动态绑定。参考：作用域插槽scope 移除被 2.5.0 新增的 slot-scope 取代。推荐 2.6.0 新增的 v-slot。用于表示一个作为带作用域的插槽的 元素，它在 2.5.0+ 中被 [slot-scope`](https://cn.vuejs.org/v2/api/#slot-scope) 替代。用法：除了 scope 只可以用于 元素，其它和 [slot-scope`](https://cn.vuejs.org/v2/api/#slot-scope) 都相同。内置的组件componentProps：is - string | ComponentDefinition | ComponentConstructorinline-template - boolean用法：渲染一个“元组件”为动态组件。依 is 的值，来决定哪个组件被渲染。12345&lt;!-- 动态组件由 vm 实例的属性值 `componentId` 控制 --&gt;&lt;component :is=&quot;componentId&quot;&gt;&lt;/component&gt;&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;&lt;component :is=&quot;$options.components.child&quot;&gt;&lt;/component&gt;参考：动态组件transitionProps：name - string，用于自动生成 CSS 过渡类名。例如：name: &#39;fade&#39; 将自动拓展为.fade-enter，.fade-enter-active等。默认类名为 &quot;v&quot;appear - boolean，是否在初始渲染时使用过渡。默认为 false。css - boolean，是否使用 CSS 过渡类。默认为 true。如果设置为 false，将只通过组件事件触发注册的 JavaScript 钩子。type - string，指定过渡事件类型，侦听过渡何时结束。有效值为 &quot;transition&quot; 和 &quot;animation&quot;。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。mode - string，控制离开/进入的过渡时间序列。有效的模式有 &quot;out-in&quot; 和 &quot;in-out&quot;；默认同时生效。duration - number | { enter: number, leave: number } 指定过渡的持续时间。默认情况下，Vue 会等待过渡所在根元素的第一个 transitionend 或 animationend 事件。enter-class - stringleave-class - stringappear-class - stringenter-to-class - stringleave-to-class - stringappear-to-class - stringenter-active-class - stringleave-active-class - stringappear-active-class - string事件：before-enterbefore-leavebefore-appearenterleaveappearafter-enterafter-leaveafter-appearenter-cancelledleave-cancelled (v-show only)appear-cancelled用法：元素作为单个元素/组件的过渡效果。 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在检测过的组件层级中。12345678910111213141516&lt;!-- 简单元素 --&gt;&lt;transition&gt; &lt;div v-if=&quot;ok&quot;&gt;toggled content&lt;/div&gt;&lt;/transition&gt;&lt;!-- 动态组件 --&gt;&lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot; appear&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/transition&gt;&lt;!-- 事件钩子 --&gt;&lt;div id=&quot;transition-demo&quot;&gt; &lt;transition @after-enter=&quot;transitionComplete&quot;&gt; &lt;div v-show=&quot;ok&quot;&gt;toggled content&lt;/div&gt; &lt;/transition&gt;&lt;/div&gt;123456789new Vue(&#123; ... methods: &#123; transitionComplete: function (el) &#123; // 传入 &apos;el&apos; 这个 DOM 元素作为参数。 &#125; &#125; ...&#125;).$mount(&apos;#transition-demo&apos;)参考：过渡：进入，离开和列表transition-groupProps：tag - string，默认为 spanmove-class - 覆盖移动过渡期间应用的 CSS 类。除了 mode，其他特性和 相同。事件：事件和 相同。用法：元素作为多个元素/组件的过渡效果。 渲染一个真实的 DOM 元素。默认渲染 ，可以通过 tag 属性配置哪个元素应该被渲染。注意，每个 的子节点必须有 独立的 key ，动画才能正常工作 支持通过 CSS transform 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它将会获取应用 CSS 移动类 (通过 name 属性或配置 move-class 属性自动生成)。如果 CSS transform 属性是“可过渡”属性，当应用移动类时，将会使用 FLIP 技术 使元素流畅地到达动画终点。12345&lt;transition-group tag=&quot;ul&quot; name=&quot;slide&quot;&gt; &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &#123;&#123; item.text &#125;&#125; &lt;/li&gt;&lt;/transition-group&gt;参考：过渡：进入，离开和列表keep-aliveProps：include - 字符串或正则表达式。只有名称匹配的组件会被缓存。exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。max - 数字。最多可以缓存多少组件实例。用法：包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 相似， 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。当组件在 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 树内的所有嵌套组件中触发。主要用于保留组件状态或避免重新渲染。1234567891011121314151617&lt;!-- 基本 --&gt;&lt;keep-alive&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 多个条件判断的子组件 --&gt;&lt;keep-alive&gt; &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt; &lt;comp-b v-else&gt;&lt;/comp-b&gt;&lt;/keep-alive&gt;&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;&lt;transition&gt; &lt;keep-alive&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/transition&gt;注意，是用在其一个直属的子组件被开关的情形。如果你在其中有 `v-for` 则不会工作。如果有上述的多个条件性的子元素， 要求同时只有一个子元素被渲染。include and exclude2.1.0 新增include 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：1234567891011121314&lt;!-- 逗号分隔字符串 --&gt;&lt;keep-alive include=&quot;a,b&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;&lt;keep-alive :include=&quot;/a|b/&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 数组 (使用 `v-bind`) --&gt;&lt;keep-alive :include=&quot;[&apos;a&apos;, &apos;b&apos;]&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配。max2.5.0 新增最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。123&lt;keep-alive :max=&quot;10&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 不会在函数式组件中正常工作，因为它们没有缓存实例。参考：动态组件 - keep-aliveslotProps：name - string，用于命名插槽。Usage：元素作为组件模板之中的内容分发插槽。 元素自身将被替换。详细用法，请参考下面教程的链接。参考：通过插槽分发内容VNode 接口请参考 VNode class declaration。服务端渲染请参考 vue-server-renderer package documentation。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB]]></title>
    <url>%2F2019%2F08%2F20%2FMongoDB%2F</url>
    <content type="text"><![CDATA[MongoDB的服务会开机自启动MongoDB数据备份与恢复要在bin目录下执行]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js]]></title>
    <url>%2F2019%2F08%2F13%2FNode-js%2F</url>
    <content type="text"><![CDATA[基础知识TIPSNodeJS访问数据库mysqljs12345678910var mysql = require('mysql');var connection = mysql.createConnection(mysqlConfig);connection.connect();connection.query('SELECT 1 + 1 AS solution',function(error,results,fields)&#123; if(error)throw error; console.log('The solution is:',results[0].solution);&#125;);connection.end();egg-mysql123456const results = yield app.mysql.select('posts',&#123; where:&#123;status:'draft'&#125;, orders:[['create_at','desc'],['id','desc']], limit:10, offset:0&#125;);写SQL实现一个服务端分页123456789101112131415161718192021222324// 拼接各种条件let whereSql = 'where online_version is not null and state &lt;&gt; 1';if (scope == 'only') &#123; whereSql += ' and use_scope like "%' + query.use_scope + '%"';&#125;whereSql += handleIn(query) + handleEqual(query) + handleLike(query);// 取得全部数据条数const sqlTotal = 'select count(*) as total from component' + whereSql;const resultTotal = yield this.app.mysql.query(sqlTotal, values);// 取得当前页数据let sqlSelect = 'select * from component'sqlSelect += whereSql;sqlSelect += ' order by modified_time desc, id desc limit ';sqlSelect += (pageIndex - 1) * pageSize + ',' + pageSize;const resultList = yield this.app.mysql.query(sqlSelect, values);// 返回分页结果const result = &#123; list: resultList, total: resultTotal[0].total,&#125;;return result;那有没有更简洁的方法去操作数据库呢，答案是肯定的社区有很多优秀的orm或sql builder的类库比如objection、sequelize、knexjs、squel等。同步太多容易造成异步回调黑洞面试题nodejs导出导入原理？？]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery]]></title>
    <url>%2F2019%2F08%2F12%2FJQuery%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS]]></title>
    <url>%2F2019%2F08%2F12%2FAngularJS%2F</url>
    <content type="text"><![CDATA[概述AngularJS是什么AngularJs（后面就简称ng了）是一个用于设计动态web应用的结构框架核心是对HTML标签的增强使你能够用标签完成一部分页面逻辑AngularJS是一个 MV* 框架，最适于开发客户端的单页面应用重要功能与特性双向的数据绑定模板MVCMVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发MVC是一个设计模式，它强制性的使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务优点：可以为一个模型在运行时同时建立和使用多个视图。变化-传播机制可以确保所有相关的视图及时得到模型数据变化，从而使所有关联的视图和控制器做到行为同步视图与控制器的可接插性，允许更换视图和控制器对象，而且可以根据需求动态的打开或关闭、甚至在运行期间进行对象替换模型的可移植性。因为模型是独立于视图的，所以可以把一个模型独立地移植到新的平台工作。需要做的只是在新平台上对视图和控制器进行新的修改潜在的框架结构。可以基于此模型建立应用程序框架，不仅仅是用在设计界面的设计中缺点：增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能目前，一般高级的界面工具或构造器不支持模式。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成MVC使用的困难服务与依赖注入AngularJS服务其作用就是对外提供某个特定的功能AngularJS拥有内建的依赖注入（DI）子系统，可以帮助开发人员更容易的开发，理解和测试应用指令scopes module controllerscopes$scope是一个把view（一个DOM元素）连结到controller上的对象每一个Angular应用都会有一个 $rootScope。这个 $rootScope 是最顶级的scope，它对应着含有 ng-app 指令属性的那个DOM元素。TIPSfactory service provider之间的关系factory把 service 的方法和数据放在一个对象里，并返回这个对象service通过构造函数方式创建 service，返回一个实例化对象provider创建一个可通过 config 配置的 service，$get 中返回的，就是用 factory 创建 service 的内容]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql]]></title>
    <url>%2F2019%2F07%2F24%2FMySql%2F</url>
    <content type="text"><![CDATA[概念数据库数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。RDBMS 即关系数据库管理系统(Relational Database Management System)的特点：1.数据以表格的形式出现2.每行为各种记录名称3.每列为记录名称所对应的数据域4.许多的行和列组成一张表单5.若干的表单组成databaseRDBMS术语数据库: 数据库是一些关联表的集合。数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。列: 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。外键：外键用于关联两个表。复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。MySql常用命令行连接数据库格式：mysql -h主机地址 -u用户名 －p用户密码查看数据库：show databases;选择并进入数据库use databasename;查看表show tables;查看表结构desc tablename;查看表数据select * from tablename;where条件语句select student_age from pre_student where student_age &gt; 14 and student_age &lt; 18;in枚举查询SELECT * FROM pre_article WHERE aid IN (1, 3, 5)%模糊查询SELECT FROM pre_user WHERE username like “%张%”; // 所有SELECT FROM pre_user WHERE username like “%张”; // 小张张SELECT * FROM pre_user WHERE username like “_张%”; // 小张张 大张伟%：代替一个或多个字符_：代替一个字符limit限制SELECT * FROM table LIMIT 5; // 直接查条数SELECT * FROM table LIMIT （index, length）; // 以哪个下标开始，共多少条数据。order by排序降序：desc升序：ascselect * from pre_student order by student_age desc插入数据INSERT INTO user (username,password) VALUES (‘admin’,’123456’);修改数据(必须指定条件 where，不然全部都会被修改到！)UPDATE user SET username = ‘admin1’, passwd =’12345678’ WHERE uid = 10删除数据DELETE FROM user WHERE uid = 10配置my.ini1234567891011121314151617[client]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\web\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\web\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP]]></title>
    <url>%2F2019%2F07%2F24%2FPHP%2F</url>
    <content type="text"><![CDATA[mysql_connect()连接数据库mysql_select_db选择数据库mysql_fetch_assoc()获取结果集mysql_query()执行sql语句phpintval() 函数用于获取变量的整数值。intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2F2019%2F07%2F07%2FJavaScript%2F</url>
    <content type="text"><![CDATA[基础知识TIPSjs实现继承的几种方式(https://www.cnblogs.com/chaixiaozhi/p/8515087.html)1、原型链继承核心：将父类的实例作为子类的原型缺点：父类新增原型方法/原型属性，子类都能访问到，父类一变其他的都变了123456789101112131415161718192021222324252627function Person(name)&#123; this name = name;&#125;;Person prototype.getName = function()&#123;//对原型进行扩展 return this.name;&#125;;function Parent(age)&#123; this.age = age;&#125;;Parent.prototype = new Person('老明');//关键//通过构造器函数创建出一个新对象，把老对象的东西拿过来Parent.prototype.getAge = function()&#123; return this.age;&#125;;//Parent.prototype.getName = function()&#123; //可以重写父类继承来的方法，会优先调用自己的// console.log(222);//&#125;;var result = new Parent(22);console.log(result.getName());//老明//调用了从Person原型中继承来的方法(继承到了当前对象的原型中) console.log(result.getAge());//22//调用了从Parent原型中扩展来的方法&#125;2、构造继承基本思想借用构造函数的基本思想就是利用call或者apply把父类中通过this指定的属性和方法复制(借用)到子类创建的实例中因为this对象是运行时基于函数的执行环境绑定的。也就是说，在全局中，this等于Windows，而当函数被作为某个对象的方法调用时，this等于那个对象call、apply方法可将与一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象所以，这个借用构造函数就是，new对象的时候(new创建的时候，this指向创建的这个实例)，]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS]]></title>
    <url>%2F2019%2F06%2F05%2FCSS%2F</url>
    <content type="text"><![CDATA[CSS命名规范常规命名头：header内容：content/container尾：footer导航：nav侧栏：sidebar栏目：column页面外围控制整体布局宽度：wrapper左右中：left right center登录条：loginbar标志：logo广告：banner页面主体：main热点：hot新闻：news下载：download子导航：subnav菜单：menu子菜单：submenu搜索：search友情链接：friendlink页脚：footer版权：copyright滚动：scroll内容：content标签页：tab文章列表：list提示信息：msg小技巧：tips栏目标题：title加入：joinus指南：guild服务：service注册：regsiter状态态：status投票：vote合作伙伴：partner注释的写法/ Footer /内容区/ End Footer /id的命名容器: container页头：header内容：content/container页面主体：main页尾：footer导航：nav侧栏：sidebar栏目：column页面外围控制整体布局宽度：wrapper左右中：left right center页面结构容器: container页头：header内容：content/container页面主体：main页尾：footer导航：nav侧栏：sidebar栏目：column页面外围控制整体布局宽度：wrapper左右中：left right center导航导航：nav主导航：mainbav子导航：subnav顶导航：topnav边导航：sidebar左导航：leftsidebar右导航：rightsidebar菜单：menu子菜单：submenu标题: title摘要: summary功能标志：logo广告：banner登陆：login登录条：loginbar注册：regsiter搜索：search功能区：shop标题：title加入：joinus状态：status按钮：btn滚动：scroll标签页：tab文章列表：list提示信息：msg当前的: current小技巧：tips图标: icon注释：note指南：guild服务：service热点：hot新闻：news下载：download投票：vote合作伙伴：partner友情链接：link版权：copyrightclass的命名(1)颜色:使用颜色的名称或者16进制代码,如123.red &#123; color: red; &#125;.f60 &#123; color: #f60; &#125;.ff8600 &#123; color: #ff8600; &#125;(2)字体大小,直接使用”font+字体大小”作为名称,如12.font12px &#123; font-size: 12px; &#125;.font9pt &#123;font-size: 9pt; &#125;(3)对齐样式,使用对齐目标的英文名称,如12.left &#123; float:left; &#125;.bottom &#123; float:bottom; &#125;(4)标题栏样式,使用”类别+功能”的方式命名,如12.barnews &#123; &#125;.barproduct &#123; &#125;注意事项1.一律小写;2.尽量用英文;3.不加中杠和下划线;4.尽量不缩写，除非一看就明白的单词.主要的 master.css模块 module.css基本共用 base.css布局，版面 layout.css主题 themes.css专栏 columns.css文字 font.css表单 forms.css补丁 mend.css打印 print.cssCSS样式字体样式font-family=“微软雅黑”;当指定多种字体时，用“，”分隔每种字体的名称当字体名称包含两个以上分开的单词是，用“”把该字体名称括起来。当样式规则外已经有“”时,用‘’代替“”。color=#ccc;/设置字体颜色/16进制RGBAtext-decoration:underline;/字体加下划线/text-decoration:none;/去下划线/font-size:14px;/字体的大小/font-style:normal正常状态italic斜体字oblique 斜体和正常状态之间font-weight:number(100～900)lighter（细体）bold(粗体)bolder（特粗体）text-transform:uppercase 所有文字大写显示lowercase:所有文字小写显示capitalize 每个单词的头字母大写none 不继承母体的文字变形参数text-decoration:underline 为文字加下划线overline 为文字加上划线line-through 为文字加删除线blink 使文字闪烁none 不显示上叙任何效果可以用font 属性全部定位p{font:italic bold 12pt;}边框与填充样式margin：外边距与边距的距离(margin-top margin-left margin-bottom margin-left)取值可以是：auto默认百分比或者具体的值：取值可以是一个或者两个或者三个或者四个（每个都具有不同的含义）。4:上右下左3：上，左右，下2：上下，左右padding内边距复合属性填充（指用白值填充）和margin的用法一样。border-styleborder-top-style:上边框样式border-right-style:右边框样式border-bottom-style:底边框样式border-left-style:左边框样式取值：none 不现实边框，为默认值dotted 点线（电线）dashed 虚线，也称短线solid 实线double 双实线groove 边框带有立体感的沟槽ridge 边框成脊形inset 使整个表框凹陷，即在边框内嵌入一个立体边框outset 使整个边框凸起，即在边框外嵌入一个立体边框border-color=“#ccc”;/设置边框颜色/border-width：border-top-width:上边框宽度border-right-width:右边框宽度border-bottom-width:底边框宽度border-left-width:左边框宽度取值为：medium 默认宽度thin 细边框thick 粗边框border:1px solid #999;/添加一条边框/border-top：上边框border—right：右边框border—bottom：底边框border-left：左边框背景样式background-color背景颜色background-image背景图片background-repeat:repeat 表示图像从水平和垂直角度平铺no-repeat 不重复平铺背景图片repeat-x 使图片只在水平方向上平铺repeat-y 使图片只在垂直方向上平铺background-attachment 参数fixed 网页滚动时，背景图片相对浏览器而言固定不动scroll 网页滚动时，背景图片相对浏览器而言一起滚动background-postion ：（背景定位）top 相对前景对象顶对齐bottom 相对前景对象底对齐left 相对前景对象左对齐right 相对前景对象右对齐center 相对前景对象中心对齐可以直接用 background 复合属性来确定式样示例：table{background:#001122 url(zhouliang.jpg) no-repeat bottom right}文本样式word-spacing:英文单词间距取值：normal或者是单位像素letter-spacing:英文字母间距取值可以是：normal或者是单位像素line-height:行距可以是精确的值，也可以是百分比text-aglin:文本水平排列left: 左对齐right：右对齐center: 居中justify:相对左右对齐。注意到：text-aglin 是块级属性，只能用于p、blockquqte、ul、h1-h6等表示vertical-align:文本垂直排列top 顶对齐 bottom 底部对齐 text-top 相对文本顶对齐text-bottom相对文本底对齐 baseline:基准线对齐 middle 中心线对齐sub 以下标的形式对齐 sup 以上标的形式对齐,相对于元素行高属性的百分比text-indent：文本缩进缩进距离必须是值或者百分比white-spacenormal：合并连续的多个空格pre：保留原样式nowrap：不换行，直到遇到br标签text-decoraitionnone :表示不对文本进行修饰，也是默认值，underline:表示对文字添加下划线overline:表示添加上划线line-through:表示对文本添加删除线blink:表示文字具有闪烁效果text-transform：文本转换none:表示原有值capitalize:使每个字的第一个字母大写uppercase:大写lowercase:小写定位样式postionabsolute 采用绝对定位（分别用四个边框来定位）relative 采用相对定位（也得用四个边框来设定位置）static 默认值left/top/width/height设置值可以是z-index也就是元素的堆叠,大的在上，小的在下。默认是按照先后顺序取值auto默认值，表示它遵循其父对象的定位属性如果设置为数字,必须是无单位的正整数，可以取负值，但是一般为正数,一般数字为1时间是最底层布局样式visibility 可视性inherit：表示对象继承父本的继承性。visible:表示对象可见hidden：表示对象隐藏视口width=device-width ：表示宽度是设备屏幕的宽度initial-scale=1.0：表示初始的缩放比例minimum-scale=0.5：表示最小的缩放比例maximum-scale=2.0：表示最大的缩放比例user-scalable=yes：表示用户是否可以调整缩放比例display设置或检索对象是否及如何显示block、inline、list-item、noneclip可视区域auto表示对象不裁剪rect(数值表示)(一般有四个设置值：方向定位于上右下左的顺序，一般以左上角(0,0)坐标计算4个偏移数值。其中 任何一个值都可以用auto代替)overflow超出范围isible 扩大浏览器hidden 裁剪掉多余的文本scroll 滚动条auto 当有多余的时候才显示滚动条float 浮动属性left表示文字浮在元素左侧right 表示文字浮在元素右侧none 默认值，表示不浮动。重点clear ：表示指定一个元素周围是都允许有其他元素漂浮在它的周围。left ,right,none,both;指要清除本元素四周的浮动对象page-break-beforealways 是否强制分页page-break-afteralways 打印后设置是否强制分页width和height表示层的宽度与高度设置值为 auto|数值列表样式list-style-type指显示于列表项前的标识符号none 表示不显示列表符号list-style-postion列表缩进inside 列表内容和列表标识符号处在不同垂直位置，在符号内侧outside 列表内容和列表标识符号处在同一垂直位置list-style-image用图片符号作为链接标题none 表示不指定图像url(网页地址) 指定图片位置list-style复合属性：实现以上三种光标样式cursor当点击某个内容时，鼠标显示其他的图形style=”cursor:hand” 手形style=”cursor:crosshair” 十字形CSS尺寸tips任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合:1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了绝对单位in英寸（Inch），绝对长度单位pt绝对长度单位。点（Point）。1in = 2.54cm = 25.4 mm = 72pt = 6pcpc绝对长度单位。派卡（Pica）。相当于我国新四号铅字的尺寸。​ 1in = 2.54cm = 25.4 mm = 72pt = 6pccm绝对长度单位。厘米（Centimeter）。​ 1in = 2.54cm = 25.4 mm = 72pt = 6pcmm绝对长度单位。毫米（Millimeter）。​ 1in = 2.54cm = 25.4 mm = 72pt = 6pc相对长度单位px相对长度单位。像素（Pixel）em相对长度单位。相对于当前对象内文本的字体尺寸ex相对长度单位。相对于字符“x”的高度。此高度通常为字体尺寸的一半。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。rem区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素选择使用什么字体单位主要由你的项目来决定，如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破冰行动-蔡永强]]></title>
    <url>%2F2019%2F06%2F02%2F%E7%A0%B4%E5%86%B0%E8%A1%8C%E5%8A%A8-%E8%94%A1%E6%B0%B8%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[[内容源于网络]我国著名语言艺术家、职场生存大师、实证主义理论家思想家、东山公安局最佳辩手、看破不说破大师、金句boy蔡永强语录言归正传。蔡永强的自述光芒四射，但关键信息点却落在蔡永强与李维民的对话上。先来看这三段对话设计。对话一：李维民：“你让谁秘密接触林三宝？”蔡永强：“就我自己，局里队里没有任何人知道我们以何种方式联络。什么时间什么地点，他们一概不知。”李维民：“为什么？”蔡永强：“刚才说过，公安局是一个情报中心。”对话二：李维民：“你对马云波不相信？”蔡永强：“我有这方面的暗示吗？”对话三：李维民：“你对林三宝车祸身亡怎么看？”蔡永强：“无非两种结论，一种是正常的车祸，他运气差，我们运气也差。另外一种结论，他被杀人灭口了，我们运气更差，因为没有证据。”李维民：“你倾向于哪一边？”蔡永强：“我没有倾向性，证据说话。”李维民：“你有点言不由衷。”蔡永强：“不是每个人都看得见真相，但每个人一定能成为真相。”对话四：李维民：“你怎么看待陈光荣？”蔡永强：“工作能力很强，办案有一套，有资源，有人脉，有个性。”李维民：“全是优点，缺点呢？”蔡永强：“有时候优点，就可能变成缺点。”看出共同点了吗？面对李维民多次蕴风雷于平淡中的询问，他始终没有给出正面肯定的回答，但是每一次回答又没有一句谎话。为什么？因为蔡永强不信任李维民。李维民的每一次提问看上去像是他对蔡永强的质疑，其实又何尝不是蔡永强对李维民的试探？“有个笑话，说谣言和真相是一对双胞胎，谣言性子急，走在前面，大家发现他是冒充的，被拍死了，等真相慢慢出了门，大家发现原来谣言和真相，一模一样。”这段话语意深远！李飞可以在审讯中反复用肯定句进行无证推断，因为他和李维民彼此信任，但是蔡永强不可以，他和李维民之间横亘着一条猜疑链，如果李维民是狼呢？他怀疑马云波，李飞怀疑他，而马云波和李飞又是李维民的嫡系，在没有证据的情况下讲错一句话，被当成谣言拍死的就是他。成年人的成熟是从“忍得住”开始的。还有人觉得蔡永强滴水不漏的说话艺术仅仅是信奉明哲保身吗？他对李维民的试探是他主动出击的方式，一旦付出信任，蔡永强将毅然成为缉毒前线一把最强的火枪。缉毒是以肉饲虎！不图名利，不图权势，每天面对的都是穷凶极恶的亡命之徒，正常人谁会去干这个？信仰的力量，可填山海。致敬和平年代的真心英雄！囚徒困境和猜疑链蔡永强和李飞联手审讯毒贩这场戏真的是目前为止最过瘾、最有戏剧张力、最火花四溅的一场戏，审讯艺术与戏剧艺术的结合妙至毫巅。引用两个名词：囚徒困境和猜疑链。囚徒困境出自博弈论。两个囚徒同时被捕，在无法互相沟通的前提下，如果两个人合作互不揭发，因证据不足，每个人都坐牢一年；如果一人揭发，另一个沉默，揭发者会因为立功而获释或减刑，沉默者则入刑十年；如果互相揭发，两个人都会因为证据确凿而获罪八年。大虾和麻子就是囚徒困境中的这两名犯人。走出囚徒困境的方法其实很简单，保持信任，创建合作。起初大虾和麻子是这样做的，各自保持沉默。按这个情形下去，两人的罪名顶多是吸毒和容留吸毒，无法找到突破性的关键证词。如何让这两个人互相揭发呢？轮到猜疑链发挥作用。猜疑链出自科幻小说《三体》。猜疑链导致文明无法互相判断彼此之间的善恶，并最终驱使双方相互敌视，无法形成共同认知。同样，猜疑链放到人类关系中也可以适用。蔡永强真是深谙人性的高手，合作哪有那么简单？人总是自私自为且不彼此信任的动物。他先通过猜硬币的方式将两人隔离，触发猜疑链，随后李飞借假口供制造大虾已招的假象，毒瘾发作判断力下降的麻子无法判断大虾是否会出卖他，紧接着，蔡永强和李飞迅速跟进对他进行诱导加强，两个人一唱一和默契唱起了双簧，很快就让麻子的心理防线全面崩溃。既然麻子已经吐得干干净净，合作创建失败，眼下的局面对大虾已经没有任何实质性的好处，一味死扛甚至可能会赔上性命，蔡永强此时说出的“我橄榄枝，只给你抛一次”，便是压垮骆驼的最后一根稻草。行云流水，步步推进，成竹在胸，难怪李飞会说庆幸里面坐的不是他。我的眼睛里只能看见一个人，蔡永强队长。这个人我可以夸到词穷，夸到笔墨难言。但是故事落幕，我不想这么简单地夸夸而已了。我想了解他，记住他。他的故事，是这部剧最感动我的部分。第一集 塔寨雨夜整个故事的开始，是一个暴雨之夜的抓捕行动。东山市公安局禁毒大队的两个年轻民警带领三名从盘锦市来的同志夜袭塔寨村，抓捕了一名叫林胜文的制贩毒嫌疑人。本来以为这只是一个简单的抓捕行动，没人想到，就是这次抓捕拉开了广东省乃至全国最大的一次打击毒品战役的序幕。而那个暗中布局拉动绳索的人，就是他。林胜文被抓回来后，蔡队质问李飞为何不在惠东林的岳家抓人，却擅闯塔寨林胜文所在的塔寨村，是东山市禁毒模范村。东山市一切打击毒品相关的行动，到了塔寨全部绕路而行。李飞成功抓捕林胜文回来后，与队长蔡永强发生了对峙。蔡永强质问他为什么擅闯塔寨，句句都是指责，却也句句都是暗示。然而此时的李飞已经对蔡永强失去信任，错过了他话语中的信息。暗示塔寨全村涉毒极为危险蔡永强提到之前的一次行动，由于抓捕时进错了屋，六个警察被村民围困一天一夜。这就是导致东山市禁毒举步维艰的最大原因：宗亲关系盘根错节，宗族之内相互掩护。以往事为鉴，所以蔡队昨夜暗暗安排了全队在村外接应（哥哥叉腰好可爱）就在林胜文被抓捕审讯后的第二天，龙坪市天平司法鉴定中心开出鉴定报告，林胜文因身患“心脏疾病”，符合保释条例。他被保释了。李飞愤怒地质问蔡永强，为什么在申请鉴定的报告上签字？是啊！为什么呢？很快你就会知道了。东山，没好人。在这里，想活下去，太难了。想留着命和手中武器，挣扎去打击犯罪，难上加难。林胜文被火速保释，面对李飞的愤怒质问，蔡队有口难言神图镇楼，哥哥苏到极限的一秒！第二集 杀机重重南井村。养鸡场。蔡永强赶到时，一切都已经晚了。他看见那两个年轻人，一个被毫无尊严地捆绑屠杀，一个满身血污命悬一线。这是一个针对他们两个精心布置的陷阱。而让他们走到了一脚踩进陷阱的如今的开端，正是不久前的那一场夜袭。蔡永强没想到自己算到了一切，却没有算到林胜文这个小虾竟然吐出了“你们领导挣300万”的猛料。而恰恰是他将李飞与自己在立场上割离的决策，让李飞决定对他隐瞒了这个致命的信息。“东山，没好人。”那个年轻人说。心如刀割。一死，一伤。蔡永强终于体会什么叫心如刀割。李飞被送进东山市人民医院。他身上扎着输液管，门外还坐着一名警员。蔡永强带着周恺和另一名队员赶到医院时，看见的是一个踉跄跑出病房的李飞。“李飞！不要动！”他不会傻得要逃走吧？这时候走了跟认了自己有罪有什么区别？蔡永强按住李飞，他这个时候还以为自己能控制住局面，审讯李飞的权力能留在自己手中。“蔡永强，你怀疑我？？？”我不怀疑你。我最信任的就是你。但是你可老实点儿吧！蔡永强把李飞按回病房，以为自己还能控制局面李飞被上手铐了=_=||| 作为一个病人，他太不“老实”。蔡永强一眼就看见乱七八糟的病房和地上散落的碎玻璃片。这不对劲。早先副队陈自力给他打来电话，枪弹检验报告显示，李飞和宋杨身上的枪伤分别是对方的警枪造成的。这明明白白就是在说，是李飞杀害了宋杨。这是个局！设局人什么都算好了，连同宋杨前女友弟弟车上的冰毒，和李飞家里的一百多万现金，一并奉上给你看。而他们禁毒大队，他蔡永强，被排斥在外了。自己的队员出了事，上司却嘱咐“检验报告别让他们拿到”。是谁？罗旭？还是马云波？涉及李飞本人的案子，蔡永强将费力打探来的信息全无保留告知。明白在说：我信任你，你是自己人。码字好累，欣赏一下永强哥哥的长睫毛慰劳下自己！哥哥的睫毛！轻轻抚在我的心上！陈光荣来要李飞。面对这个多年的战友，蔡永强心情非常复杂。情感上，陈光荣是自己多年的战友、朋友，说两人亲如兄弟也不为过；可理智上，蔡永强告诉自己，要和他保持距离。“五·一三案成立了专案组。你的名字，不在专案组名单上。”蔡永强看着陈光荣。你怎么掺和进这件事来？是上面的命令？还是你主动寻来的机会？怀疑曾经一起并肩作战的战友，是痛苦的。无论如何，李飞不能交出去。这个人是自己手下的队员，更是自己把他推出去做那把割破塔寨黑幕的尖刀。若是进了黑白不明的刑侦大队，没准有无数手段在等着他。电话挂断，无果。蔡永强脸上毫无表情，心里却泛起愤怒。对上司，对自己，对眼前这个善恶难辨的前战友。可是不是有句话说吗？把脾气压下去，是本事。愤怒有什么用？关键是怎么解决掉眼下这个麻烦。刚才的电话已经拖延了一点时间，李飞能不能自己跑掉？刚才他是不是就想跑来着？他还戴着手铐吧……要是他还在房里，怎么迅速搜集证据给他翻案？做局的人很可能就是顶头上司……难啊！蔡永强！门打开了。太好了。蔡队一眼识破，却给周恺打眼色不要声张，随后让周恺把地上的可疑玻璃片拿去化验。第三集 一线希望五·一三案，蔡永强被彻底排斥在外了。自从李飞顺利从医院病房溜走，他就再没有消息传回来过。这太正常了。他不信任蔡永强。蔡永强面上总是过分谨慎、明哲保身，林胜文被火速保释后，李飞甚至怀疑蔡永强就是东山毒贩的保护伞。在他被当作重大嫌疑人通缉、朝不保夕之际，他最不可能联系的一个人，就是蔡永强。但蔡永强不是完全没有办法。公安局，是一个信息的集散地。“丰益宾馆”，他得到了这四个字。李飞会去中山吗？副队陈自立带来了一个信息，蔡永强不知是好还是坏。“一提到‘丰益宾馆’，中山的兄弟都讳莫如深，打听不出什么消息。”打听不到消息，就说明了一个答案，同时也是一个暗示。赵学超不接电话了。这说明李飞极有可能去了中山，并且赵学超能找到他。这很好。赵学超此人是李维民的亲信，不论李维民立场如何，他总不会害李飞。蔡队的语气中有无奈，也有一点放心而此时不接电话的赵学超在干什么呢？此时，就在千方百计打探消息的蔡永强所不知道的地方，一个专门为了此案成立的联合调查组成型了，负责人正是广东省公安厅禁毒局副局长李维民，同他一同前来的还有一名公安部禁毒局的处长，左兰。对蔡永强来说，这将是一个千载难逢的机会。联合调查组抵达东山第五集 千载难逢李维民来了，带来了由广东省和公安部两级领导组成的“五·一三案联合调查组”。李维民是谁？广东省公安厅禁毒局副局长，广东省资历最深的老缉毒警，干缉毒的老祖宗。李维民和公安部禁毒局处长左兰的到来让蔡永强看见一个千载难逢的机会，他几乎要按捺不住胸中那团默默烧了多年的暗火，直要让它一把将东山这个烂泥潭燎个干净！！然而就在热血上头的一刻，他忽然冷静了。李维民，是马云波的师父，是一手把马云波带到如今这个位置的人。他完全可靠吗？蔡永强不敢赌。直到李维民的到来掀起了一场波澜，蔡永强才放下了大半的心。有人不想李维民来东山。蔡队和周恺对视一眼，发现事情并不简单( ﹁ ﹁ )就在蔡永强知道了李维民所处的困境之后，左兰处长收到了一个匿名短信，短信里将闹事现场那几个活跃分子的黑历史扒得一干二净。聪明如你肯定当时就猜到这个信息是谁发的啦！即使驽钝如我，随着剧情的发展，这个谜底也被揭开了。蔡永强的一双火眼金睛，仅凭着被“有心人”传上网络的一段短短的视频，就将那几个熟面孔一眼识破。这说明东山的涉毒分子，不论大小，在他的心中全部了如指掌。有蔡队这个强力辅助，李维民才能轻轻松松一举破局李维民来东山，是来调查五·一三案的。而他来之前，李飞就给他提供了一个可怀疑的目标。蔡队知道李飞在怀疑他，他从未怪过李飞调查组抵达东山后，蔡永强和李飞在一墙之隔的两间审讯室同时接受了问询。蔡永强把接待盘锦同志的任务交给李飞，李飞通过水伯查出“黑豆”就是塔寨村林胜文后，立刻向蔡永强请示进村抓人。李飞接了盘锦的案子，认出“黑豆”就是塔寨村林胜文，于是向蔡队汇报请求抓人然而蔡永强一开始以自己在外地为由暗示不同意他立刻去抓人，在他的坚持下又命令他将抓捕林胜文的消息保密，随后林胜文刚抓捕就被火速保释，这让李飞对蔡永强产生了极大的怀疑。林胜文对他吐出“300万保护伞”的消息后，他坚持认为这顶保护伞就是蔡永强。蔡永强的过分谨慎和叮嘱他对队内保密的行为让李飞怀疑该来的终于来了。蔡永强知道，如果不能对当初刻意把自己和李飞宋杨的抓捕行动切割开的行为做出一个合理的解释，将坐实调查组对自己的怀疑。但是能说吗？为什么装作不同意去塔寨抓人？为什么只让李飞宋扬两个人去？为什么明明派了全队人在村外接应保护，却让李飞他们守口如瓶？说不出。在不清楚李维民会对马云波极可能已经腐化的猜想采取什么立场之前，在没有抓到马云波就是保护伞的实质证据之前，蔡永强什么都不能说。不过没关系，河源的案子是早就准备好的借口。自己远在河源，其他队员手里都有案子，让李飞和宋杨去就顺理成章。不知蔡永强想没想到，李飞会将自己嘱咐他们将行动对人保密的话告知给调查组，而周恺在犹豫后，证实了这一点。抓不到马云波的把柄，又摸不准李维民的态度，蔡永强只能用借口敷衍调查组在被问到为何要李宋二人对队员保密时，他犹豫了。没有借口了。要说吗？第六集 滴水不漏“你为什么要向李飞交待，不要跟队里所有人讲。”蔡永强知道，如果这个问题自己做不出合理解释，自己身上的疑点就会一直存在。但是一天抓不到马云波的把柄，他就一天说不出真话。犹豫了几秒，他用技巧回避了。“我不记得我说过这句话。”抓不到马云波的把柄，又摸不准李维民的态度，蔡永强不敢说出自己的真实意图，只能回避。为什么让李飞他们保密？因为要防着马云波。李飞和马云波走得太近了。他不服蔡永强，不信他，怀疑他。但是他信马云波，听马云波的话。李飞因为抓捕林胜文吃了蔡永强一个处分后，马云波一句“这是组织商讨的决定”就打消了他的不平。他给马云波挡过子弹，把马云波当自己的大哥。而蔡永强，这个温吞谨慎，看似明哲保身、小心翼翼的家伙，李飞瞧不起他，也不屑于知道他到底是怎么想的。林胜文的火速保释，和蔡永强在鉴定申请书上的签名，成了李飞怀疑他的要点，而这一点显然引起了调查组的注意。蔡永强才不去管这个签名会不会成为他职业生涯中的一个的黑点，他只对自己说，机会来了。塔寨有人出面要求保释林胜文，蔡永强向马云波请示。他没有证据能够证明马云波已经站在塔寨一边，只好用这个方法去试探他的态度。而马云波会怎么说，蔡永强也预想到了。如果他不同意保释林胜文，他当时就会直接挡回去，但他回答的是：如果符合条件，你自行决定。蔡永强不是主动去申请鉴定林胜文是否够格保释，而是林耀东出面了，他才向马云波请示。结果当然是符合条件。调查组问到林胜文的保释，这简直正中蔡永强的下怀。他找到机会，在话里特别强调了那家给林胜文提供保释条件的“龙坪天平司法鉴定中心”。蔡永强都数不清有多少次，今天抓的嫌疑人，明天就被人保释出去。这个号称“天平”的机构明显有问题，蔡永强已经盯它很久了。今天就趁着调查组的东风，揭一揭它的画皮。法人是谁，什么背景，蔡永强想尽办法去调查。“出具过很多次类似的鉴定报告”、“能量很大，上面总有人替她说话。但背后的势力是谁，我不知道。”但就算他关系再广，也有查不到的人。因为林胜文的火速保释，李飞敏锐地意识到问题出在塔寨村。一定是塔寨村有人出面了，他才会那么快被“捞”出去。李维民终于问出这个让蔡永强谨慎、不忿了多年的问题：“你认为塔寨村有问题吗？”有！问题大了！什么禁毒模范村！东山市戴了多少年的毒帽？这几年里大大小小无数次扫毒行动，到了塔寨全部绕道而行，你说塔寨有没有问题？但是蔡永强能像李飞一样，凭着直觉提出指控吗？他不能。他没有证据。毫无证据之下，贸然指控一个禁毒模范村、一个两级人大代表有问题，这是要犯政治错误的。他蔡永强还想不想留着这个禁毒大队长的位子，在东山继续跟毒贩子们、跟塔寨斗下去了？此时此刻，任何没有证据的指控，都是没有意义的。蔡永强的一切城府和谨慎，都是吃够经验教训学来的。然而李维民似乎铁了心不吃这一套。在他的追问下，蔡永强给出了这场审讯的第二个技巧性回答：滴水不漏第七集（上） 一尘不染蔡永强受到了指控。这不是我自找的吗？他自嘲地想。李飞坚持，蔡永强，还有坚定站在他身边的陈自立和周恺，就是东山毒贩的保护伞。他出身大小毒贩出没的南井村，和毒贩子们沾亲带故，不是亲戚就是同学，走动起来毫不避嫌。今天抓进来的毒贩子，过几天就被“捞”出去了，放他们出去的不是他蔡永强，还能是谁？蔡永强啊蔡永强，一个东山人在东山干缉毒，你真是自找的。当年从村里考上来干警察的时候，蔡永强就想，我到底要不要干缉毒。远的不看，就看看班上那些同学里，有多少个沾上毒品家破人亡？又有多少个为了挣这个脏钱六亲不认丧心病狂？东山，太黑了。在东山干缉毒，太难。往上三辈都是亲戚，出门五步都是同学。白天抓了一个，晚上就有十七八个亲戚朋友拐着弯儿的来家里探消息，送礼，试探能不能“捞人”。越干越孤独。越干心越硬。毒贩子们刀尖舔血挣的是一夜暴富，他干缉毒的拿命去拼挣的是一个月三千块。面对儿子书包里的两万块钱，没冲击吗？蔡杰什么都没说，也没提任何要求，就是装了两万块，在自己还在上小学的儿子的书包里。什么意思？我认识你儿子。今天我能往他书包里塞钱，明天不一定还能干点什么。那天蔡永强盯着那个书包，盯了一宿合不上眼。而今天，这个“东山人”的身份，终于天然地让组织怀疑了。“你能证明我要了吗？”调查组同志怀疑、打量的眼神，让蔡永强有点无奈。知道这么难，为什么还要干缉毒？你是不是傻啊蔡永强！你为的就是那一个月三千块钱的工资吗？你为的就是混到现在亲朋疏远、孤身一人吗？我到底要的是什么？每过一段时间，蔡永强就会问问自己。然后他就听见了自己心里的答案。每一次，都一样。这个答案多少年都没有变过。谁是毒贩，这对我不重要。没有毒品，这对我很重要！看看那些被毒品祸害的老百姓！东山，不应该是这个样子！亲戚朋友不理解，同志战友有怀疑。蔡队跟谁诉过苦？有证据的话，就来指控我吧。蔡永强心想。要是对那些个大大小小的保护伞我也能这么轻轻松松地提出指控，那省了我多少功夫？身是菩提树，心如明镜台。蔡永强不是圣人，可有时候，一个普通人也能做成最伟大的事。第七集（下）处处艰难李飞怀疑指控蔡永强，蔡永强从没怪过他。他责怪自己。但是李飞对马云波的盲目信任，让蔡永强对他有些埋怨。明明咱们大队个个都是好样儿的，为什么他就是信不过？偏偏毫无理由地就信任马云波这个外来的。东山人怎么了？东山人在缉毒这行里就是原罪吗？东山人是最护着自己人的！他能去给马云波挡子弹，把队里大事小情全都跟他讲，还在事情没搞清楚之前，就去马云波面前告自己的状！“告密者”。蔡永强知道队里怎么看李飞。仗着跟副局长的关系，告了自己一状。看在最信任尊敬自己这个队长的周恺的眼里，这几乎等同于背叛。蔡永强不怪李飞，因为他不清楚实情。但是他更无法责怪为自己鸣不平的周恺。凭直觉做判断，有时是李飞的优势，有时却会成为他致命的弱点。马云波再英雄，他也是离你三尺远的副局长。你的兄弟们看着再平庸，关键时刻都是他们在盯你的背后啊！东山这潭水，太黑、太深了。明枪暗箭，防不胜防。不多长十七八个心眼，怎么活得下去？没有一帮过命的兄弟，怎么在一场场行动中全身而退？光凭着一腔孤勇、不顾己身，就能成事吗？蔡队金句。把脾气拿出来，是本事；把脾气压下去，是本事。因为在马云波面前告了自己一状，李飞被队里孤立了。蔡永强可以替他说话，替他在队里斡旋，挽回他的人际关系。实际上，蔡永强是一个很温柔的人，他可以原谅很多在普通人眼里是非常冒犯的事，再说他也从没因为这个怪过李飞。但是这个温柔的人做了一个无情的决定。他什么都没有做。他把李飞从自己的立场中割离开，连带着一起的还有宋杨。他选中了李飞，去做一把尖刀。宋杨死后，蔡永强无数次问过自己，后不后悔？后悔。不仅后悔，而且痛苦。但是重来一次，他骗不了自己，他还是会这么选。李飞和宋杨被全队人孤立，请注意，并不是蔡永强设计的，而是他做出了一个近乎背叛的行为。马云波。这个名字估计是蔡永强每天在脑子里念叨次数最多的一个。当年蔡永强有机会凭功绩升上东山市公安局副局长，可是半路冒出来一个空降兵，结果他就留在了禁毒大队，一留这么多年。这个空降兵就是马云波。省禁毒局副局长李维民嫡系弟子，全省出了名的禁毒英雄。这次他被派到东山来是奔着罗旭的位子去的，奈何深深扎根在疗养院的罗旭就是死占着坑不肯挪，他就成了副局长。马云波以往的禁毒工作太顺了，以至于他到了东山后，第一个看不上眼的就是他蔡永强和他手下这个禁毒大队。“东山如今禁毒形势严峻，你蔡永强，难辞其咎！”马云波新官上任，就借着李飞搭的梯子烧了一把火。看看恺恺的眼神，李飞就是这么被孤立的。马云波不明白为何一个手握国家机器的禁毒大队长，会弯下身段去调节几房村民的冲突矛盾，陪笑送烟，权威形象尽失。他不明白为何一个小小的东山，戴了几年的毒帽子都摘不下去。不就是一些毒贩子，能拧得过公安局的大腿？基层。稳定。宗亲。关系。越是小的地方，越是没有秘密。他们对你没有，你对他们亦然。新官上任，马云波烧到蔡永强头上的一把火，蔡永强能理解。但是如今的马云波，是蔡永强必须想办法拔掉的一颗钉子。保护伞，又多了一顶。第八集 霜刃暗藏马云波刚刚走马上任，就当着全大队的面，点名将蔡永强骂了个颜面扫地。调查组问，马云波当着所有人的面点你名，你是觉得委屈，还是愤怒？其实现在回想起来，蔡永强已经不太记得当时的心情。委屈吗？或许有一点。愤怒吗？也有一些吧。然而这愤怒不是冲着马云波，而是对自己，对自己的那种无力，更准确地说，那应该是一种难堪和羞愧。“我必须承认，他说的有道理。”东山禁毒局面如此艰难，他蔡永强这个禁毒大队长的确难辞其咎。马云波的一把火烧过后，蔡永强忍不住问自己，到底还有哪里没考虑到？为什么没能做得更好？到底有什么办法能把笼罩在东山的重重黑雾一把驱散个干净？蔡永强，你真的能行吗？他开始怀疑自己。怀疑自己的能力，怀疑自己的运气，甚至怀疑……不。他绝不怀疑自己的信仰。一天不行，两天。一年不行，两年。只要扛下去，别被打倒，别放弃寻找时机，总有一天会让他找到机会，把东山这大大小小的毒窝、保护伞，拔个干净。蔡永强此时说的不是客套话，而是真心话。在“唐旭吴刚演技大赏”一楼会详细分析。李飞。蔡永强注意到了这个热血的、聪明的、也有些莽撞的年轻人。他的热情和当年的自己真像啊！还有这小子那惊人的直觉。蔡永强仿佛看见了年轻时候的自己。年长一些后，蔡永强才发觉，那不是“直觉”，而是“观察力”和“潜意识”结合的产物。蔡永强欣赏李飞，不光是因为他的思维方式和自己极像，更是因为他对信仰的忠诚追求，和自己一模一样。而马云波和李飞亲近的关系，让蔡永强产生了一个想法。这个想法一冒头，蔡永强就对自己说：真是可怕。蔡永强，你看看自己是个什么人？然而一念生起，蔡永强再也没办法对它视而不见。它不停地在劝诱：听我的。多少年了？你不想动动塔寨吗？这个年轻人简直是最合适的利刃。他果敢，又有些冲动，最棒的是，有一个公安局副局长能在他的背后给他撑腰。就让他去动一动塔寨！你只需要保证他的安全，他的前途完全不需要你操心。你不是一直在等一个机会吗？李飞就是你的机会呀……这个声音不停、不停地在他心底轻搔，他做出了决定。“你会因为李飞跟马云波的关系，就对他另眼相看吗？”蔡永强，你是个什么人？蔡永强回避了，我猜不出他此时情绪如何。或许有愧疚吧。因为李飞的指控，调查组对蔡三毛的案子寻根究底。蔡三毛到底是怎么死的？这是一个无法回避的问题。顺风顺水的马云波不理解，李维民也很难赞同，身为一名国家机器的代言人，专职打击毒品犯罪的大队长，竟然会在调节几房村民的矛盾上面花上一个多月的时间，左右劝解，陪笑买烟。“这是你的本职工作吗？”在东山，没有基层关系的缉毒干警，是会有麻烦的。东山老百姓可以是庇护毒贩的百姓，也可以是警民一家的百姓。话是良言，可李维民才不上套。问你的是蔡三毛的真正死因，说到基层关系是不是答非所问？蔡永强犹豫了一下，将自己暗中发展线人的举动向他坦白了。不论李维民对马云波立场如何，蔡永强相信他对打击毒品犯罪，是真正的铁腕。十年磨剑，屡屡折戟。直到遇上了李飞，蔡永强终于找到了一把霜刃。及锋而试，可有大功 。]]></content>
      <tags>
        <tag>电视剧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO使用心得]]></title>
    <url>%2F2019%2F05%2F29%2FHEXO-tips%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! U2FsdGVkX19Fx/BlLQYsN0IFVfyEQ7QmHO6iVV3+bfGLtzKMKPyRTk3qZk29JuM67DqC4wcQ/1m3KhThBxh+P0rAIbz2LvtKvZTX9TBnHRk1FXLgiWhqSKxobpkPfHFCjkQ7rvtJlPsOdXHBFPdTdyQGVmiKL/nu5FC/2oKmL9dDLzBP9/mt2qHUpOXzQfs7mSkVAlxfZpDYk0h27E5QdEebg6sqwo7gvbNWlz/Z5//q7U+bhkNLezoEuvtOwasitHVGVQ3qa+/eVoVv+iqS0vxhNR/GlrRaGrEOmNY9yZSrBNPo/yxXfZOUw7/YbZjhNdx7U6x25Aw4ui93tvc/Lpm/ok29lKHPr9gtpACpX7pTw2D5UYmjNAdL/wnHXPgiNxi5pVPuyj4C+61hAqpyWiqN+pJIIIpqVWz3JljLRF+brCiNVlKrAR48gBjWuLL+NaWAJvtu99TS+/iLSV2i6MuN0MbKjgzyaSmtvvbXMFWdEjC1bGiB5MAPhiuiPdEgj0NYIbSYf3wB/Op+jC78Zgy3mTkzFr6usCh5RZuaHfGvR6t9kNcVAyGnYjZV96RJS0LgXRjREYLFT2HPwzi/GaN3/VUH/CjAbTQ7gekVuOVSeScrqEr613VUgA4aFJRtSS9grHeP2M5mgBHfCY4Fy9xhCUcqXLN0VY+w1NjtrCCtAa8TrIxXeWAXAGfcJKfEiGdV49nSAj9/ZpbmG+ywmFHOcY29BUFKK84acwAhwFJQ1J6B+VR/z2wSTXsid4zCWhYMlXXQ4xAdKPRsTm4ocHaJOoAI85TKFel9ZQxlpGAbER85mXNT++boARPX30f4JRYIreLOPOyjpawFKjtU882L04Ql+ws+IBO9RtUAEaEyXKf69PKar2zMN7n6QJyc61HUVkb3FajvAzrqRzJGSKHXV/yqScSKU8gO9ch2cnQqV7Tkvp+Nmt88cpII5espOBpJe/tHmlnnzYiA7LEuLn0rNcJy80bghT77LrtQRyK26VcZPChVLO9FGtion/gUDibIGvKkSggv8eQ0MOLA3Chv9rLf1lKC8b+XdiZcVqR5+yp/xYJss39A4FhFvLdUmRPsg4Sb/6gYxQCFhBGooNuW8G+xQvcbsFtiYzZ0dojHd4/SUC/w5BA0j9kSzuiQT7DQ64e8kNoQqjgQ+qhHIpLdwOcizl8PjKk4ai5N7yRewXBTJbKy4Y9G8IPfwaPiEHEuTH8VatcueSiVV5DU1pHjleTUE6azFFkkVUGU3qNjIun8CJLD62tw4UXHG06GUzXNUcKPeqRlbE05GYW8qj/sGAtViLhEA8x2O8bt0BDn9wa/karXLMZbSxUcTdXXc11IaVxiVXLrNN/N2e2Ht5Uj2IF4QIifM+5WKi/+3xt0ENraGbHwALZhGz+wyjc/tJ8pBUNEJyNE8xQ0t8iwm0HDcAHVdpkGEyHMetaJyihSAQJawWxkNAnE0g93QUfPB0seeSTn63yf89AwiJ595i+rNi9Pn1PrO7N9/IuTTHiukQjCASzoAngNU3S2XDD8qkaH9RMQLB6XPg1q9QVzcBkdXqFeFZMV9ozT7OPO+s9l1wACQCEKJh4/JCOFUX+GFbHYmgsUY+LX6LaRPpE1EKXisVX/1a/nUrbI0jyKFGyjsbtW0ySUEac48KnEQi2go1Jmn1gil5ija5r3A4k2ZdkOFCnLm+8+xdeOGKqaMBEDHILI0ocd7zRBrCzYn9smn4zlYtwxBZca51hCQO6zTFm5/36aZB4bYWeCi9yaxPthgb0T0SvoHirThtZTk9I51QDXoKvqLwxSdN2tKtQtBTliuoNsB+ES4pmfebU8Dj6OtO+3JXlr+yiiWjVJ4OGT6RyZS3ZBrBPIlgItG0fuimqT8G52qsRttgJZsGXlTLlRkBWAZVLSS95h8qOOjELo1Yk6Ti2r4WLoHUC3xpLYinUTlbJijled2TTff0g8/lv+fVUxJr8xKerfGu5FtPLgeLDXvH4cB+HOqcSA6EjTgaVi4KZnK+gQ9DPt+zj7dftneyIDovZ6Z6ieyKwWz1CBK+6DkTnCJW1rbnkQzYeDj2gsYg78MPhebPcQNS3oE4IfJqgZFq9kiKN7xnrBzhZkBaQgR+UraMS1hF+swJ6q0fSDSGCxax20koJJbcqX2ghmLPGVQofBYJKzWsfyKPSUJtrV004auFkozuH/Q7xIxDJQT5eBZhzsuwlO8IXbrP7zVydOqZU1xe/2GNuwfWvlHp+PTp4fAoF5fu2PFCMnImhxWuedRijRF8Gp3fj4twd4nDpY4cqmxfBYTyrmKeRkwhVsZvKRYbbMx86ixNWpEGx/hNsx26PfXc+dYiAma0Z4vgDESyKm+XzhOPklWeXkXLVziG9r0CkgXhxBoaSbbE5MYnRhfjUJ+atBf8a2AmA3A1bMOYyND7V0v32jLy/0CDnHCCS7j09sVzRbjusIkdVlosWJRcub1uuFS6kqdyf/DNAQT/GxvaiMIE/V+9/OyYGJo+P5Z3/f0PAkMpNwm5Cp72n8p5i1yFwfCwavfO4A2cVESaKpgL4VB/b0SPyhjaBMxMnShZ3t3k9iDU74SASW3hVH1BiZ/IgDaqzymypEHmC/AWo/qS94MSy72Hr7cjOJsVKrC3GasAsqd1XYtnO2SZTRIqnMR/N3zpgT+tfR7NaarqtT65OcBZhTRVw9eFxhX/tZRRhfRAMaZcal7tmWFvJexD148VecuJi4FUzkAZz+/btHbnPCWex3/3Nj4G0ZJvElZkDs+7A6Mo0mPNUx7SFEnMLqgwiat1/sgMRADC+uHoAd+NOQl3x27EAN3x+Zlz/FoHE5jWG061S1N8/VTXHd//NMtUIkQ+mxXk2exN7jxXZO6yiwwmCPNSWasTpxq+44bmgd2LPK1eUC8WX6W/FCqyIJkyzgujzms38yqP7HlC3YG/PJYg7mpNXScTkbDr0q9y18z/pdqxcLxcZ/AEJAYoDEQBsdOYFJ2ZJTAED4KyT2ThCyxrIBO4AloAj/mlR28ChcVXA4nptYkCKywjfCjCR+6IS6oyqAPZZtduQvnolXqBWwLKW2SIvS1a0in7Nv68jFB1FtBO6DvncLyXqh7elCnQq+Xlrp6DQ+XNzaHeQISU4gzrvxiTPtVe/rPJPGrBWnd9FGehA1UFYnyCxdY3AV5p9Peiyb17wRrjKtCgSIQT+3z38f749Uo57wNtzO89GJNYB1CD+8Jb6z+xLScxgnLl1Bv9ThIbAeKiHra2c+cBxMF6+VuvYXxlT+ZvqyzuPYZJBq9LPgjkenHeJTLmRKK3+2uSqTAV41kZMocuMiol9cMOLE96cnajCfVgSmtoVW5tnSoZ/J2zgKQAbtFb6D9I8S+yhRv//VfOEauNEPYkS0t05ZdHM+POPRDnWMAIl3SaUwrM8vk+4vxVkLTGnHYiosayhP7pk7mOADw6q5sg36qnwMFbjDtSvcDnZCtfDHhVa1Jexw+Az1BDWfa67ZKxEmLTf9jKQqzFa2SePVi6m/WLJSXxio6aDI5TEmwivt6Z3876xa7ZXv44am4J08ZH2Q6vZcJ4K8153mABVP39tyT9ML58Qyqtqt0eng0levziPLbkhaMsZfhmRY4XKcMzf2f659h+YmHQyvT2o2QijkKYJifkPt1zQgfDrmcZrfeRD3mFnwHdUO/9cpCamXx5SfINDw0kw6X3g5grwxJCiD7MJnMm+49xUAOXt7CQGVRmrTkmpBe2m6U6ywZCdCurI+AzC45mAmeIzI0GVgDe2dm95tNUamNbmhGNoa99X5TDsy+CMV5r9mXwiPLDWin5NXYLfSQiqIEDssj9MdB5DfQ34QqEBm6Yo1s4MKpElYcld7BNgWpL3NSk/bTORxUnw3IUmWkUQF59TBcJEtC/naEVEodvfHWDpDWbUZjPaKgB8pfl3KpzU/BXmrlIAFDokqcwwLbWipUpKMYuLIiejxYHQueVm0/lRWGQi7d0+FRRwxX7f2hiyH4VOhLIEPxWnu+fPZg2Tv3NM9WdnrIz3XFlQUUK4GYxRE3eQVUergPH2xXtGNbXKFtbYgfZp7tlVWot84UZcs1+g0IoCUfPB9DFc0yB3L92p6cxmyLkZYzdThw8FXEIW8pNeEcGy4K3z29UoGrFNYlVyqshjaYvdvGmiQxueiQQjoIn70Off9qfzqOj078rLUxt0GqJFLYTIpZkIOvyC8xXkEUzW29fAMw1RVHV2j+NhCVt3zdDt4zXE6x4IyQDsOJt/F2MWrWjSTd7CXKRVQrqNuy/r2YxKvDh73SVDScFake7c2wqcDLsitk62cpXy8xQE8m4XcXN7OnENPz6UNZqszo+/wQAZAcWCaT0Sq58J2SCcPR/elae1E4KTTWptLYnUeLkUOWQzPBK49O+wxt4yiraZze8rYTdjC+7EJp9w3ea9AL5A2bh8qYxA2sj+g2oTZrvchOQ0fMOq2UYbfSDZXEg2iLDtIVNGLPaOdVQku0kdcEGUcpy8WtKPooOkxnEBXpto5Wx0675vYllbaFSKi3dMwGA7ggveyun0mUjdBkeDcKtxz3pRvgnP8qsNkeS3O8z6AsozS54CJa6tpxWsWTImT1isy34PyjX7auN0IC3pfZ0Dadje9J/bhobmGDArQvmqi9A9UgWmLNZiKYuFm/y6M3C8zuwd8YPiR04tLQKuHO5lvg8lHseMOuCX365UYZZrFN6mHFwTb8qPcsUfbLW8Rnq3uiJd8DCw/dydsZjtqMDiHlHTYQoK1/4GFH3T2s8NRjRctCv1xH9kyP1+okhqze6ZVGuBmwpSIZhq3oLeJueJt6yYHuT7erklNOQV5/iIbts/A8ycg1ymeVoRrru65J1SL9JJI0/liLd5Jh7eumsuKKV96Y9+MIRcUucvbwVlmbbtJwo38AyJG46DJUKj9BlFygjs+f67iKwEWQtKUAlxYfe69mdPL0mv4bHRUC+LcfY+hKlJMFkFYKGaMNPXVWPyA3QUVDhlmrkS5xFnvKphd+TFA+J/LeY/zTjh/BhPq4gE5pedeNIqUBWM6aDniP1eTRR/fKvAHWIXSePjsrQB1uMTFr8tEWrzjTxVz0tOZeR2knKpY3+nviZhjoYL+shyhZq90NfxrAsymTqkAS18Aly6poYU8paLFbOO3FHEaYeF4RzA5falkTl9j7ZpLgRDCGW6M4k0RmewnrB5NANgWGPLsypu0QO9931HScOqJhy38TU2deBLo4AXMuItaM2mW8ifNbSikPw/WPsgT0F8Wc6K224rUuvXCoy2r1HqSSPlQMymc6CzYffWvtzKNH7KUYKU/q2pHWB/2YaZVKXfW9Vhjdj+bKMEt3z2vye7Bf8hgW1ljL2OxG2PpgzIDsamUuvTpIH38f7ukNqdlX02xyS11IywsSD8uW+7uvmcFCiBrywvXIvZ4fCw8RKXSCarfeJXWnhGj7t55ZxJpDMhXgXwxRl5EzwV4YcRc1HZkt0xxZZhuYzoXJ+wuERrMvvJIeKpOLz86uWcEKUg2N6DZqzrtc/nlbzAqAyV7A5uicNVCBFI2z/Jgsw/h5wh8j+tNKvuvTKoXq0Vf0lzWiLMdXQwbF08+LEUChnBkgmMLc8zp+vS9nn3bMUzy/5iJ8654unwzA/2m4KzmHtMvy3Ufx/6bNOFTlEo3m0lioQycOMzQxNP2mrYBKeiipfGJnoODKsxAMFFuZr7XmmjY/Z+JLf7tVjipe48CROxj6FDLW1LEOl+n4CMi3lBOieJcSR4r/yzsCVkNTndJ7ANRH6EEAVrTBS7uYxn9LuVL2rZ2p+W/IyYYgRI5yvJ63PZ9CrQuMgy58kVgBCZpohV61AVl5hv1qKX0dw==]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5笔记]]></title>
    <url>%2F2019%2F05%2F19%2FHTML5%2F</url>
    <content type="text"><![CDATA[HEADmeta标记meta标记用来描述网页，有利于搜索引擎快速找到网站并正确分类注意：对于中文网页需要使用 meta charset=”utf-8”声明编码，否则会出现乱码。有些浏览器(如 360 浏览器)会设置 GBK 为默认编码，则你需要设置为meta charset=”gbk”SEO（Search Engine Optimization）搜索引擎优化开发后上线=》发布=》用户就可以找到你的网站（网址、去搜索）记得网站要去做收录（各大搜索网站收录的地址）收录后，搜索引擎（蜘蛛程序）去爬你的网站目的：记录你的网页内容：title标签、alt、title属性、keywords、descriptionSTYLE / CSS选择器七种选择器ID 选择器， 如 #id{}类选择器， 如 .class{}属性选择器， 如 a[href=”segmentfault.com”]{}伪类选择器， 如 :hover{}伪元素选择器， 如 ::before{}标签选择器， 如 span{}通配选择器， 如 *{}关系选择符E F：包含选择符选择所有被E元素包含的F元素E&gt;F：子选择符选择所有作为E元素的子元素FE+F：相邻选择符选择紧贴在E元素之后的F元素E~F：兄弟选择符选择E元素所有兄弟元素F伪类选择符常用：hover设置元素在其鼠标悬停时的样式。：active设置元素在被用户激活(在鼠标点击与释放之间发生的事件)时的样式：focus设置元素在成为输入焦点(该元素的onfocus事件发生)时的样式E：not（s)匹配不含有s选择符的元素E：first-child匹配第一个子元素：last-child匹配最后一个子元素：nth-child（n）匹配第n个子元素选择器示例示例说明:checkedinput:checked选择所有选中的表单元素:disabledinput:disabled选择所有禁用的表单元素:emptyp:empty选择所有没有子元素的p元素:enabledinput:enabled选择所有启用的表单元素:first-of-typep:first-of-type选择的每个 p 元素是其父元素的第一个 p 元素:in-rangeinput:in-range选择元素指定范围内的值:invalidinput:invalid选择所有无效的元素:last-childp:last-child选择所有p元素的最后一个子元素:last-of-typep:last-of-type选择每个p元素是其母元素的最后一个p元素:not(selector):not(p)选择所有p以外的元素:nth-child(n)p:nth-child(2)选择所有 p 元素的父元素的第二个子元素:nth-last-child(n)p:nth-last-child(2)选择所有p元素倒数的第二个子元素:nth-last-of-type(n)p:nth-last-of-type(2)选择所有p元素倒数的第二个为p的子元素:nth-of-type(n)p:nth-of-type(2)选择所有p元素第二个为p的子元素:only-of-typep:only-of-type选择所有仅有一个子元素为p的元素:only-childp:only-child选择所有仅有一个子元素的p元素:optionalinput:optional选择没有”required”的元素属性:out-of-rangeinput:out-of-range选择指定范围以外的值的元素属性:read-onlyinput:read-only选择只读属性的元素属性:read-writeinput:read-write选择没有只读属性的元素属性:requiredinput:required选择有”required”属性指定的元素属性:rootroot选择文档的根元素:target#news:target选择当前活动#news元素(点击URL包含锚的名字):validinput:valid选择所有有效值的属性:linka:link选择所有未访问链接:visiteda:visited选择所有访问过的链接:activea:active选择正在活动链接:hovera:hover把鼠标放在链接上的状态:focusinput:focus选择元素输入后具有焦点:first-letterp:first-letter选择每个&lt;p 元素的第一个字母:first-linep:first-line选择每个&lt;p 元素的第一行:first-childp:first-child选择器匹配属于任意元素的第一个子元素的 p&gt; 元素:beforep:before在每个&lt;p元素之前插入内容:afterp:after在每个&lt;p元素之后插入内容:lang(language)p:lang(it)为&lt;p元素的lang属性选择一个开始值属性选择符E[att]选择具有att属性的E元素E[att=”val”]选择具有att属性且属性值等于val的E元素E[att~=”val”]选择具有att属性且属性值为一用空格分隔的字词列表，其中一个等于val的E元素E[att^=”val”]选择具有att属性且属性值为以val开头的字符串的E元素E[att$=”val”]选择具有att属性且属性值为以val结尾的字符串的E元素E[att*=”val”]选择具有att属性且属性值为包含val的字符串的E元素E[att|=”val”]选择具有att属性且属性值为以val开头并用连接符”-“分隔的字符串的E元素伪对象选择符E:first-letter/E::first-letter设置对象内的第一个字符的样式E:first-line/E::first-line设置对象内的第一行的样式E:before/E::before设置在对象前（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用E:after/E::after设置在对象后（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用E::placeholder设置对象文字占位符的样式E::selection设置对象被选择时的颜色tipsCSS选择器的使用，应该尽量避免使用 !important 和 内联样式；id通常也是与class区分开使用，前者多用于JS中的结点定位，后者多用于CSS选择器。color尽量使用16进制或RGBA字体：垂直居中：lineheight与height相等vertical-align:middle;文本居中（img未转换成块元素前同样适用）：text-align: center优先级规则：就近原则行内引用 &gt; 页内引用 &gt; 页外引用CSS 优先规则1： 最近的祖先样式比其他祖先样式优先级高。123456&lt;!-- 类名为 son 的 div 的 color 为 blue --&gt;&lt;div style="color: red"&gt; &lt;div style="color: blue"&gt; &lt;div class="son"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;CSS 优先规则2：“直接样式”比”祖先样式”优先级高。1234&lt;!-- 类名为 son 的 div 的 color 为 blue --&gt;&lt;div style="color: red"&gt; &lt;div class="son" style="color: blue"&gt;&lt;/div&gt;&lt;/div&gt;CSS 优先规则3：优先级关系：内联样式 &gt; ID 选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素选择器CSS 优先规则4：计算选择符中 ID 选择器的个数（a），计算选择符中类选择器、属性选择器以及伪类选择器的个数之和（b），计算选择符中标签选择器和伪元素选择器的个数之和（c）。按 a、b、c 的顺序依次比较大小，大的则优先级高，相等则比较下一个。若最后两个的选择符中 a、b、c 都相等，则按照”就近原则”来判断。CSS 优先规则5：属性后插有 !important 的属性拥有最高优先级。若同时插有 !important，则再利用规则 3、4 判断优先级! important （特殊情况使用）!important是CSS1就定义的语法，作用是提高指定样式规则的应用优先权。语法格式{ cssRule !important }，即写在定义的最后面，例如：p{color:red !important;}p{color:blue}tips错误的说法在学习过程中，你可能发现给选择器加权值的说法，即 ID 选择器权值为 100，类选择器权值为 10，标签选择器权值为 1，当一个选择器由多个 ID 选择器、类选择器或标签选择器组成时，则将所有权值相加，然后再比较权值。这种说法其实是有问题的。比如一个由 11 个类选择器组成的选择器和一个由 1 个 ID 选择器组成的选择器指向同一个标签，按理说 110 &gt; 100，应该应用前者的样式，然而事实是应用后者的样式。错误的原因是：选择器的权值不能进位。还是拿刚刚的例子说明。11 个类选择器组成的选择器的总权值为 110，但因为 11 个均为类选择器，所以其实总权值最多不能超过 100， 你可以理解为 99.99，所以最终应用后者样式。CSS 选择符组合方式：后代选择符： .father .child{}子选择符： .father &gt; .child{}相邻选择符: .bro1 + .bro2{}样式被应用的位置越在下面则优先级越高清除CSS中select的下拉箭头样式1234567891011121314151617181920select &#123;/*Chrome和Firefox里面的边框是不一样的，所以复写了一下*/border: solid 1px #000;/*很关键：将默认的select选择框样式清除*/appearance:none;-moz-appearance:none;-webkit-appearance:none;/*在选择框的最右侧中间显示小箭头图片*/background: url("http://ourjs.github.io/static/2015/arrow.png") no-repeat scroll right center transparent;/*为下拉小箭头留出一点位置，避免被文字覆盖*/padding-right: 14px;&#125;/*清除ie的默认选择框样式清除，隐藏下拉箭头*/select::-ms-expand &#123; display: none; &#125;other在布局上面，一开始就要设置的，主要目的去除/初始化所有标签的样式123456*&#123; margin: 0; /*去除默认的外边距*/ padding: 0; /*去除默认的内边距*/ font-size: 14px; /*统一字体大小*/ font-weight: normal; /*都不加粗*/ &#125;id名，一般不用来加样式，一般是用于js添加动态效果id的优先级最高长图片定位12345.img&#123; background:url(1.png) 0 0 no-repeat; width:25px; height:25px;&#125;布局display（元素显示模式）block块对象指的是元素显示为一个方块，默认显示状态下将占据整行，其它的元素只能另起一行显示inline行间对象与block刚好相反，它允许其它元素在同一行显示none隐藏对象inline-blockfloat（元素的浮动）none不浮动right向右浮动left向左浮动浮动的时候元素的显示属性也变化了变为 “行内元素”clear（清除浮动）none默认值允许两两边都可以有浮动对象left不允许左边有浮动对象right不允许右边有浮动对象both不允许有浮动对象position（元素的定位）static无定位默认值absolute绝对定位tips：脱离文档流。通过 top,bottom,left,right 定位。如果父元素 position 为 static 时，将以body坐标原点进行定位。如果父元素 position 为 relative 时，将以父元素进行定位。relative相对定位tips：相对定位（相对自己原来的位置而言）不脱离文档流参考自身静态位置通过 top,bottom,left,right 定位。fixed固定定位tips固定定位实际上只是绝对定位的特殊形式；固定定位的元素是相对于浏览器窗口而固定，而不是相对于其包含元素；即使页面滚动了，它们仍然会处在浏览器窗口中跟原来完全一样的地方。z-index（元素的层叠关系）autonumberreset.css1234567891011121314151617181920212223body,p,ul,ol,li,dl,dt,dd,h1,h2,h3,h4,h5,h6,form,fieldset,legend,input,select,textarea,button,th,td,menu&#123;margin:0;padding:0;&#125;ul,dl,ol&#123;list-style:none;&#125;img,fieldset,input[type="submit"]&#123;border:0 none;&#125;em&#123;font-style:normal;&#125;strong&#123;font-weight:normal;&#125;table&#123;border-collapse:collapse;border-spacing:0;&#125;button,input[type="button"]&#123;cursor:pointer;border:0 none;&#125;a,button,input,img&#123;-webkit-touch-callout:none;&#125;img&#123;pointer-events:none;/*禁止图片的点击事件，例如长按保存图片*/&#125;input,select,textarea&#123;outline:none;&#125;a&#123;text-decoration:none;&#125;.fl&#123; float: left&#125;.fr&#123; float: right&#125;.clear&#123;clear:both;&#125; html,body&#123;/*禁止用户选择元素*/-moz-user-select:none; -webkit-user-select: none;-ms-user-select: none; -khtml-user-select:none; /*禁止元素点击出现半透明黑色背景*/ -webkit-tap-highlight-color:rgba(0, 0, 0, 0); &#125;html &#123;height: 100%;width: 100%;font-family: 'Heiti SC', 'Microsoft YaHei';outline: 0;-webkit-text-size-adjust:none;&#125;body &#123;height: 100%;margin: 0;position: relative;&#125;BODY常见语义标记123456789101112131415161718192021222324252627282930313233&lt;article&gt; &lt;header&gt; &lt;h1&gt;文章标题&lt;/h1&gt; &lt;p&gt;发表时间：1999-01-01 &lt;span&gt;作者：佚名&lt;/span&gt;&lt;/p&gt;&lt;/header&gt; &lt;nav&gt; &lt;a href="#"&gt;HTML&lt;/a&gt; | &lt;a href="#"&gt;CSS&lt;/a&gt; | &lt;a href="#"&gt;JavaScript&lt;/a&gt; &lt;/nav&gt;&lt;p&gt;正文...&lt;/p&gt; &lt;section&gt; &lt;h1&gt;稻草&lt;/h1&gt; &lt;p&gt;夏日的夕阳，激起了小溪的热情，染红了乡间的田野。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;今天我们去星光电影城看了场电影&lt;/p&gt; &lt;aside&gt; &lt;h4&gt;星光电影城&lt;/h4&gt; &lt;p&gt;星光电影城是市内最大的电影城，里面不仅有舒服的观影体验，还有大量的娱乐设施，美食等...&lt;/p&gt; &lt;/aside&gt;&lt;footer&gt; &lt;p&gt;Posted by: hello world&lt;/p&gt; &lt;p&gt;&lt;time pubdate datetime="2012-03-01"&gt;&lt;/time&gt;&lt;/p&gt; &lt;/footer&gt;&lt;/article&gt;标记说明header显示网站名称、主题或者主要信息nav网站的连接菜单aside用于侧边栏article用于定义主内容区section用于章节或段落footer位于页脚，用来放置版权声明、作者等信息figure独立的流内容（图像、图表、照片、代码等等）内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。figcaption定义 figure&gt;元素的标题.应该被置于 “figure”元素的第一个或最后一个子元素的位置div：容器标签span：区块标签embed：定义了一个容器，用来嵌入外部应用或者互动程序（插件）width、height：宽高type：规定嵌入内容的MIME 类型，如视频，外部应用值：MIME_typesrc：URL1&lt;embed src="flash.swf" &gt;base：为页面上的所有链接规定默认地址或默认目标base&gt; 标签必须位于 head&gt; 元素内部base&gt;标签是空标签，没有结束标签，XHTML中要求正确关闭 /&gt;123456789&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;base href="//www.runoob.com/images/"&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; &lt;img src="logo.png"&gt; - 注意这里我们设置了图片的相对地址。能正常显示是因为我们在 head 部分设置了 base 标签，该标签指定了页面上所有链接的默认 URL，所以该图片的访问地址为 "http://www.runoob.com/images/logo.png" &lt;/p&gt;bdo：改变文字方向属性ltr：left to right ：→rtl：right to left ：←1&lt;bdo dir=“rtl”&gt;文本将改变文本方向&lt;/bdo&gt;canvas：图形的绘制通过脚本（通常是JS）来完成canvas&gt; 标签只是图形容器，您必须使用脚本来绘制图形默认情况下 canvas元素没有边框和内容，使用 style 属性来添加边框1&lt;canvas id=“id名” width=“200” height=“100” style="border:1px solid #000;"&gt;&lt;/canvas&gt;12345678&lt;tbody&gt; 标签表格主体（正文）。该标签用于组合 HTML 表格的主体内容。tbody 元素应该与 thead 和 tfoot 元素结合起来使用。thead 元素用于对 HTML 表格中的表头内容进行分组，而 tfoot 元素用于对 HTML 表格中的表注（页脚）内容进行分组。注释：如果您使用 thead、tfoot 以及 tbody 元素，您就必须使用全部的元素。它们的出现次序是：thead、tfoot、tbody，这样浏览器就可以在收到所有数据前呈现页脚了。您必须在 table 元素内部使用这些标签。提示：在默认情况下这些元素不会影响到表格的布局。不过，您可以使用 CSS 使这些元素改变表格的外观。详细描述thead、tfoot 以及 tbody 元素使您有能力对表格中的行进行分组。当您创建某个表格时，您也许希望拥有一个标题行，一些带有数据的行，以及位于底部的一个总计行。这种划分使浏览器有能力支持独立于表格标题和页脚的表格正文滚动。当长的表格被打印时，表格的表头和页脚可被打印在包含表格数据的每张页面上。注释：&lt;thead&gt; 内部必须拥有 &lt;tr&gt; 标签！标记换行1&lt;br&gt;分割线1&lt;hr&gt;让文字按原始代码的排列方式进行显示1&lt;pre&gt;&lt;/pre&gt;表示引用文字，会将标记内的文字换行并缩进1&lt;blockquote&gt;&lt;/blockquote&gt;特殊符号表示&copy; // &amp;copy+;&lt; // &amp;lt+;&gt; // &amp;gt+;&amp; // &amp;amp+;“ // &amp;quot+;&reg; // &amp;reg+;不换行空格 // &amp;nbsp+;半角空格 // &amp;ensp；全角空格 // &amp;emsp；窄空格 // &amp;thinsp；6/1a：链接1234a&#123; text-decoration：none; /*去除下划线*/ text-decoration：underline;/*添加下划线*/&#125;说明：href：定义链接地址title：链接提示信息target：链接打开方式锚点标签用于使用户”跳”到文档的某个部分。a href=”#位置名”&gt;&lt;/aa name=”位置名”&gt;&lt;/a提示：如果没有使用 href 属性，则不能使用 hreflang、media、rel、target 以及 type 属性提示：通常在当前浏览器窗口中显示被链接页面，除非规定了其他 target提示：请使用 CSS 来改变链接的样式img：图像转换为块元素：123img&#123; display: block;&#125;说明：src：定义图像的urlalt：定义图像的替代文本（即图像提示信息）width：设置图像的宽度height：设置图像的高度图像热区1234&lt;img src=&quot;URL&quot; usemap=&quot;# map名称&quot; /&gt;&lt;map name=&quot;map名称&quot;&gt; &lt;area shape=&quot;形状&quot; coords=&quot;坐标值&quot; href=&quot;URL&quot; /&gt;&lt;/map&gt;矩形：(左上角顶点坐标为(x1,y1)，右下角顶点坐标为(x2,y2))1&lt;area shape="rect" coords="x1,y1,x2,y2" href=url&gt;圆形：(圆心坐标为(X1,y1)，半径为r)1&lt;area shape="circle" coords="x1,y1,r" href=url&gt;多边形：(各顶点坐标依次为(x1,y1)、(x2,y2)、(x3,y3) ……)1&lt;area shape="poly" coords="x1,y1,x2,y2 ......" href=url&gt;float：浮动| 值 | 描述 || :—–: | :————————————————–: || left | 元素向左浮动。 || right | 元素向右浮动。 || none | 默认值。元素不浮动，并会显示在其在文本中出现的位置。 || inherit | 规定应该从父元素继承 float 属性的值 |dl：定义列表123456&lt;dl&gt; &lt;dt&gt;计算机&lt;/dt&gt; &lt;dd&gt;用来计算的仪器 ... ...&lt;/dd&gt; &lt;dt&gt;显示器&lt;/dt&gt; &lt;dd&gt;以视觉方式显示信息的装置 ... ...&lt;/dd&gt;&lt;/dl&gt;类似ulul：无序列表1234ul,dl&#123; float: left; /*左浮动：从左到右并排显示*/ list-style: none;/*去小圆圈*/&#125;属性：Typedisc：实心圆（默认）circle：空心圆square：实心方框reversed：倒序ol：有序列表start：排序的起点数值type：用来设置项目前面的标记1：数字（默认）a：小写字母A：大写字母i：小写希腊字母I：大写希腊字母Audio、Video：媒体12345&lt;audio width="320" height="240" controls="controls"&gt; &lt;source src="song.ogg" type="audio/ogg"&gt; &lt;source src="song.mp3" type="audio/mpeg"&gt; 你的浏览器不支持&lt;audio&gt;标签&lt;/audio &gt;音频属性autoplay：自动播放loop：循环播放controls：显示控件preload：预加载（若使用autoplay属性则自动忽略）视频属性同上muted：规定视频的音频输出应该被静音poster[URL]：规定视频未播放时的图像src[URL]：视频链接width &amp; height：宽高table：表格tr（行）、th（表头）、td（单元）、caption（标题）th 所标识的单元格文字会以粗体显示，通常当做表格第一行的标题说明：width、height：宽高border：边框宽度cellpadding：单元内边距cellmargin：单元外边距align：水平leftrightcentervalign：垂直topmiddlebottomcolspan：合并左右列rowspan：合并上下行让单元格文字不换行 nowrap 例：【td nowrap】遇到空白单元格时的处理方式：在其中输入全角空格（&amp;emsp；）或（&amp;nbsp；）即可解决高度=行高，文字会垂直居中图片默认根据宽度对表格进行调整，故时而其下会有间隙，遇此情况IMG CSS : display : block // 将图片改成块元素IMG CSS : display : flex // 弹性布局float : left // 浮动HTML背景设置背景颜色 body bgcolor=”#000000”&gt;设置背景图片 body background=”bg.jpg”&gt;设置页面文字颜色 body text=”#cccccc”&gt;尽量使用十六进制以及RGBA或RGB，利于浏览器渲染背景图CSS设置：12345678910111213141516body &#123; /* 图片地址 */ background-image: url(09.jpg); /* 图片按屏幕大小显示 */ background-size: cover; /* 指定一个固定的背景图片 */ background-attachment: fixed; /* 图片不重复 */ background-repeat: no-repeat; /* 图片显示位置水平居中垂直居中 */ background-position: center center; &#125;iframe内嵌框架1&lt;iframe src="xxx.html" frameborder="0" id="iframe"说明：scrolling：是否显示滚动条yesnoautoframeborder：是否显示边框10样式123456iframe &#123; position: fixed; /*固定定位*/ right: 0; bottom: 0; &#125;JavaScript12345678910111213141516171819202122232425scrolling="no"&gt;&lt;/iframe&gt; &lt;script language="javascript"&gt; var timeIframe; window.onload = function () &#123; timeIframe = setTimeout(GetIframeStatus, 10); &#125; function GetIframeStatus() &#123; var iframe = document.getElementById("iframe"); var iframeWindow = iframe.contentWindow; //内容是否加载完 if (iframeWindow.document.readyState == "complete") &#123; var iframeWidth, iframeHeight; //获取Iframe的内容实际宽度 iframeWidth = iframeWindow.document.documentElement.scrollWidth; //获取Iframe的内容实际高度 iframeHeight = iframeWindow.document.documentElement.scrollHeight; //设置Iframe的宽度 iframe.width = iframeWidth; //设置Iframe的高度 iframe.height = iframeHeight; &#125; else &#123; timeIframe = setTimeout(GetIframeStatus, 10); &#125; &#125; &lt;/script&gt;form表单1234&lt;form name="form1" action="URL" method="get"&gt; 用户名：&lt;input type="text" name="uname" /&gt; 密 码：&lt;input type="password" name="passwd" /&gt;&lt;/form&gt;method（设置发送数据的方式）：post 和 get使用get方式发送数据，数据会直接加载URL之后，安全性比较差，并且有255个字符的字数限制post方式是将数据封装之后再发送，字符串长度没有限制，数据安全性比较高。对于需要保密的信息，通常会采用post方式进行发送action表单提交地址enctype：MIME方式MIME：Multipurpose Internet Mail Extensions多用途互联网邮件扩展类型表单发送的编码方式，只有method=“post”时才有效enctype=”application/x-www-form-urlencoded”：此为默认值，若enctype省略不写，则表示采取此种编码模式enctype=”multipart/form-data”：用于上传文件的时候enctype=”text/plain”：将表单属性发送到电子邮箱时，enctype的值必须设为”text/plain”,否则将会出现乱码marquee：滚动内容（过时）marquee元素已经 过时，请不要再使用。尽管一些浏览器仍然支持它，但它不是必须的。此外，使用这个元素基本上是你可以对你的用户做最糟糕的事情之一，所以请不要这样做。direction ：滚动的方向left（默认）rightupdownbehavior ：滚动的方式scroll：连续滚动slide：滑动一次alternate：来回滚动loop ：循环的次数正整数默认为无限循环scrollamount ：运动速度正整数，默认为6scrolldelay ：停顿时间正整数，默认为0，单位是毫秒align ：元素的垂直对齐方式topmiddle（默认）bottombgcolor ：运动区域的背景色16进制的RGB颜色，默认为白色height、width：运动区域的高度和宽度正整数(单位是像素)百分数默认：width=100% height为标签内元素的高度。hspace、vspace ：元素到区域边界的水平距离和垂直距离正整数，单位是像素。onmouseover=this.stop() onmouseout=this.start() ：当鼠标以上区域的时候滚动停止，当鼠标移开的时候又继续滚动。target（打开方式）_blank：打开新窗口_self ：当前的窗口_parent：上一层窗口（父窗口）_top：最上层窗口框架名称：直接指定窗口或框架名称novalidate：规定当提交表单时不对表单数据（输入）进行验证。1234&lt;form action="demo_form.html" novalidate&gt;E-mail: &lt;input type="email" name="user_email"&gt; &lt;input type="submit"&gt;&lt;/form&gt;autocomplete：规定表单是否应该启用自动完成功能。on：浏览器会基于用户之前键入的值自动完成值。off：用户必须在每次使用时输入值到每个字段中，浏览器不会自动完成输入。input：输入框说明placeholder：显示在输入框的内容readonly：是否只读maxlength：输入字符的最大长度disabled：是否禁用value：输入框中填入的值checkbox ：复选框此时name属性应为xxx [ ]selected ：下拉框默认选中datalist：规定了 input&gt; 元素可能的选项列表。12345678&lt;input list="browsers"&gt; &lt;datalist id="browsers"&gt; &lt;option value="Internet Explorer"&gt; &lt;option value="Firefox"&gt; &lt;option value="Chrome"&gt; &lt;option value="Opera"&gt; &lt;option value="Safari"&gt; &lt;/datalist&gt;提供”自动完成”的特性。用户能看到一个下拉列表，里边的选项是预先定义好的，将作为用户的输入数据。使用 input&gt; 元素的 list 属性来绑定 datalist&gt; 元素。output：作为计算结果输出显示(比如执行脚本的输出)。123456789&lt;form oninput="x.value=parseInt(a.value)+parseInt(b.value)"&gt; 0 &lt;input type="range" id="a" value="50"&gt; 100+ &lt;input type="number" id="b" value="50"&gt; = &lt;output name="x" for="a b"&gt;&lt;/output&gt;&lt;/form&gt;hiddenhidden 属性规定对元素进行隐藏。隐藏的元素不会被显示。如果使用该属性，则会隐藏元素。可以对 hidden 属性进行设置，使用户在满足某些条件时才能看到某个元素（比如选中复选框，等等）。然后，可使用 JavaScript 来删除 hidden 属性，使该元素变得可见。radio：单选name必须相同label：将输入项或选项及其标签文字关联起来使单选文字部分也具有点击效果12345678&lt;p&gt; &lt;!-- 状态的属性，写个名字就可以了 autoplay loop checked选中 required必填--&gt;单选按钮： &lt;input type="radio" name="sex" value="男" id="nan"&gt; &lt;label for="nan"&gt;男生&lt;/label&gt; &lt;input type="radio" name="sex" value="女" checked id="nv"&gt;&lt;label for="nv"&gt;女生&lt;/label&gt;&lt;/p&gt;autocomplete用来设置input组件是否使用自动完成功能onoff自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。适用于 form&gt;，以及下面的 input&gt; 类型：text, search, url, telephone, email, password, datepickers, range 以及 colorautofocus：当页面加载时 input&gt; 元素应该自动获得焦点12345678&lt;form action="demo_form.html"&gt; First name: &lt;input type="text" name="fname" autofocus&gt; &lt;br&gt; Last name: &lt;input type="text" name="lname"&gt;&lt;br&gt; &lt;input type="submit"&gt;&lt;/form&gt;form：input&gt; 元素所属的一个或多个表单。123456789101112131415&lt;form action="demo-form.php" id="form1"&gt; First name: &lt;input type="text" name="fname"&gt; &lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;p&gt; "Last name" 字段没有在 form 表单之内， 但它也是 form 表单的一部分。&lt;/p&gt;Last name: &lt;input type="text" name="lname" form="form1"&gt;&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; IE 不支持 form 属性&lt;/p&gt;required ：必须在提交之前填写输入域（不能为空）。12345678&lt;form action="" method="post" enctype="" &gt; &lt;label for="user"&gt;用户名：&lt;/label&gt; &lt;input type="text" name="user" id="user" required&gt; &lt;br&gt; &lt;label for="password"&gt;密 码：&lt;/label&gt; &lt;input type="password" name="password" id="password" &gt; &lt;input type="submit" name="" value="提交"&gt;&lt;/form&gt;checked：状态属性默认选中accept：用于指定文件类型1accept=&quot;.jpg,.jpeg,.png,.gif&quot;file：文件上传1&lt;input type="file" name="pic2" accept="image/*"&gt;multiple：控制是否上传多文件number // 数字输入框max - 规定允许的最大值。min - 规定允许的最小值。step - 规定合法数字间隔。value - 规定默认值。去除输入框得到焦点时，浏览器出现的蓝色带阴影的边框1234567input&#123; outline: 0;&#125; OR input&#123; focus:outline: none;&#125;enctype=”multipart/form-data”指表单数据有多部分构成，既有文本数据，又有文件等二进制数据默认情况下，enctype的值是application/x-www-form-urlencoded，不能用于文件上传，只有使用了multipart/form-data，才能完整的传递文件数据。application/x-www-form-urlencoded不是不能上传文件，是只能上传文本格式的文件，multipart/form-data是将文件以二进制的形式上传，这样可以实现多种类型的文件上传。值描述button定义可点击的按钮（通常与 JavaScript 一起使用来启动脚本）checkbox定义复选框file定义文件选择字段和 “浏览…” 按钮，供文件上传hidden定义隐藏输入字段image定义图像作为提交按钮password定义密码字段（字段中的字符会被遮蔽）radio定义单选按钮reset定义重置按钮（重置所有的表单值为默认值）submit定义提交按钮text默认。定义一个单行的文本字段（默认宽度为 20 个字符）color(以下为H5新增)定义拾色器date定义 date 控件（包括年、月、日，不包括时间）datetime定义 date 和 time 控件（包括年、月、日、时、分、秒、几分之一秒，基于 UTC 时区）datetime-local定义 date 和 time 控件（包括年、月、日、时、分、秒、几分之一秒，不带时区）email定义用于 e-mail 地址的字段month定义 month 和 year 控件（不带时区）number定义用于输入数字的字段range定义用于精确值不重要的输入数字的控件（比如 slider 控件）search定义用于输入搜索字符串的文本字段tel定义用于输入电话号码的字段time定义用于输入时间的控件（不带时区）url定义用于输入 URL 的字段week定义 week 和 year 控件（不带时区）textarea：定义一个多行的文本输入控件123&lt;textarea rows="10" cols="30"&gt;我是一个文本框。&lt;/textarea&gt;说明autofocus：当页面加载时，文本区域自动获得焦点。cols：文本区域内可见的宽度。值：数字disabled：禁用文本区域。form：文本区域所属的一个或多个表单。123456789101112131415&lt;form action="demo-form.php" id="usrform"&gt; Name: &lt;input type="text" name="usrname"&gt; &lt;input type="submit"&gt;&lt;/form&gt;&lt;br&gt;&lt;textarea rows="4" cols="50" name="comment" form="usrform"&gt;输入内容...&lt;/textarea&gt;&lt;p&gt; 以上的表单在文本框之外，但是它仍是表单中的一部分。&lt;/p&gt;&lt;p&gt; &lt;b&gt;注意：&lt;/b&gt; IE 不支持 form 属性。&lt;/p&gt;maxlength：文本区域允许的最大字符数。值：数字name：文本区域的名称placeholder：提示readonly：规定文本区域为只读。required：规定文本区域是必需的/必填的。rows：规定文本区域内可见的行数。值：数字wrap：当提交表单时，文本区域中的文本应该怎样换行。soft：文本不换行（默认）hard：文本换行（包含换行符）。当使用 “hard” 时，必须指定 cols 属性。select：下拉框12345&lt;select name="city"&gt;&lt;option value="0"&gt;请选择&lt;/option&lt;option value="bj"&gt;北京&lt;/option&gt;&lt;option value="gz"&gt;广州&lt;/option&gt;&lt;/select&gt;说明：name：名称size：下拉框显示的行数multiple：是否多选disabled：是否禁用selected：是否默认选中value：选项的值optgroup：下拉框分组12345678910&lt;select name="city" multiple&gt; &lt;optgroup label="广东"&gt; &lt;option value="1"&gt;广州&lt;/option&gt; &lt;option value="2"&gt;深圳&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label="其他"&gt; &lt;option value="3"&gt;长沙&lt;/option&gt; &lt;option value="4"&gt;香港&lt;/option&gt; &lt;/optgroup&gt;&lt;/select&gt;居中行内元素：text-align：center；定宽块元素：margin：0 auto；居中的三个条件：必须是块元素(不可以是行元素)有明显的宽（width:xxpx）margin：0px auto；文本属性居中align:设置水平对齐方式（left/right/center/justify）valign:设置垂直对齐方式（top/middle/bottom）上面的不常用，下面的常用text-align:设置水平对齐方式left/right/center/justifyvertial-align:设置垂直对齐方式top/middle/bottom水平居中：给div设置一个宽度，然后添加margin:0 auto属性1234div&#123; width:200px; margin:0 auto; &#125;让绝对定位的div居中1234567891011div &#123; position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: bule; &#125;水平垂直居中确定容器的宽高 宽500 高 300 的层 设置元素的外边距1234567891011div &#123; position: relative; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; margin-top: -150px； margin-left: -250px; /* 外边距为自身宽高的一半 */ //margin:-150px 0 0 -250px; /*一样*/ background-color: blue; &#125;未知容器的宽高，利用 transform 属性123456789div &#123; position: absolute; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: blue; &#125;利用 flex 布局12345678910.container &#123; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ &#125; .container div &#123; width: 100px; height: 100px; background-color: blue; &#125;HTML 文本格式化标签标签描述b定义粗体文本em定义着重文本i定义斜体字small定义小号字strong定义加重语气（HTML5 推荐粗体）sub定义下标字sup定义上标字ins定义插入字del定义删除线粗体、斜体、下划线（最好使用CSS语法代替）em/strong/: 我们并不反对使用这个标签，但是如果您只是为了达到某种视觉效果而使用这个标签的话，我们建议您使用 CSS ，这样可能会取得更丰富的效果。small : small 标签定义小型文本（和旁注）。del和ins : &lt;del 和 &lt;ins 一起使用，描述文档中的更新和修正。浏览器通常会在已删除文本上添加一条删除线，在新插入文本下添加一条下划线HTML “计算机输出” 标签标签描述code定义计算机代码kbd定义键盘码samp定义计算机代码样本var定义变量pre定义预格式文本kdb : kbd 标签定义键盘文本。提示: kbd标签已废弃，不推荐使用，但 是可以通过CSS实现丰富的效果code : code标签是一个短语标签，用来定义计算机代码文本samp标签是一个短语标签，用来定义计算机程序的样本文本。var标签是一个短语标签，用来定义变量。abbr 标签用来表示一个缩写词或者首字母缩略词，如”WWW”或者”NATO”通过对缩写词语进行标记，您就能够为浏览器、拼写检查程序、翻译系统以及搜索引擎分度器提供有用的信息。samp/var : 我们并不反对使用这个标签，但是如果您只是为了达到某种视觉效果而使用这个标签的话，我们建议您使用 CSS ，这样可能会取得更丰富的效果。HTML 引文, 引用, 及标签定义标签描述abbr定义缩写address定义地址bdo定义文字方向blockquote定义长的引用q定义短的引用语cite定义引用、引证dfn定义一个定义项目。address标签定义文档作者/所有者的联系信息如果address元素位于 body元素内部，则它表示该文档作者/所有者的联系信息。如果 address元素位于 article 元素内部，则它表示该文章作者/所有者的联系信息。address 元素的文本通常呈现为斜体。大多数浏览器会在该元素的前后添加换行。提示：不应该使用 address 标签来描述邮政地址，除非这些信息是联系信息的组成部分。提示：address 元素通常被包含在footer元素的其他信息中。bdo 指的是 bidi 覆盖（Bi-Directional Override）。 [ ltr : left to right / rtl : right to left ]bdo标签用来覆盖默认的文本方向。bdo元素一般用于把一段文本的方向规定为与周围文本的自然方向相反的方向。方向由必需属性dir指定。bdo元素很少使用，只用于某些多语言文档。在这种文档中，可能有某一段文本使用的语言的阅读方式与文档中其他部分使用的语言的阅读方式不同。blockquote&gt; 标签定义摘自另一个源的块引用。浏览器通常会对 blockquote元素进行缩进。提示：如果标记是不需要段落分隔的短引用，请使用qq&gt; 标签定义一个短的引用。浏览器经常会在这种引用的周围插入引号。提示：请使用blockquote来标记摘自另一个源的块引用。cite&gt; 标签定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等等）的标题。注释：人名不属于作品的标题。dfn&gt; 标签是一个短语标签，用来定义一个定义项目。dfn : 我们并不反对使用这个标签，但是如果您只是为了达到某种视觉效果而使用这个标签的话，我们建议您使用 CSS ，这样可能会取得更丰富的效果。HTML元素分类：inline、inline-block、blockinlinetextarea、span、a、img、input、select行内元素特征：设置宽高无效对margin仅设置左右方向有效，上下无效；padding设置上下左右都有效，即会撑大空间,行内元素尺寸 由内含的内容决定，盒模型中 padding, border 与块级元素并无差异，都是标准的盒模型，但是 margin 却只有水平方向的值，垂直方向并没有起作用。行内元素的水平方向的padding-left,padding-right,margin- left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都 不会产生边距效果。padding设置上下左右都有效，即会撑大空间但是不会产生边距效果。不会自动进行换行元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。inline-block行内块状元素特征：不自动换行能够识别宽高默认排列方式为从左到右blockdiv、p、ul、h1等标题元素、ol、form、table块状元素特征：能够识别宽高margin和padding的上下左右均对其有效可以自动换行多个块状元素标签写在一起，默认排列方式为从上至下inline-block和float的区别文档流（Document flow）:浮动元素会脱离文档流，并使得周围元素环绕这个元素。而inline-block元素仍在文档流内。因此设置inline-block不需要清除浮动。当然，周围元素不会环绕这个元素，你也不可能通过清除inline-block就让一个元素跑到下面去。水平位置（Horizontal position）：很明显你不能通过给父元素设置text-align:center让浮动元素居中。事实上定位类属性设置到父元素上，均不会影响父元素内浮动的元素。但是父元素内元素如果设置了display：inline-block，则对父元素设置一些定位属性会影响到子元素。（这还是因为浮动元素脱离文档流的关系）。垂直对齐（Vertical alignment）：inline-block元素沿着默认的基线对齐。浮动元素紧贴顶部。你可以通过vertical属性设置这个默认基线，但对浮动元素这种方法就不行了。这也是我倾向于inline-block的主要原因。空白（Whitespace）：inline-block包含html空白节点。如果你的html中一系列元素每个元素之间都换行了，当你对这些元素设置inline-block时，这些元素之间就会出现空白。而浮动元素会忽略空白节点，互相紧贴.scrolling=”no”隐藏滚动条html很多标签都有默认样式，因此最好在样式中一开始就给表单标签去除默认的样式问题123&lt;style type="text/css"&gt; input,select,option,textarea&#123;outline: none;&#125;&lt;/style&gt;TIPS1&lt;body onload=&quot;init()&quot;&gt;//打开页面的同时调用initOTHER（应合理分类并及时归类）]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emmet]]></title>
    <url>%2F2019%2F05%2F19%2FEmmet%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[html缩写id（#）,class（.）id指令: #class指令: .div#test1&lt;div id="test"&gt;&lt;/div&gt;div.test1&lt;div class="test"&gt;&lt;/div&gt;子节点（&gt;），兄弟节点（+），上级节点（^）子节点指令: &gt;兄弟节点指令: +上级节点: ^div&gt;ul&gt;li&gt;p1234567&lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;div+ul+p123&lt;div&gt;&lt;/div&gt;&lt;ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;div&gt;ul&gt;li^div(这里的^是接在li后面所以在li的上一级，与ul成了兄弟关系,当然两个^^就是上上级）123456&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;重复（*）重复指令：*div5（号后面添加数字表示重复的元素个数）12345&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;分组（()）分组指令：()div&gt;(ul&gt;li&gt;a)+div&gt;p（括号里面的内容为一个代码块，表示与括号内部嵌套和外面的的层级无关）12345678&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;解释：这里如果不加括号的话，猜想下，a+div这样div就是和a是兄弟关系了，会包含在li里面。懂了吧哈哈123456789&lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=""&gt;&lt;/a&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul属性（[attr]）——id，class都有怎么能少了属性呢属性指令：[]a[href=’###’ name=‘xiaoA’]（中括号内填写属性键值对的形式，并且空格隔开）1&lt;a href="###" name="xiaoA"&gt;&lt;/a&gt;编号 $ul&gt;li.test$*3（$代表一位数，后面更上数字就代表从1递增到填写的数字）12345&lt;ul&gt; &lt;li class="test1"&gt;&lt;/li&gt; &lt;li class="test2"&gt;&lt;/li&gt; &lt;li class="test3"&gt;&lt;/li&gt;&lt;/ul&gt;注意：一个$ 代表一位数，如果想自定义从几开始递增的话就利用：$@+数字数字ul&gt;li.test$@3312345&lt;ul&gt; &lt;li class="test33"&gt;&lt;/li&gt; &lt;li class="test34"&gt;&lt;/li&gt; &lt;li class="test35"&gt;&lt;/li&gt;&lt;/ul&gt;文本（{}）文本指令：{}ul&gt;li.test$*3{测试$}（{里面填写内容，可以和$一起组合使用哦}）12345&lt;ul&gt; &lt;li class="test1"&gt;测试1&lt;/li&gt; &lt;li class="test2"&gt;测试2&lt;/li&gt; &lt;li class="test3"&gt;测试3&lt;/li&gt;&lt;/ul&gt;隐式标签这个标签没有指令，而是部分标签可以不使用输入标签，直接输入指令，即可识别父类标签。例如：.test1&lt;div class="test"&gt;&lt;/div&gt;ul&gt;.test$*312345&lt;ul&gt; &lt;li class="test1"&gt;&lt;/li&gt; &lt;li class="test2"&gt;&lt;/li&gt; &lt;li class="test3"&gt;&lt;/li&gt;&lt;/ul&gt;select&gt;.test$*51234567&lt;select name="" id=""&gt; &lt;option class="test1"&gt;&lt;/option&gt; &lt;option class="test2"&gt;&lt;/option&gt; &lt;option class="test3"&gt;&lt;/option&gt; &lt;option class="test4"&gt;&lt;/option&gt; &lt;option class="test5"&gt;&lt;/option&gt;&lt;/select&gt;等等…隐私标签有如下几个：li：用于 ul 和 ol 中tr：用于 table、tbody、thead 和 tfoot 中td：用于 tr 中option：用于 select 和 optgroup 中CSS缩写值比如要定义元素的宽度，只需输入w100，即可生成1width: 100px;width:30px==&gt;w30+tabHeight:30px==&gt;h30+tabMargin:30px==&gt;mg30+tabPadding:30px==&gt; pd30+tabLine-height:12px==&gt;lh12px+tabBackground==&gt;bg+tabBackground-color==&gt;bgc+tab除了px，也可以生成其他单位，比如输入h10p+m5e，结果如下：121. height: 10%; 2. margin: 5em;单位别名列表：p 表示%e 表示 emx 表示 ex附加属性可能你之前已经了解了一些缩写，比如 @f，可以生成：12341. @font-face &#123; 2. font-family:; 3. src:url(); 4. &#125;一些其他的属性，比如background-image、border-radius、font、@font-face,text-outline、text-shadow等额外的选项，可以通过“+”符号来生成，比如输入@f+，将生成：123456789101. @font-face &#123; 2. font-family: 'FontName'; 3. src: url('FileName.eot'); 4. src: url('FileName.eot?#iefix') format('embedded-opentype'), 5. ​ url('FileName.woff') format('woff'), 6. ​ url('FileName.ttf') format('truetype'), 7. ​ url('FileName.svg#FontName') format('svg'); 8. font-style: normal; 9. font-weight: normal; 10. &#125;模糊匹配如果有些缩写你拿不准，Emmet会根据你的输入内容匹配最接近的语法，比如输入ov:h、ov-h、ovh和oh，生成的代码是相同的：1overflow: hidden;供应商前缀如果输入非W3C标准的CSS属性，Emmet会自动加上供应商前缀，比如输入trs，则会生成：123451. -webkit-transform: ; 2. -moz-transform: ; 3. -ms-transform: ; 4. -o-transform: ; 5. transform: ;你也可以在任意属性前加上“-”符号，也可以为该属性加上前缀。比如输入-super-foo：123451. -webkit-super-foo: ; 2. -moz-super-foo: ; 3. -ms-super-foo: ; 4. -o-super-foo: ; 5. super-foo: ;如果不希望加上所有前缀，可以使用缩写来指定，比如-wm-trf表示只加上-webkit和-moz前缀：1231. -webkit-transform: ; 2. -moz-transform: ; 3. transform: ;前缀缩写如下：w 表示 -webkit-m 表示 -moz-s 表示 -ms-o 表示 -o-渐变输入lg(left, #fff 50%, #000)，会生成如下代码：123451. background-image: -webkit-gradient(linear, 0 0, 100% 0, color-stop(0.5, #fff), to(#000)); 2. background-image: -webkit-linear-gradient(left, #fff 50%, #000); 3. background-image: -moz-linear-gradient(left, #fff 50%, #000); 4. background-image: -o-linear-gradient(left, #fff 50%, #000); 5. background-image: linear-gradient(left, #fff 50%, #000);Tips供给带有单位的值默认地，当展开带有整数值的缩写时，Emmet 输出会带有 px 单位：m10 →margin: 10px;。若是展开的缩写带有浮点娄，输出将带有 em 单位：m1.5 →margin: 1.5em;。不过也可以经由过程在值的后面放置随便率性的字母来明白指定单位： m1.5ex → margin: 1.5ex;， m10foo → margin: 10foo;。若是明白定义了单位，不须要应用连字符分隔各个值： m10ex20em →margin: 10ex 20em;， m10ex-5 → margin: 10ex -5px;。值别号Emmet 有几个常用的别号：p → ％e → emx → ex可以用这些别号来庖代完全的单位：·w100p → width: 100％m10p30e5x → margin: 10％ 30em 5ex色彩值Emmet 付出16进制地色彩值，例如： c＃3 → color: ＃333;。＃ 符号是值的分隔符，所以不须要应用连字符做分隔。例如 bd5＃0s 展开成 border: 5px ＃000 solid: 。5 被从色彩值的 ＃ 到 s （solid的别号）从色彩平分隔出来，因为 s 不是16进制的字符，不须要用 `-` 分隔符。可以以 1个、2个、3个或者6个数字的情势书写色彩值：＃1 → ＃111111＃e0 → ＃e0e0e0＃fc0 → ＃ffcc00当 css.color.short 引用 可用时（默认），类似 ＃ffcc00 如许的值会主动简化成 ＃fc0。也可以按照 css.color.case 引用主动改变大小写。无单位的值一些 CSS 属性被定义为无单位，例如 lh2 → line-height: 2;，fw400 → font-weight: 400;。这些值是: &quot;&quot;z-index、 line-height、 opacity 和 font-weight ，可以哄骗 css.unitlessProperties 引用来覆盖它们。!important 润饰符可以在任何 CSS 缩写后面添加 ! 下标来获得 !important 值：1p!+m10e!将生成12padding: !important;margin: 10em !important;Vendor 前缀CSS3 的新特点为 web 法度员带来了福音：很少的几行代码就能完成几年前近乎不成能实现的任务。但同时这些特点对带来了疾苦：必须为不合的浏览器编写多个雷同的属性。Emmet 的 CSS 解析器有一个很奇妙的特点，可以明显进步编写 CSS3 的体验。每次在 CSS 属性或缩写前添加连字符，Emmet 就主动为每个属性创建带有 vendor 前缀的副本。例如，-bdrs 缩写将展开成：1234//code from http://caibaojian.com/emmet-doc-3.html-webkit-border-radius: ;-moz-border-radius: ;border-radius: ;此外，在支撑 tabstop 的编辑器（例如 Eclipse、 Sublime Text 2、 Espresso 等）中，Emmet 将建树值占位符，法度员可以输入属性值并主动放到全部生成的属性中。它如何工作？展开前面带有连字符的缩写时，Emmet 删除连字符并在 snippets.json 查找残剩的缩写的片段定义。例如 -bdrs 缩写将会在 snippet.json 中查找 bdrs 定义，定义的内容如下：1&quot;bdrs&quot;: &quot;border-radius:|;&quot;也就是说 bdrs 将被展开成 border-radius 属性。若是定义没有找到，缩写本身将被当成 CSS 属性名。经过 CSS 解析器策画出的属性将被输出，它将查找特定的在特定的 vendor 分类是否呈现。这些分类定义设置中的 css.{vendor}Properties 分支。 {vendor} 是浏览器的 vendor 前缀，例如 webkit、 moz 等。若是扩大属性在这些分类中被找到，它们的 vendor 前缀将用作前导属性。不然，所有的前缀将被应用。例如，border-radius 被定义在 css.webkitProperties 和 css.mozProperties中，所以这个属性的输出将带有 webkit 和 moz 前缀。另一种景象，foo 属性没有定义在任何 vendor 分类中，所以在展开 -foo 缩写时，将输出所有可用的前缀：： webkit， moz， ms and o.。它对眼下所实现的那些前沿的 CSS 属性希罕有效。假设 Google Chrome 昨天方才实现了 super-foo ，而你如今就想在项目中应用它。可以应用 -super-foo 属性，展开成果如下：12345-webkit-super-foo: ;-moz-super-foo: ;-ms-super-foo: ;-o-super-foo: ;super-foo: ;默认添加前缀属性在编写 CSS 文件时，也许要查找不带有 vendor 前缀变量的 CSS3 的 “clear” 属性。这会使编写类似 -trf （trf 是 transform 的别号） 如许带有前导连字符的缩写很难堪。这也是为什么默认景象下 Emmet 会有 css.autoInsertVendorPrefixes 选项的原因。这个属性生效，所有定义在 vendor 分类中的 CSS 属性都将被主动供给匹配的 vendor 前缀变量。这意味着，无需应用连字符来为已知的 CSS 属性获取有效的前缀变量，直接展开 bdrs 或 trf 缩写就可以获得有效的 vendor 前缀属性。明白地 vendor 前缀有时可能会想要输出仅带有指定 vendor 前缀属性的 CSS 属性。假定想要输出仅带有 webkit 和 moz 前缀的 transform 属性，可以编写如下缩写：1-wm-trf正如所见到的那样，我们经由过程添加一个字符前缀列表对缩写略作批改。在这种景象下，添加的是 w （webkit） 和 m （moz） 前缀。Emmet 的单字母前缀如下：w: webkitm: mozs: mso: o渐变编写 CSS3 特点的另一个难点是渐变。必须为多个 vendor 前缀多次反复长长地渐变定义。同时，要想覆盖所有支撑渐变的浏览器，就必须应用三种不合的注解：旧的 Webkit，当前支撑 （linear-gradient（top， ...）） 和 W3C-推荐 （linear-gradient（to bottom， ...））。凡是，用户偏向于应用第三方 GUI 来生成渐变定义，然则在编辑器中做同样的工作会更快。Emmet 的 CSS3 渐变生成器可以或许帮你分忧：正像上方显现的那样，可以输入常规地渐变定义如 lg（...） （或 linear-gradient（...）） 函数，并算作一个缩写来展开。若是编写渐变定义来充当属性值，Emmet将解析它并应用它的名字作为新的 CSS 属性的引用。备用值在偏爱设置中，可以使 css.gradient.fallback 选项有效，当渐变定义 background-* CSS 属性展开时，产生一个备用的 background-colorCSS 属性。这个备用属性将包含来自渐变定义的第一个色彩。为个选项默认是封闭的，这是因为它所产生的 background-color 值几乎可以必然须要手动进级，以确保这个靠山的内容可读。若是确切不在乎旧浏览器，就可以打开这个选项。模糊查找若是查阅 总览表，就会发明有很多 CSS 片段要记忆。并且它们中的一项目组为了分隔逻辑变得很长。为了使 CSS 的编写更简单，Emmet 为 CSS 片段实现了模糊查找逻辑：每次输入一个未知的缩写，Emmet 老是试图找到类似的片段定义。例如，作为 ov:h （overflow: hidden;） 缩写的调换，可以输入 ov-h、 ovh 或者干脆输入 oh。拜见下面的示例。演示了 bxz:cb、ovx:h 和 pos:a 片段的不合示例模糊查找只针对预定义的片段名，不支撑片段值或 CSS 属性。这个成果更好猜测和把握匹配。记住 可以创建本身的片段或重定义已存在的片段 来调剂模糊查找的体验生成Lorem ipsum文本Lorem ipsum指一篇常用于排版设计领域的拉丁文文章，主要目的是测试文章或文字在不同字型、版型下看起来的效果。通过Emmet，你只需输入lorem 或 lipsum即可生成这些文字。还可以指定文字的个数，比如lorem10，将生成：引用1Lorem ipsum dolor sit amet, consectetur adipisicing elit. Libero delectus.定制你还可以定制Emmet插件：添加新缩写或更新现有缩写，可修改snippets.json文件更改Emmet过滤器和操作的行为，可修改preferences.json文件定义如何生成HTML或XML代码，可修改syntaxProfiles.json文件]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO写作]]></title>
    <url>%2F2019%2F05%2F19%2FFront-matter%2F</url>
    <content type="text"><![CDATA[Front-matterFront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说：1234---title: Hello Worlddate: 2013/7/13 20:46:25---以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。参数描述默认值layout布局title标题date建立日期文件建立日期updated更新日期文件更新日期comments开启文章的评论功能truetags标签（不适用于分页）categories分类（不适用于分页）permalink覆盖文章网址&nbsp;分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。12345categories:- Diarytags:- PS3- Games分类方法的分歧如果您有过使用WordPress的经验，就很容易误解Hexo的分类方式。WordPress支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。下面的指定方法：categories:- Diary- Life会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。JSON Front-matter除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 --- 代换成 ;;; 即可。123&quot;title&quot;: &quot;Hello World&quot;,&quot;date&quot;: &quot;2013/7/13 20:46:25&quot;;;;你可以执行下列命令来创建一篇新文章。1$ hexo new [layout] &lt;title&gt;您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。布局（Layout）Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。布局路径postsource/_postspagesourcedraftsource/_drafts不要处理我的文章如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。文件名称Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。变量描述:title标题（小写，空格将会被替换为短杠）:year建立的年份，比如， 2015:month建立的月份（有前导零），比如， 04:i_month建立的月份（无前导零），比如， 4:day建立的日期（有前导零），比如， 07:i_day建立的日期（无前导零），比如， 7草稿刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，您可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。1$ hexo publish [layout] &lt;title&gt;草稿默认不会显示在页面中，您可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true来预览草稿。模版（Scaffold）在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：1$ hexo new photo &quot;My Gallery&quot;在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量：变量描述layout布局title标题date文件建立日期]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown文档Typora编辑器用法]]></title>
    <url>%2F2019%2F05%2F10%2FMarkDown%E6%96%87%E6%A1%A3Typora%E7%BC%96%E8%BE%91%E5%99%A8%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、标题使用简单的 ctrl+数字键 就可以快速完成各种级别的标题2、下划线ctrl + u3、删除线alt + shift + 54、字体加粗ctrl + b5、字体倾斜ctrl + i6、无序列表“-” + space + enter嵌套无序列表7、有序列表数字键 + space + enter8、引用“&gt;” + space + enter 或者 ctrl + shift + q9、插入链接ctrl + k10、插入图片本地直接拖拉图片到 md 文件或者配合 MPic完成图片上传图床并复制链接到 md 文件（推荐）或者ctrl + shift + i11、代码块ctrl + shift + f，支持 java，python，groovy 等 绝大多数编程语言12、文章跳转ctrl + home 跳转至文章开头，ctrl + end 跳转至文章末尾，这个就不再演示了13、选中英文单词/中文ctrl + d 或者 ctrl + shift + left/right 左右进行文本选中14、英文错误提示并自动修改15、按行选中ctrl + l16、快速搜索ctrl + f支持区分英文大小写和整个单词搜索，也支持中文搜索17、替换ctrl + h18、快速生成表格ctrl + t19、快速打开笔记ctrl + p20、toc 快速生成目录[toc] + enter21、着重关键字ctrl + shift + 反引号键（tab 键上面那个键）因为主题原因这里看不出来，换个主题就很明显了22、表情符号英文状态下的引号，输入字母自动显示表情符号还有一种方式，使用输入法的快捷键，这里我使用的是微软输入法 ctrl + shift + b23、新建文件ctrl + n，这个就不再演示了24、显示和隐藏侧边栏ctrl + shift + l25、全屏切换f11 这个就不再演示了26、分割线— + enter，这个也不再演示27、高亮显示==文字==，这个也不再演示28、创建表格Ctrl + T29、段落快捷键ctrl + 030、定义脚注文字 [ + ^ + 脚注 + ]31、插入URL链接&lt; + 链接 + &gt;]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
