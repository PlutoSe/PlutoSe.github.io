<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AngularJS</title>
    <url>/2019/08/12/AngularJS/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>AngularJS是什么<ul><li>AngularJs（后面就简称ng了）是一个用于设计动态web应用的结构框架</li><li>核心是对HTML标签的增强</li><li>使你能够用标签完成一部分页面逻辑</li><li>AngularJS是一个 MV* 框架，最适于开发客户端的单页面应用</li><li>重要功能与特性<ul><li>双向的数据绑定</li><li>模板</li><li>MVC<ul><li>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发</li><li>MVC是一个设计模式，它强制性的使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务</li><li>优点：<ul><li>可以为一个模型在运行时同时建立和使用多个视图。变化-传播机制可以确保所有相关的视图及时得到模型数据变化，从而使所有关联的视图和控制器做到行为同步</li><li>视图与控制器的可接插性，允许更换视图和控制器对象，而且可以根据需求动态的打开或关闭、甚至在运行期间进行对象替换</li><li>模型的可移植性。因为模型是独立于视图的，所以可以把一个模型独立地移植到新的平台工作。需要做的只是在新平台上对视图和控制器进行新的修改</li><li>潜在的框架结构。可以基于此模型建立应用程序框架，不仅仅是用在设计界面的设计中</li></ul></li><li>缺点：<ul><li>增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率</li><li>视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用</li><li>视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能</li><li>目前，一般高级的界面工具或构造器不支持模式。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成MVC使用的困难</li></ul></li></ul></li><li>服务与依赖注入<ul><li>AngularJS服务其作用就是对外提供某个特定的功能</li><li>AngularJS拥有内建的依赖注入（DI）子系统，可以帮助开发人员更容易的开发，理解和测试应用</li></ul></li><li>指令</li></ul></li></ul></li><li>scopes module controller<ul><li>scopes<ul><li>$scope是一个把view（一个DOM元素）连结到controller上的对象</li><li>每一个Angular应用都会有一个 $rootScope。这个 $rootScope 是最顶级的scope，它对应着含有 ng-app 指令属性的那个DOM元素。</li></ul></li></ul></li></ul><h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h1><ul><li><p>factory service provider之间的关系</p><ul><li><p>factory<br>把 service 的方法和数据放在一个对象里，并返回这个对象</p></li><li><p>service<br>通过构造函数方式创建 service，返回一个实例化对象</p></li><li><p>provider<br>创建一个可通过 config 配置的 service，$get 中返回的，就是用 factory 创建 service 的内容</p></li></ul></li></ul><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>2019双十一京东</title>
    <url>/2019/10/25/2019%E5%8F%8C%E5%8D%81%E4%B8%80%E4%BA%AC%E4%B8%9C/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><p>1、首先在电脑浏览器打开 <code>http://www.jd.com</code> 登录京东账号</p><p>2、然后用电脑浏览器 打开<a href="https://happy.m.jd.com/babelDiy/GZWVJFLMXBQVEBDQZWMY/XJf8bH6oXDWSgS91daDJzXh9bU7/index.html" target="_blank" rel="noopener">https://happy.m.jd.com/babelDiy/GZWVJFLMXBQVEBDQZWMY/XJf8bH6oXDWSgS91daDJzXh9bU7/index.html</a> 进入活动页面</p><p>3、按F12 点击<code>Console</code> 输入以下代码 之后按一下回车键 就会自动完成了。(图中以Chrome浏览器为例)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> productList = [],</span><br><span class="line">    shopList = [],</span><br><span class="line">    url = <span class="string">"https://api.m.jd.com/client.action"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoPost</span>(<span class="params">id, type</span>) </span>&#123;</span><br><span class="line">    fetch(<span class="string">`<span class="subst">$&#123;url&#125;</span>?timestamp=<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()&#125;</span>`</span>, &#123;</span><br><span class="line">        method: <span class="string">"POST"</span>,</span><br><span class="line">        mode: <span class="string">"cors"</span>,</span><br><span class="line">        credentials: <span class="string">"include"</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        body: <span class="string">`functionId=raisepacket_collectScore&amp;body=&#123;"type":<span class="subst">$&#123;type&#125;</span>,"ext":"<span class="subst">$&#123;id&#125;</span>","appsign":1,"msgsign":2&#125;&amp;client=wh5`</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response.json()</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res.data.biz_msg)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fetch(<span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()&#125;</span>`</span>, &#123;</span><br><span class="line">        method: <span class="string">"POST"</span>,</span><br><span class="line">        mode: <span class="string">"cors"</span>,</span><br><span class="line">        credentials: <span class="string">"include"</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        body: <span class="string">'functionId=raisepacket_getShopAndProductList&amp;body=&amp;client=wh5'</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response.json()</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        productList = res.data.result.productList;</span><br><span class="line">        shopList = res.data.result.shopList;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`获取到任务,商品：<span class="subst">$&#123;productList.length&#125;</span>商品：<span class="subst">$&#123;shopList.length&#125;</span>`</span>);</span><br><span class="line">        autoProductTask()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoProductTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, leng = productList.length; i &lt; leng; i++) &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> item = productList[index];</span><br><span class="line">                autoPost(item[<span class="string">'id'</span>], <span class="number">4</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`商品总任务数：<span class="subst">$&#123;leng&#125;</span>当前任务数：<span class="subst">$&#123;index+<span class="number">1</span>&#125;</span>`</span>);</span><br><span class="line">                <span class="keyword">if</span> (leng - <span class="number">1</span> == index) &#123;</span><br><span class="line">                    autoShopTask()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, index * <span class="number">1500</span>)</span><br><span class="line">        &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoShopTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, leng = shopList.length; i &lt; leng; i++) &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> item = shopList[index];</span><br><span class="line">                autoPost(item[<span class="string">'id'</span>], <span class="number">2</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`商铺总任务数：<span class="subst">$&#123;leng&#125;</span>当前任务数：<span class="subst">$&#123;index+<span class="number">1</span>&#125;</span>`</span>);</span><br><span class="line">                <span class="keyword">if</span> (leng - <span class="number">1</span> == index) &#123;</span><br><span class="line">                    autoPlay()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, index * <span class="number">1500</span>)</span><br><span class="line">        &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoPlay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, leng = <span class="number">4</span>; i &lt; leng; i++) &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                autoPost(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`好玩互动：<span class="subst">$&#123;leng&#125;</span>当前任务数：<span class="subst">$&#123;index+<span class="number">1</span>&#125;</span>`</span>);</span><br><span class="line">                <span class="keyword">if</span> (leng - <span class="number">1</span> == index) &#123;</span><br><span class="line">                    autoInteract()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, index * <span class="number">1000</span>)</span><br><span class="line">        &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoInteract</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, leng = <span class="number">4</span>; i &lt; leng; i++) &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                autoPost(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`视频直播：<span class="subst">$&#123;leng&#125;</span>当前任务数：<span class="subst">$&#123;index+<span class="number">1</span>&#125;</span>`</span>);</span><br><span class="line">                <span class="keyword">if</span> (leng - <span class="number">1</span> == index) &#123;</span><br><span class="line">                    autoShopping()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, index * <span class="number">1000</span>)</span><br><span class="line">        &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoShopping</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, leng = <span class="number">3</span>; i &lt; leng; i++) &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                autoPost(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`精彩会场：<span class="subst">$&#123;leng&#125;</span>当前任务数：<span class="subst">$&#123;index+<span class="number">1</span>&#125;</span>`</span>)</span><br><span class="line">            &#125;, index * <span class="number">1000</span>)</span><br><span class="line">        &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">start();</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/2019/06/05/CSS/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><h1 id="CSS命名规范"><a href="#CSS命名规范" class="headerlink" title="CSS命名规范"></a>CSS命名规范</h1><h2 id="常规命名"><a href="#常规命名" class="headerlink" title="常规命名"></a>常规命名</h2><ul><li>头：header</li><li>内容：content/container</li><li>尾：footer</li><li>导航：nav</li><li>侧栏：sidebar</li><li>栏目：column</li><li>页面外围控制整体布局宽度：wrapper</li><li>左右中：left right center</li><li>登录条：loginbar</li><li>标志：logo</li><li>广告：banner</li><li>页面主体：main</li><li>热点：hot</li><li>新闻：news</li><li>下载：download</li><li>子导航：subnav</li><li>菜单：menu</li><li>子菜单：submenu</li><li>搜索：search</li><li>友情链接：friendlink</li><li>页脚：footer</li><li>版权：copyright</li><li>滚动：scroll</li><li>内容：content</li><li>标签页：tab</li><li>文章列表：list</li><li>提示信息：msg</li><li>小技巧：tips</li><li>栏目标题：title</li><li>加入：joinus</li><li>指南：guild</li><li>服务：service</li><li>注册：regsiter</li><li>状态态：status</li><li>投票：vote</li><li>合作伙伴：partner</li></ul><h2 id="注释的写法"><a href="#注释的写法" class="headerlink" title="注释的写法"></a>注释的写法</h2><p>/<em> Footer </em>/<br>内容区<br>/<em> End Footer </em>/</p><h2 id="id的命名"><a href="#id的命名" class="headerlink" title="id的命名"></a>id的命名</h2><ul><li>容器: container</li><li>页头：header</li><li>内容：content/container</li><li>页面主体：main</li><li>页尾：footer</li><li>导航：nav</li><li>侧栏：sidebar</li><li>栏目：column</li><li>页面外围控制整体布局宽度：wrapper</li><li>左右中：left right center</li></ul><h2 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h2><ul><li>容器: container</li><li>页头：header</li><li>内容：content/container</li><li>页面主体：main</li><li>页尾：footer</li><li>导航：nav</li><li>侧栏：sidebar</li><li>栏目：column</li><li>页面外围控制整体布局宽度：wrapper</li><li>左右中：left right center</li></ul><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><ul><li>导航：nav</li><li>主导航：mainbav</li><li>子导航：subnav</li><li>顶导航：topnav</li><li>边导航：sidebar</li><li>左导航：leftsidebar</li><li>右导航：rightsidebar</li><li>菜单：menu</li><li>子菜单：submenu</li><li>标题: title</li><li>摘要: summary</li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>标志：logo</li><li>广告：banner</li><li>登陆：login</li><li>登录条：loginbar</li><li>注册：regsiter</li><li>搜索：search</li><li>功能区：shop</li><li>标题：title</li><li>加入：joinus</li><li>状态：status</li><li>按钮：btn</li><li>滚动：scroll</li><li>标签页：tab</li><li>文章列表：list</li><li>提示信息：msg</li><li>当前的: current</li><li>小技巧：tips</li><li>图标: icon</li><li>注释：note</li><li>指南：guild</li><li>服务：service</li><li>热点：hot</li><li>新闻：news</li><li>下载：download</li><li>投票：vote</li><li>合作伙伴：partner</li><li>友情链接：link</li><li>版权：copyright</li></ul><h2 id="class的命名"><a href="#class的命名" class="headerlink" title="class的命名"></a>class的命名</h2><p>(1)颜色:使用颜色的名称或者16进制代码,如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.red</span> &#123; <span class="attribute">color</span>: red; &#125;</span><br><span class="line"><span class="selector-class">.f60</span> &#123; <span class="attribute">color</span>: <span class="number">#f60</span>; &#125;</span><br><span class="line"><span class="selector-class">.ff8600</span> &#123; <span class="attribute">color</span>: <span class="number">#ff8600</span>; &#125;</span><br></pre></td></tr></table></figure><p>(2)字体大小,直接使用”font+字体大小”作为名称,如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.font12px</span> &#123; <span class="attribute">font-size</span>: <span class="number">12px</span>; &#125;</span><br><span class="line"><span class="selector-class">.font9pt</span> &#123;<span class="attribute">font-size</span>: <span class="number">9pt</span>; &#125;</span><br></pre></td></tr></table></figure><p>(3)对齐样式,使用对齐目标的英文名称,如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123; <span class="attribute">float</span>:left; &#125;</span><br><span class="line"><span class="selector-class">.bottom</span> &#123; <span class="attribute">float</span>:bottom; &#125;</span><br></pre></td></tr></table></figure><p>(4)标题栏样式,使用”类别+功能”的方式命名,如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.barnews</span> &#123; &#125;</span><br><span class="line"><span class="selector-class">.barproduct</span> &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.一律小写;<br>2.尽量用英文;<br>3.不加中杠和下划线;<br>4.尽量不缩写，除非一看就明白的单词.</p><ul><li>主要的 master.css</li><li>模块 module.css</li><li>基本共用 base.css</li><li>布局，版面 layout.css</li><li>主题 themes.css</li><li>专栏 columns.css</li><li>文字 font.css</li><li>表单 forms.css</li><li>补丁 mend.css</li><li>打印 print.css</li></ul><h1 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h1><h2 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h2><ul><li>font-family=“微软雅黑”;<ul><li>当指定多种字体时，用“，”分隔每种字体的名称</li><li>当字体名称包含两个以上分开的单词是，用“”把该字体名称括起来。</li><li>当样式规则外已经有“”时,用‘’代替“”。</li></ul></li><li>color=#ccc;<ul><li>/<em>设置字体颜色</em>/</li><li>16进制</li><li>RGBA</li></ul></li><li>text-decoration:underline;<ul><li>/<em>字体加下划线</em>/</li></ul></li><li>text-decoration:none;<ul><li>/<em>去下划线</em>/</li></ul></li><li>font-size:14px;<ul><li>/<em>字体的大小</em>/</li></ul></li><li>font-style:<ul><li>normal正常状态</li><li>italic斜体字</li><li>oblique 斜体和正常状态之间</li></ul></li><li>font-weight:<ul><li>number(100～900)</li><li>lighter（细体）</li><li>bold(粗体)</li><li>bolder（特粗体）</li></ul></li><li>text-transform:<ul><li>uppercase 所有文字大写显示</li><li>lowercase:所有文字小写显示</li><li>capitalize 每个单词的头字母大写</li><li>none 不继承母体的文字变形参数</li></ul></li><li>text-decoration:<ul><li>underline 为文字加下划线</li><li>overline 为文字加上划线</li><li>line-through 为文字加删除线</li><li>blink 使文字闪烁</li><li>none 不显示上叙任何效果</li></ul></li><li>可以用font 属性全部定位<ul><li>p{font:italic bold 12pt;}</li></ul></li></ul><h2 id="边框与填充样式"><a href="#边框与填充样式" class="headerlink" title="边框与填充样式"></a>边框与填充样式</h2><ul><li>margin：<ul><li>外边距</li><li>与边距的距离</li><li>(margin-top margin-left margin-bottom margin-left)</li><li>取值可以是：auto默认</li><li>百分比或者具体的值：</li><li>取值可以是一个或者两个或者三个或者四个（每个都具有不同的含义）。</li><li>4:上右下左</li><li>3：上，左右，下</li><li>2：上下，左右</li></ul></li><li>padding<ul><li>内边距</li><li>复合属性填充（指用白值填充）</li><li>和margin的用法一样。</li></ul></li><li>border-style<ul><li>border-top-style:上边框样式</li><li>border-right-style:右边框样式</li><li>border-bottom-style:底边框样式</li><li>border-left-style:左边框样式</li><li>取值：<ul><li>none 不现实边框，为默认值</li><li>dotted 点线（电线）</li><li>dashed 虚线，也称短线</li><li>solid 实线</li><li>double 双实线</li><li>groove 边框带有立体感的沟槽</li><li>ridge 边框成脊形</li><li>inset 使整个表框凹陷，即在边框内嵌入一个立体边框</li><li>outset 使整个边框凸起，即在边框外嵌入一个立体边框</li></ul></li></ul></li><li>border-color=“#ccc”;<ul><li>/<em>设置边框颜色</em>/</li></ul></li><li>border-width：<ul><li>border-top-width:上边框宽度</li><li>border-right-width:右边框宽度</li><li>border-bottom-width:底边框宽度</li><li>border-left-width:左边框宽度</li><li>取值为：<ul><li>medium 默认宽度</li><li>thin 细边框</li><li>thick 粗边框</li></ul></li></ul></li><li>border:1px solid #999;<ul><li>/<em>添加一条边框</em>/</li><li>border-top：上边框</li><li>border—right：右边框</li><li>border—bottom：底边框</li><li>border-left：左边框</li></ul></li></ul><h2 id="背景样式"><a href="#背景样式" class="headerlink" title="背景样式"></a>背景样式</h2><ul><li>background-color<ul><li>背景颜色</li></ul></li><li>background-image<ul><li>背景图片</li></ul></li><li>background-repeat:<ul><li>repeat 表示图像从水平和垂直角度平铺</li><li>no-repeat 不重复平铺背景图片</li><li>repeat-x 使图片只在水平方向上平铺</li><li>repeat-y 使图片只在垂直方向上平铺</li></ul></li><li>background-attachment 参数<ul><li>fixed 网页滚动时，背景图片相对浏览器而言固定不动</li><li>scroll 网页滚动时，背景图片相对浏览器而言一起滚动</li></ul></li><li>background-postion ：<ul><li>（背景定位）</li><li>top 相对前景对象顶对齐</li><li>bottom 相对前景对象底对齐</li><li>left 相对前景对象左对齐</li><li>right 相对前景对象右对齐</li><li>center 相对前景对象中心对齐</li></ul></li><li>可以直接用 background 复合属性来确定式样<ul><li>示例：</li><li>table{background:#001122 url(zhouliang.jpg) no-repeat bottom right}</li></ul></li></ul><h2 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h2><ul><li>word-spacing:<ul><li>英文单词间距</li><li>取值：normal或者是单位像素</li></ul></li><li>letter-spacing:<ul><li>英文字母间距</li><li>取值可以是：normal或者是单位像素</li></ul></li><li>line-height:<ul><li>行距</li><li>可以是精确的值，也可以是百分比</li></ul></li><li>text-aglin:<ul><li>文本水平排列</li><li>left: 左对齐</li><li>right：右对齐</li><li>center: 居中</li><li>justify:相对左右对齐。</li><li>注意到：text-aglin 是块级属性，只能用于p、blockquqte、ul、h1-h6等表示</li></ul></li><li>vertical-align:<ul><li>文本垂直排列</li><li>top 顶对齐 bottom 底部对齐 text-top 相对文本顶对齐</li><li>text-bottom相对文本底对齐 baseline:基准线对齐 middle 中心线对齐</li><li>sub 以下标的形式对齐 sup 以上标的形式对齐,相对于元素行高属性的百分比</li></ul></li><li>text-indent：<ul><li>文本缩进</li><li>缩进距离必须是值或者百分比</li></ul></li><li>white-space<ul><li>normal：合并连续的多个空格</li><li>pre：保留原样式</li><li>nowrap：不换行，直到遇到br标签</li></ul></li><li>text-decoraition<ul><li>none :表示不对文本进行修饰，也是默认值，</li><li>underline:表示对文字添加下划线</li><li>overline:表示添加上划线</li><li>line-through:表示对文本添加删除线</li><li>blink:表示文字具有闪烁效果</li></ul></li><li>text-transform：文本转换<ul><li>none:表示原有值</li><li>capitalize:使每个字的第一个字母大写</li><li>uppercase:大写</li><li>lowercase:小写</li></ul></li></ul><h2 id="定位样式"><a href="#定位样式" class="headerlink" title="定位样式"></a>定位样式</h2><ul><li>postion<ul><li>absolute 采用绝对定位（分别用四个边框来定位）</li><li>relative 采用相对定位（也得用四个边框来设定位置）</li><li>static 默认值</li></ul></li><li>left/top/width/height<ul><li>设置值可以是</li></ul></li><li>z-index<ul><li>也就是元素的堆叠,大的在上，小的在下。默认是按照先后顺序</li><li>取值auto默认值，表示它遵循其父对象的定位属性</li><li>如果设置为数字,必须是无单位的正整数，可以取负值，但是一般为正数,一般数字为1时间是最底层</li></ul></li></ul><h2 id="布局样式"><a href="#布局样式" class="headerlink" title="布局样式"></a>布局样式</h2><ul><li><p>visibility 可视性</p><ul><li>inherit：表示对象继承父本的继承性。</li><li>visible:表示对象可见</li><li>hidden：表示对象隐藏</li></ul></li><li><p>视口</p><ul><li>width=device-width ：表示宽度是设备屏幕的宽度</li><li>initial-scale=1.0：表示初始的缩放比例</li><li>minimum-scale=0.5：表示最小的缩放比例</li><li>maximum-scale=2.0：表示最大的缩放比例</li><li>user-scalable=yes：表示用户是否可以调整缩放比例</li></ul></li><li><p>display</p><ul><li>设置或检索对象是否及如何显示</li><li>block、inline、list-item、none</li></ul></li><li><p>clip</p><ul><li>可视区域</li><li>auto表示对象不裁剪</li><li>rect(数值表示)(一般有四个设置值：方向定位于上右下左的顺序，一般以左上角(0,0)坐标计算4个偏移数值。其中 任何一个值都可以用auto代替)</li></ul></li><li><p>overflow</p><ul><li>超出范围</li><li>isible 扩大浏览器</li><li>hidden 裁剪掉多余的文本</li><li>scroll 滚动条</li><li>auto 当有多余的时候才显示滚动条</li></ul></li><li><h3 id="float-浮动属性"><a href="#float-浮动属性" class="headerlink" title="float    浮动属性"></a><strong><em>float</em></strong> 浮动属性</h3><ul><li>left表示文字浮在元素左侧</li><li>right 表示文字浮在元素右侧</li><li>none 默认值，表示不浮动。</li><li><strong><em>重点</em></strong></li></ul></li><li><p>clear ：</p><ul><li>表示指定一个元素周围是都允许有其他元素漂浮在它的周围。</li><li>left ,right,none,both;指要清除本元素四周的浮动对象</li></ul></li><li><p>page-break-before</p><ul><li>always 是否强制分页</li></ul></li><li><p>page-break-after</p><ul><li>always 打印后设置是否强制分页</li></ul></li><li><p>width和height</p><ul><li>表示层的宽度与高度</li><li>设置值为 auto|数值</li></ul></li></ul><h2 id="列表样式"><a href="#列表样式" class="headerlink" title="列表样式"></a>列表样式</h2><ul><li>list-style-type<ul><li>指显示于列表项前的标识符号</li><li>none 表示不显示列表符号</li></ul></li><li>list-style-postion<ul><li>列表缩进</li><li>inside 列表内容和列表标识符号处在不同垂直位置，在符号内侧</li><li>outside 列表内容和列表标识符号处在同一垂直位置</li></ul></li><li>list-style-image<ul><li>用图片符号作为链接标题</li><li>none 表示不指定图像</li><li>url(网页地址) 指定图片位置</li></ul></li><li>list-style<ul><li>复合属性：实现以上三种</li></ul></li></ul><h2 id="光标样式"><a href="#光标样式" class="headerlink" title="光标样式"></a>光标样式</h2><ul><li>cursor<ul><li>当点击某个内容时，鼠标显示其他的图形</li><li>style=”cursor:hand” 手形</li><li>style=”cursor:crosshair” 十字形</li></ul></li></ul><h1 id="CSS尺寸"><a href="#CSS尺寸" class="headerlink" title="CSS尺寸"></a>CSS尺寸</h1><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p><strong>任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合:</strong><br><strong>1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为</strong><br><strong>16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了</strong></p><h2 id="绝对单位"><a href="#绝对单位" class="headerlink" title="绝对单位"></a>绝对单位</h2><ul><li><p>in</p><ul><li>英寸（Inch），绝对长度单位</li></ul></li><li><p>pt</p><ul><li>绝对长度单位。点（Point）。</li><li>1in = 2.54cm = 25.4 mm = 72pt = 6pc</li></ul></li><li><p>pc</p><ul><li><p>绝对长度单位。派卡（Pica）。相当于我国新四号铅字的尺寸。</p><p>​ 1in = 2.54cm = 25.4 mm = 72pt = 6pc</p></li></ul></li><li><p>cm</p><ul><li><p>绝对长度单位。厘米（Centimeter）。</p><p>​ 1in = 2.54cm = 25.4 mm = 72pt = 6pc</p></li></ul></li><li><p>mm</p><ul><li><p>绝对长度单位。毫米（Millimeter）。</p><p>​ 1in = 2.54cm = 25.4 mm = 72pt = 6pc</p></li></ul></li></ul><h2 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h2><ul><li>px<ul><li>相对长度单位。像素（Pixel）</li></ul></li><li>em<ul><li>相对长度单位。相对于当前对象内文本的字体尺寸</li></ul></li><li>ex<ul><li>相对长度单位。相对于字符“x”的高度。此高度通常为字体尺寸的一半。</li><li>如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。</li></ul></li><li>rem<ul><li>区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素</li><li><strong>选择使用什么字体单位主要由你的项目来决定，如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用</strong></li></ul></li></ul><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO写作</title>
    <url>/2019/05/19/Front-matter/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><h1 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h1><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2013&#x2F;7&#x2F;13 20:46:25</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left"><code>layout</code></td><td style="text-align:left">布局</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>title</code></td><td style="text-align:left">标题</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>date</code></td><td style="text-align:left">建立日期</td><td style="text-align:left">文件建立日期</td></tr><tr><td style="text-align:left"><code>updated</code></td><td style="text-align:left">更新日期</td><td style="text-align:left">文件更新日期</td></tr><tr><td style="text-align:left"><code>comments</code></td><td style="text-align:left">开启文章的评论功能</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left"><code>tags</code></td><td style="text-align:left">标签（不适用于分页）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>categories</code></td><td style="text-align:left">分类（不适用于分页）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>permalink</code></td><td style="text-align:left">覆盖文章网址</td><td style="text-align:left">&nbsp;</td></tr></tbody></table><h2 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h2><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure><blockquote><p>分类方法的分歧</p><p>如果您有过使用WordPress的经验，就很容易误解Hexo的分类方式。WordPress支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。下面的指定方法：<br>categories:<br>- Diary<br>- Life<br>会使分类<code>Life</code>成为<code>Diary</code>的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p></blockquote><h2 id="JSON-Front-matter"><a href="#JSON-Front-matter" class="headerlink" title="JSON Front-matter"></a>JSON Front-matter</h2><p>除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 <code>---</code> 代换成 <code>;;;</code> 即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;title&quot;: &quot;Hello World&quot;,</span><br><span class="line">&quot;date&quot;: &quot;2013&#x2F;7&#x2F;13 20:46:25&quot;</span><br><span class="line">;;;</span><br></pre></td></tr></table></figure><p>你可以执行下列命令来创建一篇新文章。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>您可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><h3 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h3><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>，它们分别对应不同的路径，而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><table><thead><tr><th style="text-align:left">布局</th><th style="text-align:left">路径</th></tr></thead><tbody><tr><td style="text-align:left"><code>post</code></td><td style="text-align:left"><code>source/_posts</code></td></tr><tr><td style="text-align:left"><code>page</code></td><td style="text-align:left"><code>source</code></td></tr><tr><td style="text-align:left"><code>draft</code></td><td style="text-align:left"><code>source/_drafts</code></td></tr></tbody></table><blockquote><p>不要处理我的文章</p><p>如果你不想你的文章被处理，你可以将 Front-Matter 中的<code>layout:</code> 设为 <code>false</code> 。</p></blockquote><h3 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h3><p>Hexo 默认以标题做为文件名称，但您可编辑 <code>new_post_name</code> 参数来改变默认的文件名称，举例来说，设为 <code>:year-:month-:day-:title.md</code> 可让您更方便的通过日期来管理文章。</p><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>:title</code></td><td style="text-align:left">标题（小写，空格将会被替换为短杠）</td></tr><tr><td style="text-align:left"><code>:year</code></td><td style="text-align:left">建立的年份，比如， <code>2015</code></td></tr><tr><td style="text-align:left"><code>:month</code></td><td style="text-align:left">建立的月份（有前导零），比如， <code>04</code></td></tr><tr><td style="text-align:left"><code>:i_month</code></td><td style="text-align:left">建立的月份（无前导零），比如， <code>4</code></td></tr><tr><td style="text-align:left"><code>:day</code></td><td style="text-align:left">建立的日期（有前导零），比如， <code>07</code></td></tr><tr><td style="text-align:left"><code>:i_day</code></td><td style="text-align:left">建立的日期（无前导零），比如， <code>7</code></td></tr></tbody></table><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>刚刚提到了 Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code>来预览草稿。</p><h2 id="模版（Scaffold）"><a href="#模版（Scaffold）" class="headerlink" title="模版（Scaffold）"></a>模版（Scaffold）</h2><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new photo &quot;My Gallery&quot;</span><br></pre></td></tr></table></figure><p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>layout</code></td><td style="text-align:left">布局</td></tr><tr><td style="text-align:left"><code>title</code></td><td style="text-align:left">标题</td></tr><tr><td style="text-align:left"><code>date</code></td><td style="text-align:left">文件建立日期</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript6</title>
    <url>/2019/10/16/ES6/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><h1 id="Babel转码器"><a href="#Babel转码器" class="headerlink" title="Babel转码器"></a>Babel转码器</h1><p>Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。即，你可以用ES6的方式编写程序，又不用担心现有环境是否支持。</p><p>下面是一个例子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转码前</span></span><br><span class="line">input.map(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//转码后</span></span><br><span class="line">input.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的原始代码用了箭头函数，这个特性还没有得到广泛支持，Babel将其转为普通函数，就能在现有的JavaScript环境执行</p><h2 id="配置文件-babelrc"><a href="#配置文件-babelrc" class="headerlink" title="配置文件.babelrc"></a>配置文件.babelrc</h2><p>Babel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。</p><p>该文件用来设置转码规则和插件，基本格式如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">"presets"</span>:[],</span><br><span class="line">	<span class="string">"plugins"</span>:[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>presets字段</p><h1 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h1><h2 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">//ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p><p><code>for</code>循环的计数器，就很合适使用let命令。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">//ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码的计数器<code>i</code>，只在<code>for</code>循环体内有效。</p><p>下面的代码如果使用<code>var</code>，最后输出的是10。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>是<code>var</code>声明的，在全局范围内都有效。所以每一次循环，新的<code>i</code>值都会覆盖旧值，导致最后输出的是最后一轮的<code>i</code>的值。</p><p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是6。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是6。</p><h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p><code>let</code>不像<code>var</code>那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p><p>ES6明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，<strong>在代码块内，使用let命令声明变量之前，该变量都是不可用的</strong>。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。</p><p>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>x</code>使用<code>let</code>命令声明，所以在声明之前，都属于<code>x</code>的“死区”，只要用到该变量就会报错。因此，<code>typeof</code>运行时就会抛出一个<code>ReferenceError</code>。</p><p>作为比较，如果一个变量根本没有被声明，使用<code>typeof</code>反而不会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>undeclared_variable</code>是一个不存在的变量名，结果返回“undefined”。所以，在没有<code>let</code>之前，<code>typeof</code>运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p><p>有些“死区”比较隐蔽，不太容易发现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>bar</code>函数之所以报错（某些实现可能不报错），是因为参数<code>x</code>默认值等于另一个参数<code>y</code>，而此时<code>y</code>还没有声明，属于”死区“。如果<code>y</code>的默认值是<code>x</code>，就不会报错，因为此时<code>x</code>已经声明了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = <span class="number">2</span>, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure><p>ES6规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。</p><p>总之，暂时性死区的本质就是，<strong>只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</strong></p><h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p>let不允许在相同作用域内，重复声明同一个变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，不能在函数内部重新声明参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg; <span class="comment">// 不报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><h3 id="为什么需要块级作用域"><a href="#为什么需要块级作用域" class="headerlink" title="为什么需要块级作用域?"></a>为什么需要块级作用域?</h3><p>ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p><p>第一种场景，内层变量可能会覆盖外层变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">"hello world"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数f执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。</p><p>第二种场景，用来计数的循环变量泄露为全局变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p><h2 id="ES6的块级作用域"><a href="#ES6的块级作用域" class="headerlink" title="ES6的块级作用域"></a>ES6的块级作用域</h2><p><code>let</code>实际上为JavaScript新增了块级作用域。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用<code>var</code>定义变量<code>n</code>，最后输出的值就是10。</p><p>ES6允许块级作用域的任意嵌套。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>&#125;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(insane); <span class="comment">// 报错</span></span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>内层作用域可以定义外层作用域的同名变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  <span class="keyword">let</span> insane = <span class="string">'Hello World'</span>;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IIFE写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h2><p>函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。</p><p>ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的两种函数声明，根据ES5的规定都是非法的。</p><p>但是，浏览器没有遵守这个规定，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5严格模式</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>ES6引入了块级作用域，明确允许在块级作用域之中声明函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6严格模式</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure><p>并且ES6规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>上面代码在ES5中运行，会得到“I am inside!”，因为在<code>if</code>内声明的函数<code>f</code>会被提升到函数头部，实际运行的代码如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>ES6的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于<code>let</code>，对作用域之外没有影响，实际运行的代码如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>很显然，这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics" target="_blank" rel="noopener">附录B</a>里面规定，浏览器的实现可以不遵守上面的规定，有自己的<a href="http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6" target="_blank" rel="noopener">行为方式</a>。</p><ul><li>允许在块级作用域内声明函数。</li><li>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部。</li><li>同时，函数声明还会提升到所在的块级作用域的头部。</li></ul><p>注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作<code>let</code>处理。</p><p>前面那段代码，在Chrome环境下运行会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6的浏览器环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>上面的代码报错，是因为实际运行的是下面的代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6的浏览器环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明语句</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h2><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line">PI <span class="comment">// 3.1415</span></span><br><span class="line"></span><br><span class="line">PI = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>上面代码表明改变常量的值会报错。</p><p><code>const</code>声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo;</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><p>上面代码表示，对于<code>const</code>来说，只声明不赋值，就会报错。</p><p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> MAX = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MAX <span class="comment">// Uncaught ReferenceError: MAX is not defined</span></span><br></pre></td></tr></table></figure><p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(MAX); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">const</span> MAX = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码在常量<code>MAX</code>声明之前就调用，结果报错。</p><p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两行都会报错</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">"Goodbye!"</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。<code>const</code>命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">foo.prop</span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: "foo" is read-only</span></span><br></pre></td></tr></table></figure><p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p><p>下面是另一个例子。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">'Dave'</span>];    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p><p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p><p>除了将对象本身冻结，对象的属性也应该冻结。下面是<strong>一个将对象彻底冻结的函数。</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES5只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6除了添加<code>let</code>和<code>const</code>命令，后面章节还会提到，另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6一共有6种声明变量的方法。</p><h2 id="全局对象的属性"><a href="#全局对象的属性" class="headerlink" title="全局对象的属性"></a>全局对象的属性</h2><p>全局对象是最顶层的对象，在浏览器环境指的是<code>window</code>对象，在Node.js指的是<code>global</code>对象。ES5之中，全局对象的属性与全局变量是等价的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，全局对象的属性赋值与全局变量的赋值，是同一件事。（对于Node来说，这一条只对REPL环境适用，模块环境之中，全局变量必须显式声明成<code>global</code>对象的属性。）</p><p>未声明的全局变量，自动成为全局对象<code>window</code>的属性，这被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了两个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道，其次程序员很容易不知不觉地就创建了全局变量（比如打字出错）。另一方面，从语义上讲，语言的顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是全局对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与全局对象的属性脱钩。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在Node的REPL环境，可以写成global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，全局变量<code>a</code>由<code>var</code>命令声明，所以它是全局对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是全局对象的属性，返回<code>undefined</code>。</p><h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>以前，为变量赋值，只能直接指定值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>ES6允许写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br><span class="line">third <span class="comment">// "baz"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x <span class="comment">// "a"</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果解构不成功，变量的值就等于<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo] = [];</span><br><span class="line"><span class="keyword">var</span> [bar, foo] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>以上两种情况都属于解构不成功，<code>foo</code>的值都会等于<code>undefined</code>。</p><p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>上面两个例子，都属于不完全解构，但是可以成功。</p><p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。</p><p>解构赋值不仅适用于var命令，也适用于let和const命令。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [v1, v2, ..., vN ] = array;</span><br><span class="line"><span class="keyword">let</span> [v1, v2, ..., vN ] = array;</span><br><span class="line"><span class="keyword">const</span> [v1, v2, ..., vN ] = array;</span><br></pre></td></tr></table></figure><p>对于Set结构，也可以使用数组的解构赋值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</span><br><span class="line">x <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure><p>事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>fibs</code>是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。</p><p><em>注：</em></p><ul><li><em>Iterator：迭代器</em></li><li>function*<em>（构造器函数）： ES6中定义了一种新的函数.用function定义生成器函数,这种函数会返回一个generator对象.生成器函数在执行时可以暂停，然后又可以在暂停处接着执行。</em></li></ul><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>解构赋值允许指定默认值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">[x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line">[x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></span><br></pre></td></tr></table></figure><p>注意，ES6内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值是不会生效的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。</p><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>上面代码中，因为<code>x</code>能取到值，所以函数<code>f</code>根本不会执行。上面的代码其实等价于下面的代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  x = f();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  x = [<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p>上面最后一个表达式之所以会报错，是因为<code>x</code>用到默认值<code>y</code>时，<code>y</code>还没有声明。</p><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>解构不仅可以用于数组，还可以用于对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo <span class="comment">// "aaa"</span></span><br><span class="line">bar <span class="comment">// "bbb"</span></span><br></pre></td></tr></table></figure><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo <span class="comment">// "aaa"</span></span><br><span class="line">bar <span class="comment">// "bbb"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于<code>undefined</code>。</p><p>如果变量名与属性名不一致，必须写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">'hello'</span>, <span class="attr">last</span>: <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f <span class="comment">// 'hello'</span></span><br><span class="line">l <span class="comment">// 'world'</span></span><br></pre></td></tr></table></figure><p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br></pre></td></tr></table></figure><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p><p>注意，采用这种写法时，变量的声明和赋值是一体的。对于<code>let</code>和<code>const</code>来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo;</span><br><span class="line"><span class="keyword">let</span> &#123;foo&#125; = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;; <span class="comment">// SyntaxError: Duplicate declaration "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baz;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">bar</span>: baz&#125; = &#123;<span class="attr">bar</span>: <span class="number">1</span>&#125;; <span class="comment">// SyntaxError: Duplicate declaration "baz"</span></span><br></pre></td></tr></table></figure><p>上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为<code>var</code>命令允许重新声明，所以这个错误只会在使用<code>let</code>和<code>const</code>命令时出现。如果没有第二个<code>let</code>命令，上面的代码就不会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo;</span><br><span class="line">(&#123;foo&#125; = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;); <span class="comment">// 成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baz;</span><br><span class="line">(&#123;<span class="attr">bar</span>: baz&#125; = &#123;<span class="attr">bar</span>: <span class="number">1</span>&#125;); <span class="comment">// 成功</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>let</code>命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。</p><p>和数组一样，解构也可以用于嵌套结构的对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br></pre></td></tr></table></figure><p>注意，这时<code>p</code>是模式，不是变量，因此不会被赋值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line <span class="comment">// 1</span></span><br><span class="line">loc  <span class="comment">// error: loc is undefined</span></span><br><span class="line">start <span class="comment">// error: start is undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不会被赋值。</p><p>下面是嵌套赋值的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line">(&#123; <span class="attr">foo</span>: obj.prop, <span class="attr">bar</span>: arr[<span class="number">0</span>] &#125; = &#123; <span class="attr">foo</span>: <span class="number">123</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">obj <span class="comment">// &#123;prop:123&#125;</span></span><br><span class="line">arr <span class="comment">// [true]</span></span><br></pre></td></tr></table></figure><p>对象的解构也可以指定默认值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>:y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>:y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</span><br><span class="line">msg <span class="comment">// "Something went wrong"</span></span><br></pre></td></tr></table></figure><p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>x</code>属性等于<code>null</code>，就不严格相等于<code>undefined</code>，导致默认值不会生效。</p><p>如果解构失败，变量的值等于<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;foo&#125; = &#123;<span class="attr">bar</span>: <span class="string">'baz'</span>&#125;;</span><br><span class="line">foo <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">'baz'</span>&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，等号左边对象的<code>foo</code>属性，对应一个子对象。该子对象的<code>bar</code>属性，解构时会报错。原因很简单，因为<code>foo</code>这时等于<code>undefined</code>，再取子属性就会报错，请看下面的代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _tmp = &#123;<span class="attr">baz</span>: <span class="string">'baz'</span>&#125;;</span><br><span class="line">_tmp.foo.bar <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure><p>上面代码的写法会报错，因为JavaScript引擎会将<code>{x}</code>理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p><p>解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p><p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br></pre></td></tr></table></figure><p>上面代码将<code>Math</code>对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码对数组进行对象结构。数组<code>arr</code>的<code>0</code>键对应的值是<code>1</code>，<code>[arr.length - 1]</code>就是<code>2</code>键，对应的值是<code>3</code>。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》一章。</p><h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a <span class="comment">// "h"</span></span><br><span class="line">b <span class="comment">// "e"</span></span><br><span class="line">c <span class="comment">// "l"</span></span><br><span class="line">d <span class="comment">// "l"</span></span><br><span class="line">e <span class="comment">// "o"</span></span><br></pre></td></tr></table></figure><p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p><p>解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><p>函数的参数也可以使用解构赋值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。</p><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">// [ 3, 7 ]</span></span><br></pre></td></tr></table></figure><p>函数参数的解构也可以使用默认值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>move</code>的参数是一个对象，通过对这个对象进行解构，得到变量<code>x</code>和<code>y</code>的值。如果解构失败，<code>x</code>和<code>y</code>等于默认值。</p><p>注意，下面的写法会得到不一样的结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码是为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值，所以会得到与前一种写法不同的结果。</p><p><code>undefined</code>就会触发函数参数的默认值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">'yes'</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [ 1, 'yes', 3 ]</span></span><br></pre></td></tr></table></figure><h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p><p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p><p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p><h2 id="不能使用原括号的情况"><a href="#不能使用原括号的情况" class="headerlink" title="不能使用原括号的情况"></a>不能使用原括号的情况</h2><p>以下三种解构赋值不得使用圆括号。</p><p>（1）变量声明语句中，不能带有圆括号。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="keyword">var</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><p>上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p><p>（2）函数参数中，模式不能带有圆括号。</p><p>函数参数也属于变量声明，因此不能带有圆括号。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br></pre></td></tr></table></figure><p>（3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>上面代码将整个模式放在圆括号之中，导致报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure><p>上面代码将嵌套模式的一层，放在圆括号之中，导致报错。</p><h2 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h2><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>变量的解构赋值用途很多。</p><p><strong>（1）交换变量的值</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p><p><strong>（2）从函数返回多个值</strong></p><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><p><strong>（3）函数参数的定义</strong></p><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>（4）提取JSON数据</strong></p><p>解构赋值对提取JSON对象中的数据，尤其有用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure><p>上面代码可以快速提取JSON数据的值。</p><p><strong>（5）函数参数的默认值</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... more config</span></span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p><p><strong>（6）遍历Map结构</strong></p><p>任何部署了Iterator接口的对象，都可以用<code>for...of</code>循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（7）输入模块的指定方法</strong></p><p>加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure><h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><p>ES6加强了对Unicode的支持，并且扩展了字符串对象</p><h2 id="字符的Unicode表示法"><a href="#字符的Unicode表示法" class="headerlink" title="字符的Unicode表示法"></a>字符的Unicode表示法</h2><p>JavaScript允许采用<code>\uxxxx</code>形式表示一个字符，其中“xxxx”表示字符的码点。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"\u0061"</span></span><br><span class="line"><span class="comment">// "a"</span></span><br></pre></td></tr></table></figure><p>但是，这种表示法只限于<code>\u0000</code>——<code>\uFFFF</code>之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"\uD842\uDFB7"</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u20BB7"</span></span><br><span class="line"><span class="comment">// " 7"</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果直接在“\u”后面跟上超过<code>0xFFFF</code>的数值（比如<code>\u20BB7</code>），JavaScript会理解成“\u20BB+7”。由于<code>\u20BB</code>是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。</p><p>ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"</span></span><br><span class="line"><span class="comment">// "ABC"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = <span class="number">123</span>;</span><br><span class="line">hell\u&#123;<span class="number">6</span>F&#125; <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u&#123;1F680&#125;'</span> === <span class="string">'\uD83D\uDE80'</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，最后一个例子表明，大括号表示法与四字节的UTF-16编码是等价的。</p><p>有了这种表示法之后，JavaScript共有6种方法可以表示一个字符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'\z'</span> === <span class="string">'z'</span>  <span class="comment">// true</span></span><br><span class="line"><span class="string">'\172'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\x7A'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u007A'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u&#123;7A&#125;'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Proxy和Reflect"><a href="#Proxy和Reflect" class="headerlink" title="Proxy和Reflect"></a>Proxy和Reflect</h2><h3 id="Proxy概述"><a href="#Proxy概述" class="headerlink" title="Proxy概述"></a>Proxy概述</h3><p>Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p>Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function (target, key, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function (target, key, value, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.count = <span class="number">1</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line">++obj.count</span><br><span class="line"><span class="comment">//  getting count!</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line"><span class="comment">//  2</span></span><br></pre></td></tr></table></figure><p>上面代码说明，Proxy实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p><p>ES6原生提供Proxy构造函数，用来生成Proxy实例。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p>Proxy对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个Proxy实例，target参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p><p>下面是另一个拦截读取属性行为的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, property) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time <span class="comment">// 35</span></span><br><span class="line">proxy.name <span class="comment">// 35</span></span><br><span class="line">proxy.title <span class="comment">// 35</span></span><br></pre></td></tr></table></figure><p>上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p><p>注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p><p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.a = <span class="string">'b'</span>;</span><br><span class="line">target.a <span class="comment">// "b"</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>handeler</code>就等同于访问<code>target</code>。</p><p>一个技巧是将Proxy对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123; <span class="attr">proxy</span>: <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler) &#125;;</span><br></pre></td></tr></table></figure><p>Proxy实例也可以作为其他对象的原型对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, property) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj.time <span class="comment">// 35</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p><p>同一个拦截器函数，可以设置拦截多个操作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">'prototype'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span>(<span class="params">target, thisBinding, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">value</span>: args[<span class="number">1</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line">fproxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> fproxy(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// &#123;value: 2&#125;</span></span><br><span class="line">fproxy.prototype === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line">fproxy.foo <span class="comment">// "Hello, foo"</span></span><br></pre></td></tr></table></figure><p>下面是Proxy支持的拦截操作一览。</p><p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p><p><strong>（1）get(target, propKey, receiver)</strong></p><p>拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</p><p>最后一个参数<code>receiver</code>是一个对象，可选，参见下面<code>Reflect.get</code>的部分。</p><p><strong>（2）set(target, propKey, value, receiver)</strong></p><p>拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</p><p><strong>（3）has(target, propKey)</strong></p><p>拦截<code>propKey in proxy</code>的操作，以及对象的<code>hasOwnProperty</code>方法，返回一个布尔值。</p><p><strong>（4）deleteProperty(target, propKey)</strong></p><p>拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</p><p><strong>（5）ownKeys(target)</strong></p><p>拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>，返回一个数组。该方法返回对象所有自身的属性，而<code>Object.keys()</code>仅返回对象可遍历的属性。</p><p><strong>（6）getOwnPropertyDescriptor(target, propKey)</strong></p><p>拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</p><p><strong>（7）defineProperty(target, propKey, propDesc)</strong></p><p>拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</p><p><strong>（8）preventExtensions(target)</strong></p><p>拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</p><p><strong>（9）getPrototypeOf(target)</strong></p><p>拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</p><p><strong>（10）isExtensible(target)</strong></p><p>拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</p><p><strong>（11）setPrototypeOf(target, proto)</strong></p><p>拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。</p><p>如果目标对象是函数，那么还有两种额外操作可以拦截。</p><p><strong>（12）apply(target, object, args)</strong></p><p>拦截Proxy实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</p><p><strong>（13）construct(target, args)</strong></p><p>拦截Proxy实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="了解-Promise-吗？"><a href="#了解-Promise-吗？" class="headerlink" title="了解 Promise 吗？"></a>了解 Promise 吗？</h2><p>JS异步编程的一种解决方案，比传统的解决方案————回调函数和事件————更合理更强大。</p><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果</p><ul><li><p>从语法上讲，promise是一个对象，从它可以获取异步操作的消息</p></li><li><p>从本意上讲，它是承诺，承诺过一段时间会给一个结果</p></li><li><p>promise有三种状态</p><ul><li>pending（等待态）</li><li>fulfiled（成功态）</li><li>rejected（失败态）</li><li>状态一旦改变，就不会再变。</li><li>创造promise实例后，会立即执行</li></ul></li></ul><ul><li><h3 id="Promise的两个特点"><a href="#Promise的两个特点" class="headerlink" title="Promise的两个特点"></a>Promise的两个特点</h3><ul><li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，英文意思就是“承诺”，表示其他手段无法改变</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。这与事件Event完全不同，事件的特点就是，如果你错过了它，再去监听，是得不到结果的。</li></ul></li><li><h3 id="Promise的缺点"><a href="#Promise的缺点" class="headerlink" title="Promise的缺点"></a>Promise的缺点</h3><ul><li>无法取消Promise，一旦新建就会立即执行，无法中途取消</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部</li><li>当处于Pending状态时，无法得知目前进展到哪一个阶段</li></ul></li><li><p>如果某些事件不断反复发生，一般来说，使用stream模式是比部署Promise更好的选择</p></li><li><h3 id="promise的写法"><a href="#promise的写法" class="headerlink" title="promise的写法"></a>promise的写法</h3><p>new Promise(请求1)</p><p>​ .then(请求2,(请求结果1))</p><p>​ .then(请求3,(请求结果2))</p><p>​ .then(请求4,(请求结果3))</p><p>​ .then(请求5,(请求结果4))</p><p>​ .then(请求6,(请求结果5))</p><p>​ .catch(处理异常(异常信息))</p></li><li><h3 id="Promise的API"><a href="#Promise的API" class="headerlink" title="Promise的API"></a>Promise的API</h3></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据传入的value不同而返回不同的值，如果传入的是对象的话则会返回一个状态为成功的promise对象</span></span><br><span class="line"></span><br><span class="line">promise.resolve(value)</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据传入的value不同而返回不同的值，如果传入的是对象的话则会返回一个状态为失败的promise对象</span></span><br><span class="line"></span><br><span class="line">promise.reject(value)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then()</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch()</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race()</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all()</span><br></pre></td></tr></table></figure><h2 id="Promise-解决的痛点是什么？"><a href="#Promise-解决的痛点是什么？" class="headerlink" title="Promise 解决的痛点是什么？"></a>Promise 解决的痛点是什么？</h2><ul><li>回调地狱，代码难以维护，常常第一个的函数的输出是第二个函数的输入这种现象</li><li>promise可以支持多个并发的请求，获取并发请求中的数据</li><li>promise可以解决可读性的问题，异步的嵌套带来的可读性的问题</li><li>promise可以解决信任问题</li></ul><h2 id="Promise-解决的痛点还有其他方法可以解决吗？如果有，请列举。"><a href="#Promise-解决的痛点还有其他方法可以解决吗？如果有，请列举。" class="headerlink" title="Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。"></a>Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。</h2><ul><li>setTimeout、事件监听、回调函数、Generator函数、async/await</li></ul><h2 id="Promise-如何使用？"><a href="#Promise-如何使用？" class="headerlink" title="Promise 如何使用？"></a>Promise 如何使用？</h2><ul><li><p>创造一个Promise实例</p></li><li><p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数</p></li><li><p>可用Promise的try和catch方法预防异常</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//做异步操作</span></span><br><span class="line"></span><br><span class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">' 执行完成 '</span>);</span><br><span class="line"></span><br><span class="line">	resolve(<span class="string">' 成功 '</span>);</span><br><span class="line"></span><br><span class="line">	&#125;,<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>Promise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：<ul><li>resolve：异步操作执行成功后的回调函数</li><li>reject：异步操作执行失败后的回调函数</li></ul></li></ul><h2 id="Promise-常用的方法有哪些？它们的作用是什么？"><a href="#Promise-常用的方法有哪些？它们的作用是什么？" class="headerlink" title="Promise 常用的方法有哪些？它们的作用是什么？"></a>Promise 常用的方法有哪些？它们的作用是什么？</h2><ul><li>Promise.resolve(value)<ul><li>类方法，该方法返回一个以value值解析后的Promise对象</li><li>如果这个值是个thenable（即带有then方法），返回</li></ul></li></ul><h2 id="Promise-在事件循环中的执行过程是怎样的？"><a href="#Promise-在事件循环中的执行过程是怎样的？" class="headerlink" title="Promise 在事件循环中的执行过程是怎样的？"></a>Promise 在事件循环中的执行过程是怎样的？</h2><p>promise是事件循环中的微任务（micotask），在每次事情循环中会先清空了微任务的队列</p><h2 id="Promise-的业界实现都有哪些？"><a href="#Promise-的业界实现都有哪些？" class="headerlink" title="Promise 的业界实现都有哪些？"></a>Promise 的业界实现都有哪些？</h2><ul><li>Q</li><li>bluebird</li></ul><h2 id="能不能手写一个-Promise-的-polyfill"><a href="#能不能手写一个-Promise-的-polyfill" class="headerlink" title="能不能手写一个 Promise 的 polyfill"></a>能不能手写一个 Promise 的 polyfill</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span>;</span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">"resolved"</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">    that.state = PENDING;</span><br><span class="line">    that.value = <span class="literal">null</span>;</span><br><span class="line">    that.resolvedCallbacks = [];</span><br><span class="line">    that.rejectedCallbacks = [];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//判断传入的值是否为Promise类型</span></span><br><span class="line">        <span class="keyword">if</span>( value <span class="keyword">instanceof</span> MyPromise)&#123;</span><br><span class="line">            <span class="keyword">return</span> value.then(resolve,reject)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为了保证函数的执行顺序，需要将两个函数体代码使用setTimeout包裹起来</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//只有等待状态才可以改变状态</span></span><br><span class="line">            <span class="keyword">if</span>(that.state == PENDING)&#123;</span><br><span class="line">                <span class="comment">//将当前状态更改为对应状态，并且将传入的值赋值给value</span></span><br><span class="line">                that.state = RESOLVED;</span><br><span class="line">                that.value = value;</span><br><span class="line">                <span class="comment">//遍历回调函数组并执行</span></span><br><span class="line">                that.resolvedCallbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span> cb(that.value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(that.state == PENDING)&#123;</span><br><span class="line">                that.state == REJECTED;</span><br><span class="line">                that.value == value;</span><br><span class="line">                that.rejectedCallbacks.map( <span class="function"><span class="params">cb</span> =&gt;</span> cb(that.value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fn(resolve,reject)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//判断两个参数是否为函数类型，这两个参数是可选参数</span></span><br><span class="line">    <span class="comment">//当参数不是函数类型时，需要创建一个函数赋值给对应的参数，同时也实现了透传</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled:<span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected:<span class="function"><span class="params">r</span> =&gt;</span> &#123;<span class="keyword">throw</span> r&#125;;</span><br><span class="line">    <span class="keyword">if</span>(that.state === PENDING)&#123;</span><br><span class="line">        <span class="comment">//返回了一个新的Promise对象，并在Promise中传入一个函数</span></span><br><span class="line">        <span class="comment">//规范规定，执行onFulfilled 或者 onRejected 函数会返回一个x，并且执行Promise解决过程，这是为了不同的Promise都可以兼容使用，比如JQuery的 Promise 能兼容 ES6  的Promise</span></span><br><span class="line">        <span class="keyword">return</span><span class="function">(<span class="params">promise2 = <span class="keyword">new</span> MyPromise((resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            that.rejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">const</span> x = onFulfilled(that.value)</span><br><span class="line">                    resolutionProcedure(promise2,x,resolve,reject)</span><br><span class="line">                &#125;<span class="keyword">catch</span>(r)&#123;</span><br><span class="line">                    reject(r)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            that.rejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> x = onRejected(that.value)</span><br><span class="line">                        resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">                        reject(r)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(that.state === RESOLVED)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function">(<span class="params">promise2 = <span class="keyword">new</span> MyPromise((resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> x = onFulfilled(that.value)</span><br><span class="line">                        resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">                        reject(r)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(that.state === REJECTED)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function">(<span class="params">promise2 = <span class="keyword">new</span> MyPromise((resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> x = onRejected(that.value);</span><br><span class="line">                    resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">                &#125;<span class="keyword">catch</span>(r)&#123;</span><br><span class="line">                    reject(r)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                x.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                        resolutionProcedure(promise2, value, resolve, reject)</span><br><span class="line">                &#125;, reject)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个实例 </span></span><br><span class="line">    <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">1</span>)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><h2 id="什么是axios"><a href="#什么是axios" class="headerlink" title="什么是axios"></a>什么是axios</h2><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端</p><h3 id="执行GET请求"><a href="#执行GET请求" class="headerlink" title="执行GET请求"></a>执行GET请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向具有指定ID的用户发出请求</span></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 也可以通过 params 对象传递参数</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">params: &#123;</span><br><span class="line">	ID: <span class="number">12345</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="执行POST请求"><a href="#执行POST请求" class="headerlink" title="执行POST请求"></a>执行POST请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="执行多个并发请求"><a href="#执行多个并发请求" class="headerlink" title="执行多个并发请求"></a>执行多个并发请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> axios.get(<span class="string">'/user/12345'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> axios.get(<span class="string">'/user/12345/permissions'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">.then(axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct, perms</span>) </span>&#123;</span><br><span class="line"><span class="comment">//两个请求现已完成</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h2 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h2><p>可以通过相关配置传递给axios来进行请求</p><h3 id="axios-config"><a href="#axios-config" class="headerlink" title="axios(config)"></a>axios(config)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送一个 POST 请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    url: <span class="string">'/user/12345'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="axios-url-config"><a href="#axios-url-config" class="headerlink" title="axios(url[,config])"></a>axios(url[,config])</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送一个 GET 请求 (GET请求是默认请求模式)</span></span><br><span class="line">axios(<span class="string">'/user/12345'</span>);</span><br></pre></td></tr></table></figure><h3 id="请求方法别名"><a href="#请求方法别名" class="headerlink" title="请求方法别名"></a>请求方法别名</h3><p>为了方便起见,已经为所有支持的请求方法提供了别名</p><ul><li>axios.request (config)</li><li>axios.get（url [，config]）</li><li>axios.delete（url [，config]）</li><li>axios.head（url [，config]）</li><li>axios.post（url [，data [，config]]）</li><li>axios.put（url [，data [，config]]）</li><li>axios.patch（url [，data [，config]]）</li></ul><p>注意:当使用别名方法时,不需要在config中指定url,method和data属性</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>帮助函数处理并发请求</p><ul><li>axios.all（iterable）</li><li>axios.spread（callback）</li></ul><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>使用自定义配置创建axios的新实例</p><p>axios.create（[config]）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line">    timeout: <span class="number">1000</span>,</span><br><span class="line">    headers: &#123;<span class="string">'X-Custom-Header'</span>: <span class="string">'foobar'</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul><li>axios＃request（config）</li><li>axios＃get（url [，config]）</li><li>axios＃delete（url [，config]）</li><li>axios＃head（url [，config]）</li><li>axios＃post（url [，data [，config]]）</li><li>axios＃put（url [，data [，config]]）</li><li>axios＃patch（url [，data [，config]]）</li></ul><h3 id="请求拦截"><a href="#请求拦截" class="headerlink" title="请求拦截"></a>请求拦截</h3><h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h1><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><ul><li>ReferenceError(引用错误)：代表当一个不存在变量被引用时发生的错误，在作用域中找不到</li><li>TypeError(类型错误)：在作用域中找到了但是做了它不可能做的事情</li></ul><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Emmet</title>
    <url>/2019/05/19/Emmet%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><h1 id="html缩写"><a href="#html缩写" class="headerlink" title="html缩写"></a>html缩写</h1><h2 id="id（-）-class（-）"><a href="#id（-）-class（-）" class="headerlink" title="id（#）,class（.）"></a>id（#）,class（.）</h2><p>id指令: #</p><p>class指令: .</p><ul><li>div#test</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>div.test<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="子节点（-gt-），兄弟节点（-），上级节点（-）"><a href="#子节点（-gt-），兄弟节点（-），上级节点（-）" class="headerlink" title="子节点（&gt;），兄弟节点（+），上级节点（^）"></a>子节点（&gt;），兄弟节点（+），上级节点（^）</h2><p>子节点指令: &gt;</p><p>兄弟节点指令: +</p><p>上级节点: ^</p><ul><li>div&gt;ul&gt;li&gt;p</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>div+ul+p</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>div&gt;ul&gt;li^div</p><p>(这里的^是接在li后面所以在li的上一级，与ul成了兄弟关系,当然两个^^就是上上级）</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="重复（-）"><a href="#重复（-）" class="headerlink" title="重复（*）"></a>重复（*）</h2><p>重复指令：*</p><p>div<em>5（</em>号后面添加数字表示重复的元素个数）<br></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><h2 id="分组（-）"><a href="#分组（-）" class="headerlink" title="分组（()）"></a>分组（()）</h2><p>分组指令：()</p><ul><li>div&gt;(ul&gt;li&gt;a)+div&gt;p<br>（括号里面的内容为一个代码块，表示与括号内部嵌套和外面的的层级无关）</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解释：这里如果不加括号的话，猜想下，a+div这样div就是和a是兄弟关系了，会包含在li里面。懂了吧哈哈<br></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span></span></span><br></pre></td></tr></table></figure><p></p><h2 id="属性（-attr-）——id，class都有怎么能少了属性呢"><a href="#属性（-attr-）——id，class都有怎么能少了属性呢" class="headerlink" title="属性（[attr]）——id，class都有怎么能少了属性呢"></a>属性（[attr]）——id，class都有怎么能少了属性呢</h2><p>属性指令：[]</p><ul><li>a[href=’###’ name=‘xiaoA’]</li></ul><p>（中括号内填写属性键值对的形式，并且空格隔开）</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"###"</span> <span class="attr">name</span>=<span class="string">"xiaoA"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编号"><a href="#编号" class="headerlink" title="编号  $"></a>编号 $</h2><ul><li>ul&gt;li.test$*3</li></ul><p><em>（$代表一位数，后面更上</em>数字就代表从1递增到填写的数字）</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"test1"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"test2"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"test3"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>一个$ 代表一位数，<br>如果想自定义从几开始递增的话就利用：$@+数字数字</p><ul><li>ul&gt;li.test$@33</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"test33"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"test34"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"test35"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="文本（-）"><a href="#文本（-）" class="headerlink" title="文本（{}）"></a>文本（{}）</h2><p>文本指令：{}</p><ul><li><p>ul&gt;li.test$*3{测试$}</p><p>（{里面填写内容，可以和$一起组合使用哦}）</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"test1"</span>&gt;</span>测试1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"test2"</span>&gt;</span>测试2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"test3"</span>&gt;</span>测试3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="隐式标签"><a href="#隐式标签" class="headerlink" title="隐式标签"></a>隐式标签</h2><p>这个标签没有指令，而是部分标签可以不使用输入标签，直接输入指令，即可识别父类标签。</p><p>例如：.test<br></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><ul><li>ul&gt;.test$*3</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"test1"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"test2"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"test3"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>select&gt;.test$*5</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">class</span>=<span class="string">"test1"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">class</span>=<span class="string">"test2"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">class</span>=<span class="string">"test3"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">class</span>=<span class="string">"test4"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">class</span>=<span class="string">"test5"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>等等…<br>隐私标签有如下几个：</p><ul><li>li：用于 ul 和 ol 中</li><li>tr：用于 table、tbody、thead 和 tfoot 中</li><li>td：用于 tr 中</li><li>option：用于 select 和 optgroup 中</li></ul><h1 id="CSS缩写"><a href="#CSS缩写" class="headerlink" title="CSS缩写"></a>CSS缩写</h1><h2 id="值"><a href="#值" class="headerlink" title="值"></a><strong>值</strong></h2><p>比如要定义元素的宽度，只需输入w100，即可生成</p><ol><li><code>`</code>css<br>width: 100px;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   * width:30px&#x3D;&#x3D;&gt;w30+tab</span><br><span class="line">   * Height:30px&#x3D;&#x3D;&gt;h30+tab</span><br><span class="line">   * Margin:30px&#x3D;&#x3D;&gt;mg30+tab</span><br><span class="line">   * Padding:30px&#x3D;&#x3D;&gt; pd30+tab</span><br><span class="line">   * Line-height:12px&#x3D;&#x3D;&gt;lh12px+tab</span><br><span class="line">   * Background&#x3D;&#x3D;&gt;bg+tab</span><br><span class="line">   * Background-color&#x3D;&#x3D;&gt;bgc+tab</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">除了px，也可以生成其他单位，比如输入h10p+m5e，结果如下： </span><br><span class="line"></span><br><span class="line">1. &#96;&#96;&#96;css</span><br><span class="line">   1. height: 10%;  </span><br><span class="line">   2. margin: 5em;</span><br></pre></td></tr></table></figure></li></ol><p>单位别名列表：</p><ul><li>p 表示%</li><li>e 表示 em</li><li>x 表示 ex</li></ul><h2 id="附加属性"><a href="#附加属性" class="headerlink" title="附加属性"></a><strong>附加属性</strong></h2><p>可能你之前已经了解了一些缩写，比如 @f，可以生成：</p><ol><li><code>`</code>css<ol><li>@font-face {</li><li>font-family:;</li><li>src:url();</li><li>}<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一些其他的属性，比如background-image、border-radius、font、@font-face,text-outline、text-shadow等额外的选项，可以通过“+”符号来生成，比如输入@f+，将生成： </span><br><span class="line"></span><br><span class="line">1. &#96;&#96;&#96;css</span><br><span class="line">   1. @font-face &#123;  </span><br><span class="line">   2.   font-family: &#39;FontName&#39;;  </span><br><span class="line">   3.   src: url(&#39;FileName.eot&#39;);  </span><br><span class="line">   4.   src: url(&#39;FileName.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),  </span><br><span class="line">   5. ​     url(&#39;FileName.woff&#39;) format(&#39;woff&#39;),  </span><br><span class="line">   6. ​     url(&#39;FileName.ttf&#39;) format(&#39;truetype&#39;),  </span><br><span class="line">   7. ​     url(&#39;FileName.svg#FontName&#39;) format(&#39;svg&#39;);  </span><br><span class="line">   8.   font-style: normal;  </span><br><span class="line">   9.   font-weight: normal;  </span><br><span class="line">   10. &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a><strong>模糊匹配</strong></h2><p>如果有些缩写你拿不准，Emmet会根据你的输入内容匹配最接近的语法，比如输入ov:h、ov-h、ovh和oh，生成的代码是相同的：</p><ol><li><code>`</code>css<br>overflow: hidden;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">## **供应商前缀** </span><br><span class="line"></span><br><span class="line">如果输入非W3C标准的CSS属性，Emmet会自动加上供应商前缀，比如输入trs，则会生成： </span><br><span class="line"></span><br><span class="line">1. &#96;&#96;&#96;css</span><br><span class="line">   1. -webkit-transform: ;  </span><br><span class="line">   2. -moz-transform: ;  </span><br><span class="line">   3. -ms-transform: ;  </span><br><span class="line">   4. -o-transform: ;  </span><br><span class="line">   5. transform: ;</span><br></pre></td></tr></table></figure></li></ol><p>你也可以在任意属性前加上“-”符号，也可以为该属性加上前缀。比如输入-super-foo：</p><ol><li><code>`</code>css<ol><li>-webkit-super-foo: ;</li><li>-moz-super-foo: ;</li><li>-ms-super-foo: ;</li><li>-o-super-foo: ;</li><li>super-foo: ;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   如果不希望加上所有前缀，可以使用缩写来指定，比如-wm-trf表示只加上-webkit和-moz前缀：</span><br><span class="line"></span><br><span class="line">1. &#96;&#96;&#96;css</span><br><span class="line">   1. -webkit-transform: ;  </span><br><span class="line">   2. -moz-transform: ;  </span><br><span class="line">   3. transform: ;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>前缀缩写如下：</p><ul><li>w 表示 -webkit-</li><li>m 表示 -moz-</li><li>s 表示 -ms-</li><li>o 表示 -o-</li></ul><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a><strong>渐变</strong></h2><p>输入lg(left, #fff 50%, #000)，会生成如下代码：</p><ol><li><code>`</code>css<ol><li>background-image: -webkit-gradient(linear, 0 0, 100% 0, color-stop(0.5, #fff), to(#000));</li><li>background-image: -webkit-linear-gradient(left, #fff 50%, #000);</li><li>background-image: -moz-linear-gradient(left, #fff 50%, #000);</li><li>background-image: -o-linear-gradient(left, #fff 50%, #000);</li><li>background-image: linear-gradient(left, #fff 50%, #000);<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">## Tips</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 供给带有单位的值</span><br><span class="line"></span><br><span class="line">默认地，当展开带有整数值的缩写时，Emmet 输出会带有 &#96;px&#96; 单位：&#96;m10&#96; →&#96;margin: 10px;&#96;。若是展开的缩写带有浮点娄，输出将带有 &#96;em&#96; 单位：&#96;m1.5&#96; →&#96;margin: 1.5em;&#96;。不过也可以经由过程在值的后面放置随便率性的字母来明白指定单位： &#96;m1.5ex&#96; → &#96;margin: 1.5ex;&#96;， &#96;m10foo&#96; → &#96;margin: 10foo;&#96;。</span><br><span class="line"></span><br><span class="line">若是明白定义了单位，不须要应用连字符分隔各个值： &#96;m10ex20em&#96; →&#96;margin: 10ex 20em;&#96;， &#96;m10ex-5&#96; → &#96;margin: 10ex -5px;&#96;。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 值别号</span><br><span class="line"></span><br><span class="line">Emmet 有几个常用的别号：</span><br><span class="line"></span><br><span class="line">- &#96;p&#96; → &#96;％&#96;</span><br><span class="line">- &#96;e&#96; → &#96;em&#96;</span><br><span class="line">- &#96;x&#96; → &#96;ex&#96;</span><br><span class="line"></span><br><span class="line">可以用这些别号来庖代完全的单位：[·](http:&#x2F;&#x2F;caibaojian.com&#x2F;emmet-doc-3.html)</span><br><span class="line"></span><br><span class="line">- &#96;w100p&#96; → &#96;width: 100％&#96;</span><br><span class="line">- &#96;m10p30e5x&#96; → &#96;margin: 10％ 30em 5ex&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 色彩值</span><br><span class="line"></span><br><span class="line">Emmet 付出16进制地色彩值，例如： &#96;c＃3&#96; → &#96;color: ＃333;&#96;。&#96;＃&#96; 符号是值的分隔符，所以不须要应用连字符做分隔。例如 &#96;bd5＃0s&#96; 展开成 &#96;border: 5px ＃000 solid&#96;: 。&#96;5&#96; 被从色彩值的 &#96;＃&#96; 到 &#96;s&#96; （&#96;solid &#96;的别号）从色彩平分隔出来，因为 &#96;s 不是16进制的字符，不须要用 &#96;&#96;-&#96; 分隔符。</span><br><span class="line"></span><br><span class="line">可以以 1个、2个、3个或者6个数字的情势书写色彩值：</span><br><span class="line"></span><br><span class="line">- &#96;＃1&#96; → &#96;＃111111&#96;</span><br><span class="line">- &#96;＃e0&#96; → &#96;＃e0e0e0&#96;</span><br><span class="line">- &#96;＃fc0&#96; → &#96;＃ffcc00&#96;</span><br><span class="line"></span><br><span class="line">当 &#96;css.color.short&#96; 引用 可用时（默认），类似 &#96;＃ffcc00&#96; 如许的值会主动简化成 &#96;＃fc0&#96;。也可以按照 &#96;css.color.case&#96; 引用主动改变大小写。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 无单位的值</span><br><span class="line"></span><br><span class="line">一些 CSS 属性被定义为无单位，例如 &#96;lh2&#96; → &#96;line-height: 2;&#96;，&#96;fw400&#96; → &#96;font-weight: 400;&#96;。</span><br><span class="line"></span><br><span class="line">这些值是: &#96;&quot;&quot;z-index&#96;、 &#96;line-height&#96;、 &#96;opacity&#96; 和 &#96;font-weight&#96; ，可以哄骗 &#96;css.unitlessProperties&#96; 引用来覆盖它们。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### !important 润饰符</span><br><span class="line"></span><br><span class="line">可以在任何 CSS 缩写后面添加 &#96;!&#96; 下标来获得 &#96;!important&#96; 值：</span><br></pre></td></tr></table></figure>p!+m10e!<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">将生成</span><br></pre></td></tr></table></figure>padding: !important;<br>margin: 10em !important;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">### Vendor 前缀</span><br><span class="line"></span><br><span class="line">CSS3 的新特点为 [web](http:&#x2F;&#x2F;caibaojian.com&#x2F;c&#x2F;web) 法度员带来了福音：很少的几行代码就能完成几年前近乎不成能实现的任务。但同时这些特点对带来了疾苦：必须为不合的浏览器编写多个雷同的属性。</span><br><span class="line"></span><br><span class="line">Emmet 的 CSS 解析器有一个很奇妙的特点，可以明显进步编写 CSS3 的体验。每次在 CSS 属性或缩写前添加连字符，Emmet 就主动为每个属性创建带有 vendor 前缀的副本。例如，&#96;-bdrs&#96; 缩写将展开成：</span><br></pre></td></tr></table></figure>//code from <a href="http://caibaojian.com/emmet-doc-3.html" target="_blank" rel="noopener">http://caibaojian.com/emmet-doc-3.html</a><br>-webkit-border-radius: ;<br>-moz-border-radius: ;<br>border-radius: ;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">此外，在支撑 tabstop 的编辑器（例如 Eclipse、 Sublime Text 2、 Espresso 等）中，Emmet 将建树值占位符，法度员可以输入属性值并主动放到全部生成的属性中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 它如何工作？</span><br><span class="line"></span><br><span class="line">展开前面带有连字符的缩写时，Emmet 删除连字符并在 &#96;snippets.json&#96; 查找残剩的缩写的片段定义。例如 &#96;-bdrs&#96; 缩写将会在 &#96;snippet.json&#96; 中查找 &#96;bdrs&#96; 定义，定义的内容如下：</span><br></pre></td></tr></table></figure>“bdrs”: “border-radius:|;”<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">也就是说 &#96;bdrs&#96; 将被展开成 &#96;border-radius&#96; 属性。若是定义没有找到，缩写本身将被当成 CSS 属性名。</span><br><span class="line"></span><br><span class="line">经过 CSS 解析器策画出的属性将被输出，它将查找特定的在特定的 *vendor 分类*是否呈现。这些分类定义设置中的 &#96;css.&#123;vendor&#125;Properties&#96; 分支。 &#96;&#123;vendor&#125;&#96; 是浏览器的 vendor 前缀，例如 &#96;webkit&#96;、 &#96;moz&#96; 等。</span><br><span class="line"></span><br><span class="line">若是扩大属性在这些分类中被找到，它们的 vendor 前缀将用作前导属性。不然，所有的前缀将被应用。</span><br><span class="line"></span><br><span class="line">例如，&#96;border-radius&#96; 被定义在 &#96;css.webkitProperties&#96; 和 &#96;css.mozProperties &#96;中，所以这个属性的输出将带有 &#96;webkit&#96; 和 &#96;moz&#96; 前缀。另一种景象，&#96;foo&#96; 属性没有定义在任何 vendor 分类中，所以在展开 &#96;-foo&#96; 缩写时，将输出所有可用的前缀：： &#96;webkit&#96;， &#96;moz&#96;， &#96;ms&#96; and &#96;o&#96;.。它对眼下所实现的那些前沿的 CSS 属性希罕有效。</span><br><span class="line"></span><br><span class="line">假设 Google Chrome 昨天方才实现了 &#96;super-foo&#96; ，而你如今就想在项目中应用它。可以应用 &#96;-super-foo&#96; 属性，展开成果如下：</span><br></pre></td></tr></table></figure>-webkit-super-foo: ;<br>-moz-super-foo: ;<br>-ms-super-foo: ;<br>-o-super-foo: ;<br>super-foo: ;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">### 默认添加前缀属性</span><br><span class="line"></span><br><span class="line">在编写 CSS 文件时，也许要查找不带有 vendor 前缀变量的 CSS3 的 “clear” 属性。这会使编写类似 &#96;-trf&#96; （&#96;trf&#96; 是 &#96;transform&#96; 的别号） 如许带有前导连字符的缩写很难堪。</span><br><span class="line"></span><br><span class="line">这也是为什么默认景象下 Emmet 会有 &#96;css.autoInsertVendorPrefixes&#96; 选项的原因。这个属性生效，所有定义在 vendor 分类中的 CSS 属性都将被主动供给匹配的 vendor 前缀变量。</span><br><span class="line"></span><br><span class="line">这意味着，无需应用连字符来为已知的 CSS 属性获取有效的前缀变量，直接展开 &#96;bdrs&#96; 或 &#96;trf&#96; 缩写就可以获得有效的 vendor 前缀属性。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 明白地 vendor 前缀</span><br><span class="line"></span><br><span class="line">有时可能会想要输出仅带有指定 vendor 前缀属性的 CSS 属性。</span><br><span class="line"></span><br><span class="line">假定想要输出仅带有 &#96;webkit&#96; 和 &#96;moz&#96; 前缀的 &#96;transform&#96; 属性，可以编写如下缩写：</span><br></pre></td></tr></table></figure>-wm-trf<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">正如所见到的那样，我们经由过程添加一个字符前缀列表对缩写略作批改。在这种景象下，添加的是 &#96;w&#96; （&#96;webkit&#96;） 和 &#96;m&#96; （&#96;moz&#96;） 前缀。Emmet 的单字母前缀如下：</span><br><span class="line"></span><br><span class="line">- &#96;w&#96;: &#96;webkit&#96;</span><br><span class="line">- &#96;m&#96;: &#96;moz&#96;</span><br><span class="line">- &#96;s&#96;: &#96;ms&#96;</span><br><span class="line">- &#96;o&#96;: &#96;o&#96;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">### 渐变</span><br><span class="line"></span><br><span class="line">编写 CSS3 特点的另一个难点是渐变。必须为多个 vendor 前缀多次反复长长地渐变定义。同时，要想覆盖所有支撑渐变的浏览器，就必须应用三种不合的注解：旧的 Webkit，当前支撑 （&#96;linear-gradient（top， ...）&#96;） 和 W3C-推荐 （&#96;linear-gradient（to bottom， ...）&#96;）。</span><br><span class="line"></span><br><span class="line">凡是，用户偏向于应用第三方 GUI 来生成渐变定义，然则在编辑器中做同样的工作会更快。</span><br><span class="line"></span><br><span class="line">Emmet 的 CSS3 渐变生成器可以或许帮你分忧：</span><br><span class="line"></span><br><span class="line">正像上方显现的那样，可以输入常规地渐变定义如 &#96;lg（...）&#96; （或 &#96;linear-gradient（...）&#96;） 函数，并算作一个缩写来展开。若是编写渐变定义来充当属性值，Emmet将解析它并应用它的名字作为新的 CSS 属性的引用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 备用值</span><br><span class="line"></span><br><span class="line">在偏爱设置中，可以使 &#96;css.gradient.fallback&#96; 选项有效，当渐变定义 &#96;background-*&#96; CSS 属性展开时，产生一个备用的 &#96;background-color &#96;CSS 属性。这个备用属性将包含来自渐变定义的第一个色彩。</span><br><span class="line"></span><br><span class="line">为个选项默认是封闭的，这是因为它所产生的 &#96;background-color&#96; 值几乎可以必然须要手动进级，以确保这个靠山的内容可读。若是确切不在乎旧浏览器，就可以打开这个选项。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">### 模糊查找</span><br><span class="line"></span><br><span class="line">若是查阅 总览表，就会发明有很多 CSS 片段要记忆。并且它们中的一项目组为了分隔逻辑变得很长。</span><br><span class="line"></span><br><span class="line">为了使 CSS 的编写更简单，Emmet 为 CSS 片段实现了模糊查找逻辑：每次输入一个未知的缩写，Emmet 老是试图找到类似的片段定义。</span><br><span class="line"></span><br><span class="line">例如，作为 &#96;ov:h&#96; （&#96;overflow: hidden;&#96;） 缩写的调换，可以输入 &#96;ov-h、&#96; &#96;ovh&#96; 或者干脆输入 &#96;oh&#96;。拜见下面的示例。演示了 &#96;bxz:cb&#96;、&#96;ovx:h&#96; 和 &#96;pos:a&#96; 片段的不合示例</span><br><span class="line"></span><br><span class="line">模糊查找只针对预定义的片段名，不支撑片段值或 CSS 属性。这个成果更好猜测和把握匹配。记住 可以创建本身的片段或重定义已存在的片段 来调剂模糊查找的体验</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># **生成Lorem ipsum文本** </span><br><span class="line"></span><br><span class="line">Lorem ipsum指一篇常用于排版设计领域的拉丁文文章，主要目的是测试文章或文字在不同字型、版型下看起来的效果。通过Emmet，你只需输入lorem 或 lipsum即可生成这些文字。还可以指定文字的个数，比如lorem10，将生成：</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">引用</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;css</span><br><span class="line">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Libero delectus.</span><br></pre></td></tr></table></figure></li></ol></li></ol><h1 id="定制"><a href="#定制" class="headerlink" title="定制"></a><strong>定制</strong></h1><p>你还可以定制Emmet插件：</p><ul><li>添加新缩写或更新现有缩写，可修改<a href="http://docs.emmet.io/customization/snippets/" target="_blank" rel="noopener">snippets.json</a>文件</li><li>更改Emmet过滤器和操作的行为，可修改<a href="http://docs.emmet.io/customization/preferences/" target="_blank" rel="noopener">preferences.json</a>文件</li><li>定义如何生成HTML或XML代码，可修改<a href="http://docs.emmet.io/customization/syntax-profiles/" target="_blank" rel="noopener">syntaxProfiles.json</a>文件</li></ul><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO使用心得</title>
    <url>/2019/05/29/HEXO-tips/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令</title>
    <url>/2019/10/17/Git%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><h1 id="命令大全"><a href="#命令大全" class="headerlink" title="命令大全"></a>命令大全</h1><h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><ul><li><p>–mixed：回退到某个版本，只保留源码，回退commit和stage信息</p></li><li><p>–soft：回退到某个版本，只回退了commit的信息，不会恢复stage(如果还要提交，直接commit即可)</p></li><li><p>–hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容</p></li><li><p>HEAD^^：回退到前N次的提交，是上述的快捷表示</p></li></ul><h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h2><ul><li><p>[-v]：查看本地分支</p></li><li><p>-D[本地分支名]：删除本地的分支</p></li><li>–remote/-r：查看本地分支追踪的是哪一个远程分支</li><li>-a：查看所有远程分支</li><li>–track newLocalBranch remoteName/remoteBranch：<ul><li>取回远程主机的更新后，可以在它的基础上，使用gitcheckout命令创建一个新的分支，并使新建的本地分支，追踪指定的远程分支</li></ul></li><li>–set-upstream master origin/next：手动建立起追踪关系</li></ul><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><ul><li>.<ul><li>添加当前”git status”下显示的除删除文件外的所有修改</li></ul></li><li>–all：添加所有修改，包括删除文件</li></ul><h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><ul><li>git clone &lt;版本库的网址&gt; [本地目录名]：<ul><li>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数</li></ul></li><li>-o<ul><li>克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定<ul><li>$git clone -o jQuery <a href="https://github.com/jquery/jquery.git" target="_blank" rel="noopener">https://github.com/jquery/jquery.git</a></li><li>$git remote</li><li>jQuery</li></ul></li></ul></li></ul><h2 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h2><ul><li><p>不带选项的时候，git remote命令列出所有远程主机</p><ul><li>$git remote</li><li>origin</li></ul></li><li><p>-v</p><ul><li>参看远程主机的网址<ul><li>$git remote -v</li><li>origin <a href="mailto:git@github.com">git@github.com</a>:jquery/jquery.git(fetch)</li><li>origin <a href="mailto:git@github.com">git@github.com</a>:jquery/jquery.git(push)</li></ul></li><li>git remote show &lt;主机名&gt;<ul><li>查看该远程主机的详细信息，一般远程主机名默认命名为origin</li></ul></li><li>git remote add &lt;主机名&gt; &lt;网址&gt;<ul><li>用于添加远程主机</li></ul></li><li>git remote rm &lt;主机名&gt;<ul><li>用于删除远程主机</li></ul></li><li>git remote rename &lt;原主机名&gt; &lt;新主机名&gt;<ul><li>用于重命名远程主机名</li></ul></li></ul><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><ul><li>gerrit</li><li>git fetch &lt;远程主机名&gt;<ul><li>一旦远程主机的版本库有了更新(Git属于叫做commit)，需要将这些更新取回本地，这时就要用到git fetch命令，通常用来查看其他人的进程，对本地的代码没有影响。默认取回所有分支的更新</li></ul></li><li>git fetch &lt;远程主机名&gt; &lt;分支名&gt;<ul><li>指定分支名，取回特定分支的更新</li><li>$git fetch origin master：取回oringin主机的master分支</li></ul></li></ul><h2 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h2><ul><li>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;：&lt;本地分支名&gt;<ul><li>取回远程主机某个分支的更新，再与本地的指定分支合并</li></ul></li><li>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;<ul><li>如果远程分支是与当前分支合并，则冒号后面的部分可以省略</li><li>命令表示取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。<ul><li>$git fetch origin</li><li>$git merge origin/next</li></ul></li><li>git pull origin<ul><li>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名</li></ul></li><li>git pull<ul><li>如果当前分支只有一个追踪分支，连远程分支名都可以省略</li></ul></li><li>git pull -p<ul><li>如果远程主机删除了某个分支，默认情况下，git pull不会在拉取远程分支的时候，删除对应的本地分支。加上参数-p就会在本地删除远程已经删除的分支</li></ul></li><li>–rebase &lt;远程主机名&gt; &lt;远程分支名&gt; : &lt;本地分支名&gt;</li></ul></li></ul><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><ul><li>git push &lt;远程主机名&gt; &lt;远程分支名&gt;：&lt;本地分支名&gt;<br>*</li></ul></li></ul><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>JQuery</title>
    <url>/2019/08/12/JQuery/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB</title>
    <url>/2019/08/20/MongoDB/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><p>MongoDB的服务会开机自启动</p><p>MongoDB数据备份与恢复要在bin目录下执行</p><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5笔记</title>
    <url>/2019/05/19/HTML5/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><h1 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h1><h2 id="meta标记"><a href="#meta标记" class="headerlink" title="meta标记"></a>meta标记</h2><ul><li><p>meta标记用来描述网页，有利于搜索引擎快速找到网站并正确分类</p></li><li><p><strong>注意：</strong>对于中文网页需要使用 meta charset=”utf-8”声明编码，否则会出现乱码。</p></li><li><p>有些浏览器(如 360 浏览器)会设置 GBK 为默认编码，则你需要设置为meta charset=”gbk”</p></li><li><p>SEO（Search Engine Optimization）搜索引擎优化</p><ul><li>开发后上线=》发布=》用户就可以找到你的网站（网址、去搜索）</li><li>记得网站要去做收录（各大搜索网站收录的地址）</li><li>收录后，搜索引擎（蜘蛛程序）去爬你的网站</li><li>目的：记录你的网页内容：title标签、alt、title属性、keywords、description</li></ul></li></ul><h1 id="STYLE-CSS"><a href="#STYLE-CSS" class="headerlink" title="STYLE / CSS"></a>STYLE / CSS</h1><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="七种选择器"><a href="#七种选择器" class="headerlink" title="七种选择器"></a>七种选择器</h3><ul><li>ID 选择器， 如 #id{}</li><li>类选择器， 如 .class{}</li><li>属性选择器， 如 a[href=”segmentfault.com”]{}</li><li>伪类选择器， 如 :hover{}</li><li>伪元素选择器， 如 ::before{}</li><li>标签选择器， 如 span{}</li><li>通配选择器， 如 *{}</li></ul><h3 id="关系选择符"><a href="#关系选择符" class="headerlink" title="关系选择符"></a>关系选择符</h3><ul><li>E F：包含选择符<ul><li>选择所有被E元素包含的F元素</li></ul></li><li>E&gt;F：子选择符<ul><li>选择所有作为E元素的子元素F</li></ul></li><li>E+F：相邻选择符<ul><li>选择紧贴在E元素之后的F元素</li></ul></li><li>E~F：兄弟选择符<ul><li>选择E元素所有兄弟元素F</li></ul></li></ul><h3 id="伪类选择符"><a href="#伪类选择符" class="headerlink" title="伪类选择符"></a>伪类选择符</h3><ul><li><p>常用</p><ul><li><p>：hover</p><ul><li>设置元素在其鼠标悬停时的样式。</li></ul></li><li><p>：active</p><ul><li><p>设置元素在被用户激活</p><p>(在鼠标点击与释放之间发生的事件)时的样式</p></li></ul></li><li><p>：focus</p><ul><li><p>设置元素在成为输入焦点</p><p>(该元素的onfocus事件发生)时的样式</p></li></ul></li><li><p>E：not（s)</p><ul><li>匹配不含有s选择符的元素E</li></ul></li><li><p>：first-child</p><ul><li>匹配第一个子元素</li></ul></li><li><p>：last-child</p><ul><li>匹配最后一个子元素</li></ul></li><li><p>：nth-child（n）</p><ul><li>匹配第n个子元素</li></ul></li></ul></li></ul><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/cssref/sel-checked.html" target="_blank" rel="noopener">:checked</a></td><td>input:checked</td><td>选择所有选中的表单元素</td></tr><tr><td><a href="https://www.runoob.com/css/cssref/sel-disabled.html" target="_blank" rel="noopener">:disabled</a></td><td>input:disabled</td><td>选择所有禁用的表单元素</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-empty.html" target="_blank" rel="noopener">:empty</a></td><td>p:empty</td><td>选择所有没有子元素的p元素</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-enable.html" target="_blank" rel="noopener">:enabled</a></td><td>input:enabled</td><td>选择所有启用的表单元素</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-first-of-type.html" target="_blank" rel="noopener">:first-of-type</a></td><td>p:first-of-type</td><td>选择的每个 p 元素是其父元素的第一个 p 元素</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-in-range.html" target="_blank" rel="noopener">:in-range</a></td><td>input:in-range</td><td>选择元素指定范围内的值</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-invalid.html" target="_blank" rel="noopener">:invalid</a></td><td>input:invalid</td><td>选择所有无效的元素</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-last-child.html" target="_blank" rel="noopener">:last-child</a></td><td>p:last-child</td><td>选择所有p元素的最后一个子元素</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-last-of-type.html" target="_blank" rel="noopener">:last-of-type</a></td><td>p:last-of-type</td><td>选择每个p元素是其母元素的最后一个p元素</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-not.html" target="_blank" rel="noopener">:not(selector)</a></td><td>:not(p)</td><td>选择所有p以外的元素</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-nth-child.html" target="_blank" rel="noopener">:nth-child(n)</a></td><td>p:nth-child(2)</td><td>选择所有 p 元素的父元素的第二个子元素</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-nth-last-child.html" target="_blank" rel="noopener">:nth-last-child(n)</a></td><td>p:nth-last-child(2)</td><td>选择所有p元素倒数的第二个子元素</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-nth-last-of-type.html" target="_blank" rel="noopener">:nth-last-of-type(n)</a></td><td>p:nth-last-of-type(2)</td><td>选择所有p元素倒数的第二个为p的子元素</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-nth-of-type.html" target="_blank" rel="noopener">:nth-of-type(n)</a></td><td>p:nth-of-type(2)</td><td>选择所有p元素第二个为p的子元素</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-only-of-type.html" target="_blank" rel="noopener">:only-of-type</a></td><td>p:only-of-type</td><td>选择所有仅有一个子元素为p的元素</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-only-child.html" target="_blank" rel="noopener">:only-child</a></td><td>p:only-child</td><td>选择所有仅有一个子元素的p元素</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-optional.html" target="_blank" rel="noopener">:optional</a></td><td>input:optional</td><td>选择没有”required”的元素属性</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-out-of-range.html" target="_blank" rel="noopener">:out-of-range</a></td><td>input:out-of-range</td><td>选择指定范围以外的值的元素属性</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-read-only.html" target="_blank" rel="noopener">:read-only</a></td><td>input:read-only</td><td>选择只读属性的元素属性</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-read-write.html" target="_blank" rel="noopener">:read-write</a></td><td>input:read-write</td><td>选择没有只读属性的元素属性</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-required.html" target="_blank" rel="noopener">:required</a></td><td>input:required</td><td>选择有”required”属性指定的元素属性</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-root.html" target="_blank" rel="noopener">:root</a></td><td>root</td><td>选择文档的根元素</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-target.html" target="_blank" rel="noopener">:target</a></td><td>#news:target</td><td>选择当前活动#news元素(点击URL包含锚的名字)</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-valid.html" target="_blank" rel="noopener">:valid</a></td><td>input:valid</td><td>选择所有有效值的属性</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-link.html" target="_blank" rel="noopener">:link</a></td><td>a:link</td><td>选择所有未访问链接</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-visited.html" target="_blank" rel="noopener">:visited</a></td><td>a:visited</td><td>选择所有访问过的链接</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-active.html" target="_blank" rel="noopener">:active</a></td><td>a:active</td><td>选择正在活动链接</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-hover.html" target="_blank" rel="noopener">:hover</a></td><td>a:hover</td><td>把鼠标放在链接上的状态</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-focus.html" target="_blank" rel="noopener">:focus</a></td><td>input:focus</td><td>选择元素输入后具有焦点</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-firstletter.html" target="_blank" rel="noopener">:first-letter</a></td><td>p:first-letter</td><td>选择每个&lt;p 元素的第一个字母</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-firstline.html" target="_blank" rel="noopener">:first-line</a></td><td>p:first-line</td><td>选择每个&lt;p 元素的第一行</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-firstchild.html" target="_blank" rel="noopener">:first-child</a></td><td>p:first-child</td><td>选择器匹配属于任意元素的第一个子元素的 p&gt; 元素</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-before.html" target="_blank" rel="noopener">:before</a></td><td>p:before</td><td>在每个&lt;p元素之前插入内容</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-after.html" target="_blank" rel="noopener">:after</a></td><td>p:after</td><td>在每个&lt;p元素之后插入内容</td></tr><tr><td><a href="https://www.runoob.com/cssref/sel-lang.html" target="_blank" rel="noopener">:lang(<em>language</em>)</a></td><td>p:lang(it)</td><td>为&lt;p元素的lang属性选择一个开始值</td></tr></tbody></table><h3 id="属性选择符"><a href="#属性选择符" class="headerlink" title="属性选择符"></a>属性选择符</h3><ul><li>E[att]<ul><li>选择具有att属性的E元素</li></ul></li><li>E[att=”val”]<ul><li>选择具有att属性且属性值等于val的E元素</li></ul></li><li>E[att~=”val”]<ul><li>选择具有att属性且属性值为一用空格分隔的字词列表，其中一个等于val的E元素</li></ul></li><li>E[att^=”val”]<ul><li>选择具有att属性且属性值为以val开头的字符串的E元素</li></ul></li><li>E[att$=”val”]<ul><li>选择具有att属性且属性值为以val结尾的字符串的E元素</li></ul></li><li>E[att*=”val”]<ul><li>选择具有att属性且属性值为包含val的字符串的E元素</li></ul></li><li>E[att|=”val”]<ul><li>选择具有att属性且属性值为以val开头并用连接符”-“分隔的字符串的E元素</li></ul></li></ul><h3 id="伪对象选择符"><a href="#伪对象选择符" class="headerlink" title="伪对象选择符"></a>伪对象选择符</h3><ul><li>E:first-letter/E::first-letter<ul><li>设置对象内的第一个字符的样式</li></ul></li><li>E:first-line/E::first-line<ul><li>设置对象内的第一行的样式</li></ul></li><li>E:before/E::before<ul><li>设置在对象前（依据对象树的逻辑结构）发生的内容。</li><li>用来和content属性一起使用</li></ul></li><li>E:after/E::after<ul><li>设置在对象后（依据对象树的逻辑结构）发生的内容。</li><li>用来和content属性一起使用</li></ul></li><li>E::placeholder<ul><li>设置对象文字占位符的样式</li></ul></li><li>E::selection<ul><li>设置对象被选择时的颜色</li></ul></li></ul><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul><li>CSS选择器的使用，应该尽量避免使用 !important 和 内联样式；</li><li>id通常也是与class区分开使用，前者多用于JS中的结点定位，后者多用于CSS选择器。</li><li>color尽量使用16进制或RGBA</li><li>字体：<ul><li>垂直居中：<ul><li>lineheight与height相等</li><li>vertical-align:middle;</li></ul></li><li>文本居中（img未转换成块元素前同样适用）：<ul><li>text-align: center</li></ul></li></ul></li></ul><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><h3 id="规则：就近原则"><a href="#规则：就近原则" class="headerlink" title="规则：就近原则"></a>规则：就近原则</h3><ul><li><p>行内引用 &gt; 页内引用 &gt; 页外引用</p></li><li><p><strong>CSS 优先规则1：</strong> 最近的祖先样式比其他祖先样式优先级高。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">--</span> 类名为 <span class="selector-tag">son</span> 的 <span class="selector-tag">div</span> 的 <span class="selector-tag">color</span> 为 <span class="selector-tag">blue</span> <span class="selector-tag">--</span>&gt;</span><br><span class="line">&lt;div style="color: red"&gt;</span><br><span class="line">    &lt;div style="color: blue"&gt;</span><br><span class="line">        &lt;div class="son"&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>CSS 优先规则2：</strong>“直接样式”比”祖先样式”优先级高。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">--</span> 类名为 <span class="selector-tag">son</span> 的 <span class="selector-tag">div</span> 的 <span class="selector-tag">color</span> 为 <span class="selector-tag">blue</span> <span class="selector-tag">--</span>&gt;</span><br><span class="line">&lt;div style="color: red"&gt;</span><br><span class="line">    &lt;div class="son" style="color: blue"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>CSS 优先规则3：</strong></p><ul><li>优先级关系：内联样式 &gt; ID 选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素选择器</li></ul></li><li><p><strong>CSS 优先规则4：</strong></p><ul><li>计算选择符中 ID 选择器的个数（a），计算选择符中类选择器、属性选择器以及伪类选择器的个数之和（b），计算选择符中标签选择器和伪元素选择器的个数之和（c）。</li><li>按 a、b、c 的顺序依次比较大小，大的则优先级高，相等则比较下一个。若最后两个的选择符中 a、b、c 都相等，则按照”就近原则”来判断。</li></ul></li><li><p><strong>CSS 优先规则5：</strong></p><ul><li>属性后插有 <strong>!important</strong> 的属性拥有最高优先级。若同时插有 <strong>!important</strong>，则再利用规则 3、4 判断优先级</li></ul></li><li><p>! important <strong>（特殊情况使用）</strong></p><ul><li>!important是CSS1就定义的语法，作用是提高指定样式规则的应用优先权。<ul><li>语法格式{ cssRule !important }，即写在定义的最后面，例如：<ul><li>p{color:red !important;}</li><li>p{color:blue}</li></ul></li></ul></li></ul></li></ul><h2 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h2><ul><li><h4 id="错误的说法"><a href="#错误的说法" class="headerlink" title="错误的说法"></a>错误的说法</h4><ul><li>在学习过程中，你可能发现给选择器加权值的说法，即 ID 选择器权值为 100，类选择器权值为 10，标签选择器权值为 1，当一个选择器由多个 ID 选择器、类选择器或标签选择器组成时，则将所有权值相加，然后再比较权值。这种说法其实是有问题的。比如一个由 11 个类选择器组成的选择器和一个由 1 个 ID 选择器组成的选择器指向同一个标签，按理说 110 &gt; 100，应该应用前者的样式，然而事实是应用后者的样式。错误的原因是：<strong>选择器的权值不能进位</strong>。还是拿刚刚的例子说明。11 个类选择器组成的选择器的总权值为 110，但因为 11 个均为类选择器，所以其实总权值最多不能超过 100， 你可以理解为 99.99，所以最终应用后者样式。</li></ul></li><li><h4 id="CSS-选择符组合方式："><a href="#CSS-选择符组合方式：" class="headerlink" title="CSS 选择符组合方式："></a>CSS 选择符组合方式：</h4><ul><li>后代选择符： .father .child{}</li><li>子选择符： .father &gt; .child{}</li><li>相邻选择符: .bro1 + .bro2{}</li></ul></li><li><h4 id="样式被应用的位置越在下面则优先级越高"><a href="#样式被应用的位置越在下面则优先级越高" class="headerlink" title="样式被应用的位置越在下面则优先级越高"></a>样式被应用的位置越在下面则优先级越高</h4></li><li><p>清除CSS中select的下拉箭头样式</p><ul><li><p><code>`</code>css<br>select {<br>/<em>Chrome和Firefox里面的边框是不一样的，所以复写了一下</em>/<br>border: solid 1px #000;</p><p>/<em>很关键：将默认的select选择框样式清除</em>/<br>appearance:none;<br>-moz-appearance:none;<br>-webkit-appearance:none;</p><p>/<em>在选择框的最右侧中间显示小箭头图片</em>/<br>background: url(“<a href="http://ourjs.github.io/static/2015/arrow.png&quot;" target="_blank" rel="noopener">http://ourjs.github.io/static/2015/arrow.png&quot;</a>) no-repeat scroll right center transparent;</p></li></ul></li></ul><pre><code>/*为下拉小箭头留出一点位置，避免被文字覆盖*/
padding-right: 14px;
}


/*清除ie的默认选择框样式清除，隐藏下拉箭头*/
select::-ms-expand { display: none; }
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## other</span><br><span class="line"></span><br><span class="line">* 在布局上面，一开始就要设置的，主要目的去除&#x2F;初始化所有标签的样式</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;css</span><br><span class="line">  *&#123;</span><br><span class="line">              margin: 0;  &#x2F;*去除默认的外边距*&#x2F;</span><br><span class="line">              padding: 0; &#x2F;*去除默认的内边距*&#x2F;</span><br><span class="line">              font-size: 14px;    &#x2F;*统一字体大小*&#x2F;</span><br><span class="line">              font-weight: normal;    &#x2F;*都不加粗*&#x2F;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre><ul><li><p>id名，一般不用来加样式，一般是用于js添加动态效果</p></li><li><p>id的优先级最高</p></li><li><p>长图片定位</p><ul><li><code>`</code>css<br>.img{<pre><code>background:url(1.png) 0 0 no-repeat;
width:25px;
height:25px;
</code></pre>}<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"># 布局</span><br><span class="line"></span><br><span class="line">## display（元素显示模式）</span><br><span class="line"></span><br><span class="line">* block</span><br><span class="line">  * 块对象指的是元素显示为一个方块，默认显示状态下将占据整行，其它的元素只能另起一行显示</span><br><span class="line">* inline</span><br><span class="line">  * 行间对象与block刚好相反，它允许其它元素在同一行显示</span><br><span class="line">* none</span><br><span class="line">  * 隐藏对象</span><br><span class="line">* inline-block</span><br><span class="line"></span><br><span class="line">## float（元素的浮动）</span><br><span class="line"></span><br><span class="line">* none</span><br><span class="line">  * 不浮动</span><br><span class="line">* right</span><br><span class="line">  * 向右浮动</span><br><span class="line">* left</span><br><span class="line">  * 向左浮动</span><br><span class="line">* 浮动的时候元素的显示属性也变化了变为 “行内元素”</span><br><span class="line"></span><br><span class="line">## clear（清除浮动）</span><br><span class="line"></span><br><span class="line">* none</span><br><span class="line">  * 默认值</span><br><span class="line">  * 允许两两边都可以有浮动对象</span><br><span class="line">* left</span><br><span class="line">  * 不允许左边有浮动对象</span><br><span class="line">* right</span><br><span class="line">  * 不允许右边有浮动对象</span><br><span class="line">* both</span><br><span class="line">  * 不允许有浮动对象</span><br><span class="line"></span><br><span class="line">## position（元素的定位）</span><br><span class="line"></span><br><span class="line">* static</span><br><span class="line">  * 无定位</span><br><span class="line">  * 默认值</span><br><span class="line">* absolute</span><br><span class="line">  * 绝对定位</span><br><span class="line">  * tips：</span><br><span class="line">    * 脱离文档流。</span><br><span class="line">    * 通过 top,bottom,left,right 定位。</span><br><span class="line">    * 如果父元素 position 为 static 时，将以body坐标原点进行定位。</span><br><span class="line">    * 如果父元素 position 为 relative  时，将以父元素进行定位。</span><br><span class="line">* relative</span><br><span class="line">  * 相对定位</span><br><span class="line">  * tips：</span><br><span class="line">    * 相对定位（相对自己原来的位置而言）</span><br><span class="line">    * 不脱离文档流</span><br><span class="line">    * 参考自身静态位置通过 top,bottom,left,right 定位。</span><br><span class="line">* fixed</span><br><span class="line">  * 固定定位</span><br><span class="line">  * tips</span><br><span class="line">    * 固定定位实际上只是绝对定位的特殊形式；</span><br><span class="line">    * 固定定位的元素是相对于浏览器窗口而固定，而不是相对于其包含元素；</span><br><span class="line">    * 即使页面滚动了，它们仍然会处在浏览器窗口中跟原来完全一样的地方。 </span><br><span class="line"></span><br><span class="line">## z-index（元素的层叠关系）</span><br><span class="line"></span><br><span class="line">* auto</span><br><span class="line">* number</span><br><span class="line"></span><br><span class="line">## **reset.css**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;css</span><br><span class="line">body,p,ul,ol,li,dl,dt,dd,h1,h2,h3,h4,h5,h6,form,fieldset,legend,input,select,textarea,button,th,td,menu&#123;margin:0;padding:0;&#125;</span><br><span class="line">ul,dl,ol&#123;list-style:none;&#125;</span><br><span class="line">img,fieldset,input[type&#x3D;&quot;submit&quot;]&#123;border:0 none;&#125;</span><br><span class="line">em&#123;font-style:normal;&#125;</span><br><span class="line">strong&#123;font-weight:normal;&#125;</span><br><span class="line">table&#123;border-collapse:collapse;border-spacing:0;&#125;</span><br><span class="line">button,input[type&#x3D;&quot;button&quot;]&#123;cursor:pointer;border:0 none;&#125;</span><br><span class="line">a,button,input,img&#123;-webkit-touch-callout:none;&#125;</span><br><span class="line">img&#123;pointer-events:none;&#x2F;*禁止图片的点击事件，例如长按保存图片*&#x2F;&#125;</span><br><span class="line">input,select,textarea&#123;outline:none;&#125;</span><br><span class="line">a&#123;text-decoration:none;&#125;</span><br><span class="line">.fl&#123; float: left&#125;</span><br><span class="line">.fr&#123; float: right&#125;</span><br><span class="line">.clear&#123;clear:both;&#125; </span><br><span class="line">html,body&#123;</span><br><span class="line">&#x2F;*禁止用户选择元素*&#x2F;</span><br><span class="line">-moz-user-select:none;</span><br><span class="line"> -webkit-user-select: none;</span><br><span class="line">-ms-user-select: none;</span><br><span class="line"> -khtml-user-select:none; &#x2F;*禁止元素点击出现半透明黑色背景*&#x2F;</span><br><span class="line"> -webkit-tap-highlight-color:rgba(0, 0, 0, 0); &#125;</span><br><span class="line">html &#123;height: 100%;width: 100%;font-family: &#39;Heiti SC&#39;, &#39;Microsoft YaHei&#39;;outline: 0;-webkit-text-size-adjust:none;&#125;</span><br><span class="line">body &#123;height: 100%;margin: 0;position: relative;&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="BODY"><a href="#BODY" class="headerlink" title="BODY"></a>BODY</h1><h2 id="常见语义标记"><a href="#常见语义标记" class="headerlink" title="常见语义标记"></a>常见语义标记</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>文章标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>发表时间：1999-01-01 <span class="tag">&lt;<span class="name">span</span>&gt;</span>作者：佚名<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">a</span>&gt;</span> | </span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>CSS<span class="tag">&lt;/<span class="name">a</span>&gt;</span> | </span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>正文...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>稻草<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">p</span>&gt;</span>夏日的夕阳，激起了小溪的热情，染红了乡间的田野。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>今天我们去星光电影城看了场电影<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">h4</span>&gt;</span>星光电影城<span class="tag">&lt;/<span class="name">h4</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>星光电影城是市内最大的电影城，里面不仅有舒服的观影体验，还有大量的娱乐设施，美食等...<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>Posted by: hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">time</span> <span class="attr">pubdate</span> <span class="attr">datetime</span>=<span class="string">"2012-03-01"</span>&gt;</span><span class="tag">&lt;/<span class="name">time</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>标记</th><th>说明</th></tr></thead><tbody><tr><td>header</td><td>显示网站名称、主题或者主要信息</td></tr><tr><td>nav</td><td>网站的连接菜单</td></tr><tr><td>aside</td><td>用于侧边栏</td></tr><tr><td>article</td><td>用于定义主内容区</td></tr><tr><td>section</td><td>用于章节或段落</td></tr><tr><td>footer</td><td>位于页脚，用来放置版权声明、作者等信息</td></tr><tr><td>figure</td><td>独立的流内容（图像、图表、照片、代码等等）<br>内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。</td></tr><tr><td>figcaption</td><td>定义 figure&gt;元素的标题.<br>应该被置于 “figure”元素的第一个或最后一个子元素的位置</td></tr><tr><td></td></tr></tbody></table><ul><li><p>div：容器标签</p></li><li><p>span：区块标签</p></li><li><p>embed：定义了一个容器，用来嵌入外部应用或者互动程序（插件）</p><ul><li><p>width、height：宽高</p></li><li><p>type：规定嵌入内容的MIME 类型，如视频，外部应用</p><ul><li>值：MIME_type</li></ul></li><li><p>src：URL</p></li><li><p><code>`</code>html<br><embed src="flash.swf"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* base：为页面上的所有链接规定默认地址或默认目标</span><br><span class="line"></span><br><span class="line">  * base&gt; 标签必须位于 head&gt; 元素内部</span><br><span class="line"></span><br><span class="line">  * base&gt;标签是空标签，没有结束标签，XHTML中要求正确关闭 &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;html</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; </span><br><span class="line">    &lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;</span><br><span class="line">    	&lt;base href&#x3D;&quot;&#x2F;&#x2F;www.runoob.com&#x2F;images&#x2F;&quot;&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        &lt;img src&#x3D;&quot;logo.png&quot;&gt; - 注意这里我们设置了图片的相对地址。能正常显示是因为我们在 head 部分设置了 base 标签，该标签指定了页面上所有链接的默认 URL，所以该图片的访问地址为 &quot;http:&#x2F;&#x2F;www.runoob.com&#x2F;images&#x2F;logo.png&quot;</span><br><span class="line">        &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>bdo：改变文字方向</p><ul><li><p>属性</p><ul><li>ltr：left to right ：→</li><li>rtl：right to left ：←</li></ul></li><li><p><code>`</code>html<br><bdo dir="“rtl”">文本将改变文本方向</bdo></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* canvas：图形的绘制</span><br><span class="line"></span><br><span class="line">  * 通过脚本（通常是JS）来完成</span><br><span class="line"></span><br><span class="line">  * canvas&gt; 标签只是图形容器，您必须使用脚本来绘制图形</span><br><span class="line"></span><br><span class="line">  * 默认情况下 canvas元素没有边框和内容，使用 style 属性来添加边框</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;html</span><br><span class="line">    &lt;canvas  id&#x3D;“id名” width&#x3D;“200” height&#x3D;“100” style&#x3D;&quot;border:1px solid #000;&quot;&gt;&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>`</code><br></p><tbody>标签表格主体（正文）。该标签用于组合 HTML 表格的主体内容。<br>tbody 元素应该与 thead 和 tfoot 元素结合起来使用。<br>thead 元素用于对 HTML 表格中的表头内容进行分组，而 tfoot 元素用于对 HTML 表格中的表注（页脚）内容进行分组。<br>注释：如果您使用 thead、tfoot 以及 tbody 元素，您就必须使用全部的元素。它们的出现次序是：thead、tfoot、tbody，这样浏览器就可以在收到所有数据前呈现页脚了。您必须在 table 元素内部使用这些标签。<br>提示：在默认情况下这些元素不会影响到表格的布局。不过，您可以使用 CSS 使这些元素改变表格的外观。<br>详细描述<br>thead、tfoot 以及 tbody 元素使您有能力对表格中的行进行分组。当您创建某个表格时，您也许希望拥有一个标题行，一些带有数据的行，以及位于底部的一个总计行。这种划分使浏览器有能力支持独立于表格标题和页脚的表格正文滚动。当长的表格被打印时，表格的表头和页脚可被打印在包含表格数据的每张页面上。<br>注释：<thead>内部必须拥有<tr>标签！<p></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">## 标记</span><br><span class="line"></span><br><span class="line">- 换行</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">&lt;br&gt;</span><br></pre></td></tr></table></figure></tr></thead></tbody></li></ul><ul><li>分割线</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>让文字按原始代码的排列方式进行显示</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>表示引用文字，会将标记内的文字换行并缩进</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>特殊符号表示</p><p>&copy; // &amp;copy+;</p><p>&lt; // &amp;lt+;</p><p>&gt; // &amp;gt+;</p><p>&amp; // &amp;amp+;</p><p>“ // &amp;quot+;</p><p>&reg; // &amp;reg+;</p><p>不换行空格 // &amp;nbsp+;</p><p>半角空格 // &amp;ensp；</p><p>全角空格 // &amp;emsp；</p><p>窄空格 // &amp;thinsp；6/1</p></li></ul><h2 id="a：链接"><a href="#a：链接" class="headerlink" title="a：链接"></a>a：链接</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">	text-decoration：none;	/*去除下划线*/</span><br><span class="line">    <span class="selector-tag">text-decoration</span>：<span class="selector-tag">underline</span>;<span class="comment">/*添加下划线*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>说明：<ul><li>href：定义链接地址</li><li>title：链接提示信息</li><li>target：链接打开方式</li></ul></li><li><p>锚点标签用于使用户”跳”到文档的某个部分。</p><ul><li>a href=”#位置名”&gt;&lt;/a</li><li>a name=”位置名”&gt;&lt;/a</li></ul></li><li><p><strong>提示：</strong>如果没有使用 href 属性，则不能使用 hreflang、media、rel、target 以及 type 属性</p></li><li><strong>提示：</strong>通常在当前浏览器窗口中显示被链接页面，除非规定了其他 target</li><li><strong>提示：</strong>请使用 CSS 来改变链接的样式</li></ul><h2 id="img：图像"><a href="#img：图像" class="headerlink" title="img：图像"></a>img：图像</h2><ul><li><p>转换为块元素：</p><ul><li><p><code>`</code>css<br>img{</p><pre><code>display: block;
</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 说明：</span><br><span class="line"></span><br><span class="line">  * src：定义图像的url</span><br><span class="line">  * alt：定义图像的替代文本（即图像提示信息）</span><br><span class="line">  * width：设置图像的宽度  </span><br><span class="line">  * height：设置图像的高度</span><br><span class="line"></span><br><span class="line">* 图像热区</span><br></pre></td></tr></table></figure><p><img src="URL" usemap="# map名称"><br><map name="map名称"><br><area shape="形状" coords="坐标值" href="URL"><br></map></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 矩形：(左上角顶点坐标为(x1,y1)，右下角顶点坐标为(x2,y2)) </span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">&lt;area shape&#x3D;&quot;rect&quot; coords&#x3D;&quot;x1,y1,x2,y2&quot; href&#x3D;url&gt;</span><br></pre></td></tr></table></figure></li><li><p>圆形：(圆心坐标为(X1,y1)，半径为r)</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"circle"</span> <span class="attr">coords</span>=<span class="string">"x1,y1,r"</span> <span class="attr">href</span>=<span class="string">url</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>多边形：(各顶点坐标依次为(x1,y1)、(x2,y2)、(x3,y3) ……)</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"poly"</span> <span class="attr">coords</span>=<span class="string">"x1,y1,x2,y2 ......"</span> <span class="attr">href</span>=<span class="string">url</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>float：浮动</p><p>| 值 | 描述 |<br>| :—–: | :————————————————–: |<br>| left | 元素向左浮动。 |<br>| right | 元素向右浮动。 |<br>| none | 默认值。元素不浮动，并会显示在其在文本中出现的位置。 |<br>| inherit | 规定应该从父元素继承 float 属性的值 |</p></li></ul><h2 id="dl：定义列表"><a href="#dl：定义列表" class="headerlink" title="dl：定义列表"></a>dl：定义列表</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>计算机<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>用来计算的仪器 ... ...<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>显示器<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>以视觉方式显示信息的装置 ... ...<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>类似ul</li></ul><h2 id="ul：无序列表"><a href="#ul：无序列表" class="headerlink" title="ul：无序列表"></a>ul：无序列表</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span>,<span class="selector-tag">dl</span>&#123;</span><br><span class="line">	<span class="attribute">float</span>: left;	<span class="comment">/*左浮动：从左到右并排显示*/</span></span><br><span class="line">    <span class="attribute">list-style</span>: none;<span class="comment">/*去小圆圈*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>属性：Type<ul><li>disc：实心圆（默认）</li><li>circle：空心圆</li><li>square：实心方框</li></ul></li><li>reversed：倒序</li></ul><h2 id="ol：有序列表"><a href="#ol：有序列表" class="headerlink" title="ol：有序列表"></a>ol：有序列表</h2><ul><li>start：排序的起点数值</li><li>type：用来设置项目前面的标记<ul><li>1：数字（默认）</li><li>a：小写字母</li><li>A：大写字母</li><li>i：小写希腊字母</li><li>I：大写希腊字母</li></ul></li></ul><h2 id="Audio、Video：媒体"><a href="#Audio、Video：媒体" class="headerlink" title="Audio、Video：媒体"></a>Audio、Video：媒体</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"song.ogg"</span> <span class="attr">type</span>=<span class="string">"audio/ogg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"song.mp3"</span> <span class="attr">type</span>=<span class="string">"audio/mpeg"</span>&gt;</span></span><br><span class="line">  你的浏览器不支持<span class="tag">&lt;<span class="name">audio</span>&gt;</span>标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span> &gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>音频属性</p><ul><li>autoplay：自动播放</li><li>loop：循环播放</li><li>controls：显示控件</li><li>preload：预加载（若使用autoplay属性则自动忽略）</li></ul></li><li><p>视频属性</p><ul><li>同上</li><li>muted：规定视频的音频输出应该被静音</li><li>poster[URL]：规定视频未播放时的图像</li><li>src[URL]：视频链接</li><li>width &amp; height：宽高</li></ul></li></ul><h2 id="table：表格"><a href="#table：表格" class="headerlink" title="table：表格"></a>table：表格</h2><ul><li><strong>tr（行）、th（表头）、td（单元）、caption（标题）</strong><ul><li><strong>th</strong> 所标识的单元格文字会以<strong>粗体</strong>显示，通常当做表格第一行的标题</li></ul></li><li>说明：<ul><li>width、height：宽高</li><li>border：边框宽度</li><li>cellpadding：单元内边距</li><li>cellmargin：单元外边距</li><li>align：水平<ul><li>left</li><li>right</li><li>center</li></ul></li><li>valign：垂直<ul><li>top</li><li>middle</li><li>bottom</li></ul></li><li>colspan：合并左右列</li><li>rowspan：合并上下行</li></ul></li><li>让单元格文字不换行 <strong>nowrap</strong> 例：【td nowrap】</li><li>遇到空白单元格时的处理方式：<ul><li>在其中输入全角空格（&amp;emsp；）或（&amp;nbsp；）即可解决</li></ul></li><li><strong>高度=行高，文字会垂直居中</strong></li><li>图片默认根据宽度对表格进行调整，故时而其下会有间隙，遇此情况<ul><li>IMG CSS : display : block // 将图片改成块元素</li><li>IMG CSS : display : flex // 弹性布局</li><li>float : left // 浮动</li></ul></li></ul><h2 id="HTML背景"><a href="#HTML背景" class="headerlink" title="HTML背景"></a>HTML背景</h2><ul><li><p>设置背景颜色 <strong>body bgcolor=”#000000”&gt;</strong></p></li><li><p>设置背景图片 <strong>body background=”bg.jpg”&gt;</strong></p></li><li><p>设置页面文字颜色 <strong>body text=”#cccccc”&gt;</strong></p></li><li><p>尽量使用十六进制以及RGBA或RGB，利于浏览器渲染</p></li><li><p>背景图CSS设置：</p><ul><li><p><code>`</code>css<br>body {</p><pre><code>    /* 图片地址 */
    background-image: url(09.jpg);

    /* 图片按屏幕大小显示 */
    background-size: cover;

    /* 指定一个固定的背景图片 */
    background-attachment: fixed;

    /* 图片不重复 */
    background-repeat: no-repeat;

    /* 图片显示位置水平居中垂直居中 */
    background-position: center center;
}
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">## iframe内嵌框架</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">&lt;iframe src&#x3D;&quot;xxx.html&quot; frameborder&#x3D;&quot;0&quot; id&#x3D;&quot;iframe&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>说明：</p><ul><li>scrolling：是否显示滚动条<ul><li>yes</li><li>no</li><li>auto</li></ul></li><li>frameborder：是否显示边框<ul><li>1</li><li>0</li></ul></li></ul></li><li><p>样式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">iframe</span> &#123;</span><br><span class="line">            <span class="attribute">position</span>: fixed;</span><br><span class="line">            <span class="comment">/*固定定位*/</span></span><br><span class="line">            <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>JavaScript</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scrolling=<span class="string">"no"</span>&gt;&lt;<span class="regexp">/iframe&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script language="javascript"&gt;</span></span><br><span class="line"><span class="regexp">        var timeIframe;</span></span><br><span class="line"><span class="regexp">        window.onload = function () &#123;</span></span><br><span class="line"><span class="regexp">            timeIframe = setTimeout(GetIframeStatus, 10);</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        function GetIframeStatus() &#123;</span></span><br><span class="line"><span class="regexp">            var iframe = document.getElementById("iframe");</span></span><br><span class="line"><span class="regexp">            var iframeWindow = iframe.contentWindow;</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/内容是否加载完</span></span><br><span class="line"><span class="regexp">            if (iframeWindow.document.readyState == "complete") &#123;</span></span><br><span class="line"><span class="regexp">                var iframeWidth, iframeHeight;</span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/获取Iframe的内容实际宽度</span></span><br><span class="line"><span class="regexp">                iframeWidth = iframeWindow.document.documentElement.scrollWidth;</span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/获取Iframe的内容实际高度</span></span><br><span class="line"><span class="regexp">                iframeHeight = iframeWindow.document.documentElement.scrollHeight;</span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/设置Iframe的宽度</span></span><br><span class="line"><span class="regexp">                iframe.width = iframeWidth;</span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/设置Iframe的高度</span></span><br><span class="line"><span class="regexp">                iframe.height = iframeHeight;</span></span><br><span class="line"><span class="regexp">            &#125; else &#123;</span></span><br><span class="line"><span class="regexp">                timeIframe = setTimeout(GetIframeStatus, 10);</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="form表单"><a href="#form表单" class="headerlink" title="form表单"></a>form表单</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"form1"</span> <span class="attr">action</span>=<span class="string">"URL"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">	用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uname"</span> /&gt;</span></span><br><span class="line">	密 码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"passwd"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>method（设置发送数据的方式）：</p><ul><li>post 和 get<ul><li>使用get方式发送数据，数据会直接加载URL之后，安全性比较差，并且有255个字符的字数限制</li><li>post方式是将数据封装之后再发送，字符串长度没有限制，数据安全性比较高。对于需要保密的信息，通常会采用post方式进行发送</li></ul></li></ul></li><li><p>action</p><ul><li>表单提交地址</li></ul></li><li><p>enctype：MIME方式</p><ul><li>MIME：<ul><li>Multipurpose Internet Mail Extensions</li><li>多用途互联网邮件扩展类型</li></ul></li><li>表单发送的编码方式，只有method=“post”时才有效</li><li>enctype=”application/x-www-form-urlencoded”：此为默认值，若enctype省略不写，则表示采取此种编码模式</li><li>enctype=”multipart/form-data”：用于上传文件的时候</li><li>enctype=”text/plain”：将表单属性发送到电子邮箱时，enctype的值必须设为”text/plain”,否则将会出现乱码</li></ul></li><li><p>marquee：滚动内容（过时）</p><ul><li>marquee元素已经 <strong>过时</strong>，请不要再使用。尽管一些浏览器仍然支持它，但它不是必须的。此外，使用这个元素基本上是你可以对你的用户做最糟糕的事情之一，所以请不要这样做。</li><li>direction ：滚动的方向<ul><li>left（默认）</li><li>right</li><li>up</li><li>down</li></ul></li><li>behavior ：滚动的方式<ul><li>scroll：连续滚动</li><li>slide：滑动一次</li><li>alternate：来回滚动</li></ul></li><li>loop ：循环的次数<ul><li>正整数</li><li>默认为无限循环</li></ul></li><li>scrollamount ：运动速度<ul><li>正整数，默认为6</li></ul></li><li>scrolldelay ：停顿时间<ul><li>正整数，默认为0，单位是毫秒</li></ul></li><li>align ：元素的垂直对齐方式<ul><li>top</li><li>middle（默认）</li><li>bottom</li></ul></li><li>bgcolor ：运动区域的背景色<ul><li>16进制的RGB颜色，默认为白色</li></ul></li><li>height、width：运动区域的高度和宽度<ul><li>正整数(单位是像素)</li><li>百分数</li><li>默认：width=100% height为<strong>标签</strong>内元素的高度。</li></ul></li><li>hspace、vspace ：元素到区域边界的水平距离和垂直距离<ul><li>正整数，单位是像素。</li></ul></li><li>onmouseover=this.stop() onmouseout=this.start() ：当鼠标以上区域的时候滚动停止，当鼠标移开的时候又继续滚动。</li></ul></li><li><p>target（打开方式）</p><ul><li>_blank：打开新窗口</li><li>_self ：当前的窗口</li><li>_parent：上一层窗口（父窗口）</li><li>_top：最上层窗口</li><li>框架名称：直接指定窗口或框架名称</li></ul></li><li><p>novalidate：规定当提交表单时不对表单数据（输入）进行验证。</p><ul><li><p><code>`</code>html<br></p><form action="demo_form.html" novalidate><br>E-mail: <input type="email" name="user_email"><p></p><pre><code>&lt;input type=&quot;submit&quot;&gt;
</code></pre><p></p></form><p></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- autocomplete：规定表单是否应该启用自动完成功能。</span><br><span class="line"></span><br><span class="line">  - on：浏览器会基于用户之前键入的值自动完成值。</span><br><span class="line">  - off：用户必须在每次使用时输入值到每个字段中，浏览器不会自动完成输入。</span><br><span class="line"></span><br><span class="line">### input：输入框</span><br><span class="line"></span><br><span class="line">- 说明</span><br><span class="line"></span><br><span class="line">  - placeholder：显示在输入框的内容</span><br><span class="line"></span><br><span class="line">  - readonly：是否只读</span><br><span class="line"></span><br><span class="line">  - maxlength：输入字符的最大长度</span><br><span class="line"></span><br><span class="line">  - disabled：是否禁用</span><br><span class="line"></span><br><span class="line">  - value：输入框中填入的值</span><br><span class="line"></span><br><span class="line">  - checkbox ：复选框   </span><br><span class="line"></span><br><span class="line">    - 此时name属性应为xxx [ ]</span><br><span class="line"></span><br><span class="line">  - selected ：下拉框默认选中</span><br><span class="line"></span><br><span class="line">  - datalist：规定了 input&gt; 元素可能的选项列表。</span><br><span class="line"></span><br><span class="line">    - &#96;&#96;&#96;html</span><br><span class="line">      &lt;input list&#x3D;&quot;browsers&quot;&gt; </span><br><span class="line">      &lt;datalist id&#x3D;&quot;browsers&quot;&gt; </span><br><span class="line">          &lt;option value&#x3D;&quot;Internet Explorer&quot;&gt; </span><br><span class="line">          &lt;option value&#x3D;&quot;Firefox&quot;&gt; </span><br><span class="line">          &lt;option value&#x3D;&quot;Chrome&quot;&gt; </span><br><span class="line">          &lt;option value&#x3D;&quot;Opera&quot;&gt; </span><br><span class="line">          &lt;option value&#x3D;&quot;Safari&quot;&gt; </span><br><span class="line">      &lt;&#x2F;datalist&gt;</span><br></pre></td></tr></table></figure><ul><li><p>提供”自动完成”的特性。用户能看到一个下拉列表，里边的选项是预先定义好的，将作为用户的输入数据。</p></li><li><p>使用 input&gt; 元素的 list 属性来绑定 datalist&gt; 元素。</p></li></ul></li><li><p>output：作为计算结果输出显示(比如执行脚本的输出)。</p><ul><li><code>`</code>html<br><form oninput="x.value=parseInt(a.value)+parseInt(b.value)"><pre><code>0
</code></pre><input type="range" id="a" value="50"><pre><code>100+
</code></pre><input type="number" id="b" value="50"><pre><code>=
</code></pre><output name="x" for="a b"></output><br></form><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- hidden</span><br><span class="line"></span><br><span class="line">  - hidden 属性规定对元素进行隐藏。</span><br><span class="line">  - 隐藏的元素不会被显示。</span><br><span class="line">  - 如果使用该属性，则会隐藏元素。</span><br><span class="line">  - 可以对 hidden 属性进行设置，使用户在满足某些条件时才能看到某个元素（比如选中复选框，等等）。然后，可使用 JavaScript 来删除 hidden 属性，使该元素变得可见。</span><br><span class="line"></span><br><span class="line">- radio：单选   </span><br><span class="line"></span><br><span class="line">  - name必须相同</span><br><span class="line"></span><br><span class="line">    #### label：</span><br><span class="line"></span><br><span class="line">    * 将输入项或选项及其标签文字关联起来</span><br><span class="line"></span><br><span class="line">    - 使单选**文字**部分也具有点击效果</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96;html</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">    	&lt;!-- 状态的属性，写个名字就可以了 autoplay loop checked选中 required必填--&gt;</span><br><span class="line">    单选按钮：</span><br><span class="line">    	&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;男&quot; id&#x3D;&quot;nan&quot;&gt;</span><br><span class="line">    	&lt;label for&#x3D;&quot;nan&quot;&gt;男生&lt;&#x2F;label&gt;</span><br><span class="line">    	&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;女&quot; checked id&#x3D;&quot;nv&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;nv&quot;&gt;女生&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>autocomplete</p><ul><li>用来设置input组件是否使用自动完成功能<ul><li>on</li><li>off</li></ul></li><li>自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。</li><li>适用于 form&gt;，以及下面的 input&gt; 类型：<ul><li>text, search, url, telephone, email, password, datepickers, range 以及 color</li></ul></li></ul></li><li><p>autofocus：当页面加载时 input&gt; 元素应该自动获得焦点</p><ul><li><code>`</code>html<br><form action="demo_form.html"><pre><code>First name: 
&lt;input type=&quot;text&quot; name=&quot;fname&quot; autofocus&gt;
   &lt;br&gt;
Last name: 
&lt;input type=&quot;text&quot; name=&quot;lname&quot;&gt;&lt;br&gt;
&lt;input type=&quot;submit&quot;&gt;
</code></pre></form><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- form：input&gt; 元素所属的一个或多个表单。</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;html</span><br><span class="line">    &lt;form action&#x3D;&quot;demo-form.php&quot; id&#x3D;&quot;form1&quot;&gt;</span><br><span class="line">    	First name: </span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;fname&quot;&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">    	&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;p&gt; </span><br><span class="line">        &quot;Last name&quot; 字段没有在 form 表单之内，</span><br><span class="line">        但它也是 form 表单的一部分。</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">    </span><br><span class="line">    Last name: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;lname&quot; form&#x3D;&quot;form1&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;p&gt;&lt;b&gt;注意:&lt;&#x2F;b&gt; IE 不支持 form 属性&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>required ：必须在提交之前填写输入域（不能为空）。</p><ul><li><p><code>`</code>html<br></p><form action="" method="post" enctype=""><p></p><pre><code>&lt;label for=&quot;user&quot;&gt;用户名：&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;user&quot; id=&quot;user&quot; required&gt;
&lt;br&gt;
&lt;label for=&quot;password&quot;&gt;密　码：&lt;/label&gt;
&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; &gt; 
&lt;input type=&quot;submit&quot; name=&quot;&quot; value=&quot;提交&quot;&gt;
</code></pre><p></p></form><p></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- checked：状态属性</span><br><span class="line"></span><br><span class="line">  - 默认选中</span><br><span class="line"></span><br><span class="line">- accept：用于指定文件类型</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure><p>accept=”.jpg,.jpeg,.png,.gif”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- file：文件上传  </span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;html</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;pic2&quot; accept&#x3D;&quot;image&#x2F;*&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>multiple：控制是否上传多文件</p></li></ul></li><li><p>number // 数字输入框</p><ul><li><a href="https://www.runoob.com/tags/att-input-max.html" target="_blank" rel="noopener">max</a> - 规定允许的最大值。</li><li><a href="https://www.runoob.com/tags/att-input-min.html" target="_blank" rel="noopener">min</a> - 规定允许的最小值。</li><li><a href="https://www.runoob.com/tags/att-input-step.html" target="_blank" rel="noopener">step</a> - 规定合法数字间隔。</li><li><a href="https://www.runoob.com/tags/att-input-value.html" target="_blank" rel="noopener">value</a> - 规定默认值。</li></ul></li></ul></li><li><p>去除输入框得到焦点时，浏览器出现的蓝色带阴影的边框</p><ul><li><code>`</code>css<br>input{<pre><code>outline: 0;
</code></pre>}<pre><code>OR    
</code></pre>input{<pre><code>focus:outline: none;
</code></pre>}<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- enctype&#x3D;&quot;multipart&#x2F;form-data&quot;  </span><br><span class="line"></span><br><span class="line">  - 指表单数据有多部分构成，既有文本数据，又有文件等二进制数据</span><br><span class="line">  - 默认情况下，enctype的值是application&#x2F;x-www-form-urlencoded，不能用于文件上传，只有使用了multipart&#x2F;form-data，才能完整的传递文件数据。</span><br><span class="line">  - application&#x2F;x-www-form-urlencoded不是不能上传文件，是只能上传文本格式的文件，multipart&#x2F;form-data是将文件以二进制的形式上传，这样可以实现多种类型的文件上传。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|         值          |                             描述                             |</span><br><span class="line">| :-----------------: | :----------------------------------------------------------: |</span><br><span class="line">|       button        |   定义可点击的按钮（通常与 JavaScript 一起使用来启动脚本）   |</span><br><span class="line">|      checkbox       |                          定义复选框                          |</span><br><span class="line">|        file         |        定义文件选择字段和 &quot;浏览...&quot; 按钮，供文件上传         |</span><br><span class="line">|       hidden        |                       定义隐藏输入字段                       |</span><br><span class="line">|        image        |                     定义图像作为提交按钮                     |</span><br><span class="line">|      password       |             定义密码字段（字段中的字符会被遮蔽）             |</span><br><span class="line">|        radio        |                         定义单选按钮                         |</span><br><span class="line">|        reset        |           定义重置按钮（重置所有的表单值为默认值）           |</span><br><span class="line">|       submit        |                         定义提交按钮                         |</span><br><span class="line">|        text         |     默认。定义一个单行的文本字段（默认宽度为 20 个字符）     |</span><br><span class="line">| color(以下为H5新增) |                          定义拾色器                          |</span><br><span class="line">|        date         |         定义 date 控件（包括年、月、日，不包括时间）         |</span><br><span class="line">|      datetime       | 定义 date 和 time 控件（包括年、月、日、时、分、秒、几分之一秒，基于 UTC 时区） |</span><br><span class="line">|   datetime-local    | 定义 date 和 time 控件（包括年、月、日、时、分、秒、几分之一秒，不带时区） |</span><br><span class="line">|        email        |                  定义用于 e-mail 地址的字段                  |</span><br><span class="line">|        month        |             定义 month 和 year 控件（不带时区）              |</span><br><span class="line">|       number        |                    定义用于输入数字的字段                    |</span><br><span class="line">|        range        |   定义用于精确值不重要的输入数字的控件（比如 slider 控件）   |</span><br><span class="line">|       search        |               定义用于输入搜索字符串的文本字段               |</span><br><span class="line">|         tel         |                  定义用于输入电话号码的字段                  |</span><br><span class="line">|        time         |              定义用于输入时间的控件（不带时区）              |</span><br><span class="line">|         url         |                   定义用于输入 URL 的字段                    |</span><br><span class="line">|        week         |              定义 week 和 year 控件（不带时区）              |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### **textarea**：定义一个多行的文本输入控件</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">&lt;textarea rows&#x3D;&quot;10&quot; cols&#x3D;&quot;30&quot;&gt;</span><br><span class="line">我是一个文本框。</span><br><span class="line">&lt;&#x2F;textarea&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>说明</p><ul><li><p>autofocus：当页面加载时，文本区域自动获得焦点。</p></li><li><p>cols：文本区域内可见的宽度。</p><ul><li>值：数字</li></ul></li><li><p>disabled：禁用文本区域。</p></li><li><p>form：文本区域所属的一个或多个表单。</p><ul><li><code>`</code>html<br><form action="demo-form.php" id="usrform"><pre><code>  Name: 
&lt;input type=&quot;text&quot; name=&quot;usrname&quot;&gt;
  &lt;input type=&quot;submit&quot;&gt;
</code></pre></form><br><br><br><textarea rows="4" cols="50" name="comment" form="usrform"><br>输入内容…<br></textarea><br><p><pre><code>以上的表单在文本框之外，但是它仍是表单中的一部分。&lt;/p&gt;
</code></pre></p><p><pre><code>&lt;b&gt;注意：&lt;/b&gt; 
IE 不支持 form 属性。
</code></pre></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  * maxlength：文本区域允许的最大字符数。</span><br><span class="line"></span><br><span class="line">    * 值：数字</span><br><span class="line"></span><br><span class="line">  * name：文本区域的名称</span><br><span class="line"></span><br><span class="line">  * placeholder：提示</span><br><span class="line"></span><br><span class="line">  * readonly：规定文本区域为只读。</span><br><span class="line"></span><br><span class="line">  * required：规定文本区域是必需的&#x2F;必填的。</span><br><span class="line"></span><br><span class="line">  * rows：规定文本区域内可见的行数。</span><br><span class="line"></span><br><span class="line">    * 值：数字</span><br><span class="line"></span><br><span class="line">  * wrap：当提交表单时，文本区域中的文本应该怎样换行。</span><br><span class="line"></span><br><span class="line">    * soft：文本不换行（默认）</span><br><span class="line">    * hard：文本换行（包含换行符）。当使用 &quot;hard&quot; 时，必须指定 cols 属性。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### select：下拉框</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">&lt;select name&#x3D;&quot;city&quot;&gt;</span><br><span class="line">&lt;option value&#x3D;&quot;0&quot;&gt;请选择&lt;&#x2F;option</span><br><span class="line">&lt;option value&#x3D;&quot;bj&quot;&gt;北京&lt;&#x2F;option&gt;</span><br><span class="line">&lt;option value&#x3D;&quot;gz&quot;&gt;广州&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>说明：</p><ul><li>name：名称</li><li>size：下拉框显示的行数</li><li>multiple：是否多选</li><li>disabled：是否禁用</li><li>selected：是否默认选中</li><li>value：选项的值</li></ul></li></ul><h3 id="optgroup：下拉框分组"><a href="#optgroup：下拉框分组" class="headerlink" title="optgroup：下拉框分组"></a>optgroup：下拉框分组</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"city"</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">"广东"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">"其他"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"3"</span>&gt;</span>长沙<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"4"</span>&gt;</span>香港<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h2><ul><li>行内元素：text-align：center；</li><li><p>定宽块元素：margin：0 auto；</p></li><li><p>居中的三个条件：</p><ul><li>必须是块元素(不可以是行元素)</li><li>有明显的宽（width:xxpx）</li><li>margin：0px auto；</li></ul></li><li><p>文本属性居中</p><ul><li>align:设置水平对齐方式（left/right/center/justify）</li><li>valign:设置垂直对齐方式（top/middle/bottom）</li><li>上面的不常用，下面的常用<ul><li>text-align:<ul><li>设置水平对齐方式</li><li>left/right/center/justify</li></ul></li><li>vertial-align:<ul><li>设置垂直对齐方式</li><li>top/middle/bottom</li></ul></li></ul></li></ul><h3 id="水平居中："><a href="#水平居中：" class="headerlink" title="水平居中："></a>水平居中：</h3></li><li><p>给div设置一个宽度，然后添加margin:0 auto属性</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>让绝对定位的div居中</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: bule;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><ul><li><p>确定容器的宽高 宽500 高 300 的层 设置元素的外边距</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">   <span class="attribute">position</span>: relative;     <span class="comment">/* 相对定位或绝对定位均可 */</span></span><br><span class="line">   <span class="attribute">width</span>:<span class="number">500px</span>;</span><br><span class="line">   <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">margin-top</span>: -<span class="number">150px</span>；</span><br><span class="line">   margin-left:  -<span class="number">250px</span>;       <span class="comment">/* 外边距为自身宽高的一半 */</span></span><br><span class="line">   //margin:-150px 0 0 -250px; /*一样*/</span><br><span class="line">   <span class="selector-tag">background-color</span>: <span class="selector-tag">blue</span>; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>未知容器的宽高，利用 transform 属性</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;     <span class="comment">/* 相对定位或绝对定位均可 */</span></span><br><span class="line">    <span class="attribute">width</span>:<span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>利用 flex 布局</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;        <span class="comment">/* 垂直居中 */</span></span><br><span class="line">    <span class="attribute">justify-content</span>: center;    <span class="comment">/* 水平居中 */</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.container</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HTML-文本格式化标签"><a href="#HTML-文本格式化标签" class="headerlink" title="HTML 文本格式化标签"></a>HTML 文本格式化标签</h2><table><thead><tr><th style="text-align:center">标签</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">b</td><td style="text-align:center">定义粗体文本</td></tr><tr><td style="text-align:center">em</td><td style="text-align:center">定义着重文本</td></tr><tr><td style="text-align:center">i</td><td style="text-align:center">定义斜体字</td></tr><tr><td style="text-align:center">small</td><td style="text-align:center">定义小号字</td></tr><tr><td style="text-align:center">strong</td><td style="text-align:center">定义加重语气（HTML5 推荐粗体）</td></tr><tr><td style="text-align:center">sub</td><td style="text-align:center">定义下标字</td></tr><tr><td style="text-align:center">sup</td><td style="text-align:center">定义上标字</td></tr><tr><td style="text-align:center">ins</td><td style="text-align:center">定义插入字</td></tr><tr><td style="text-align:center">del</td><td style="text-align:center">定义删除线</td></tr></tbody></table><ul><li>粗体、斜体、下划线（最好使用CSS语法代替）</li><li>em/strong/: 我们并不反对使用这个标签，但是如果您只是为了达到某种视觉效果而使用这个标签的话，我们建议您使用 CSS ，这样可能会取得更丰富的效果。</li><li>small : small 标签定义小型文本（和旁注）。</li><li>del和ins : &lt;del 和 &lt;ins 一起使用，描述文档中的更新和修正。浏览器通常会在已删除文本上添加一条删除线，在新插入文本下添加一条下划线</li></ul><h2 id="HTML-“计算机输出”-标签"><a href="#HTML-“计算机输出”-标签" class="headerlink" title="HTML “计算机输出” 标签"></a>HTML “计算机输出” 标签</h2><table><thead><tr><th style="text-align:center">标签</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">code</td><td style="text-align:center">定义计算机代码</td></tr><tr><td style="text-align:center">kbd</td><td style="text-align:center">定义键盘码</td></tr><tr><td style="text-align:center">samp</td><td style="text-align:center">定义计算机代码样本</td></tr><tr><td style="text-align:center">var</td><td style="text-align:center">定义变量</td></tr><tr><td style="text-align:center">pre</td><td style="text-align:center">定义预格式文本</td></tr></tbody></table><ul><li><p>kdb : kbd 标签定义键盘文本。</p><p><strong>提示:</strong> kbd标签已废弃，不推荐使用，但 是可以通过CSS实现丰富的效果</p></li><li><p>code : code标签是一个短语标签，用来定义计算机代码文本</p></li><li><p>samp标签是一个短语标签，用来定义计算机程序的样本文本。</p></li><li><p>var标签是一个短语标签，用来定义变量。</p></li><li><p>abbr 标签用来表示一个缩写词或者首字母缩略词，如”WWW”或者”NATO”<br>通过对缩写词语进行标记，您就能够为浏览器、拼写检查程序、翻译系统以及搜索引擎分度器提供有用的信息。</p></li><li><p>samp/var : 我们并不反对使用这个标签，但是如果您只是为了达到某种视觉效果而使用这个标签的话，我们建议您使用 CSS ，这样可能会取得更丰富的效果。</p></li></ul><h2 id="HTML-引文-引用-及标签定义"><a href="#HTML-引文-引用-及标签定义" class="headerlink" title="HTML 引文, 引用, 及标签定义"></a>HTML 引文, 引用, 及标签定义</h2><table><thead><tr><th style="text-align:center">标签</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">abbr</td><td style="text-align:center">定义缩写</td></tr><tr><td style="text-align:center">address</td><td style="text-align:center">定义地址</td></tr><tr><td style="text-align:center">bdo</td><td style="text-align:center">定义文字方向</td></tr><tr><td style="text-align:center">blockquote</td><td style="text-align:center">定义长的引用</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">定义短的引用语</td></tr><tr><td style="text-align:center">cite</td><td style="text-align:center">定义引用、引证</td></tr><tr><td style="text-align:center">dfn</td><td style="text-align:center">定义一个定义项目。</td></tr></tbody></table><ul><li><p>address标签定义文档作者/所有者的联系信息如果</p><p>address元素位于 body元素内部，则它表示该文档作者/所有者的联系信息。</p><p>如果 address元素位于 article 元素内部，则它表示该文章作者/所有者的联系信息。</p><p>address 元素的文本通常呈现为斜体。大多数浏览器会在该元素的前后添加换行。<br><strong>提示：</strong>不应该使用 address 标签来描述邮政地址，除非这些信息是联系信息的组成部分。</p><p><strong>提示：</strong>address 元素通常被包含在footer元素的其他信息中。</p></li><li><p>bdo 指的是 bidi 覆盖（Bi-Directional Override）。 [ ltr : left to right / rtl : right to left ]</p><p>bdo标签用来覆盖默认的文本方向。<br>bdo元素一般用于把一段文本的方向规定为与周围文本的自然方向相反的方向。方向由<strong>必需属性dir</strong>指定。bdo元素很少使用，只用于某些<strong>多语言文档</strong>。在这种文档中，可能有某一段文本使用的语言的阅读方式与文档中其他部分使用的语言的阅读方式不同。</p></li><li><p>blockquote&gt; 标签定义摘自另一个源的块引用。</p><p>浏览器通常会对 blockquote元素进行缩进。</p><p><strong>提示：</strong>如果标记是不需要段落分隔的短引用，请使用q</p></li><li><p>q&gt; 标签定义一个短的引用。</p><p>浏览器经常会在这种引用的周围插入引号。</p><p><strong>提示：</strong>请使用blockquote来标记摘自另一个源的块引用。</p></li><li><p>cite&gt; 标签定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等等）的标题。</p><p><strong>注释：</strong>人名不属于作品的标题。</p></li><li><p>dfn&gt; 标签是一个短语标签，用来定义一个定义项目。</p></li><li><p>dfn : 我们并不反对使用这个标签，但是如果您只是为了达到某种视觉效果而使用这个标签的话，我们建议您使用 CSS ，这样可能会取得更丰富的效果。</p></li></ul><h2 id="HTML元素分类：inline、inline-block、block"><a href="#HTML元素分类：inline、inline-block、block" class="headerlink" title="HTML元素分类：inline、inline-block、block"></a>HTML元素分类：inline、inline-block、block</h2><ul><li><ul><li>inline<ul><li>textarea、span、a、img、input、select</li><li>行内元素特征：<ul><li>设置宽高无效</li><li>对margin仅设置左右方向有效，上下无效；padding设置上下左右都有效，即会撑大空间,行内元素尺寸 由内含的内容决定，盒模型中 padding, border 与块级元素并无差异，都是标准的盒模型，但是 margin 却只有水平方向的值，垂直方向并没有起作用。行内元素的水平方向的padding-left,padding-right,margin- left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都 不会产生边距效果。padding设置上下左右都有效，即会撑大空间但是不会产生边距效果。</li><li>不会自动进行换行</li><li>元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。</li></ul></li></ul></li><li>inline-block<ul><li>行内块状元素特征：<ul><li>不自动换行</li><li>能够识别宽高</li><li>默认排列方式为从左到右</li></ul></li></ul></li><li>block<ul><li>div、p、ul、h1等标题元素、ol、form、table<br>块状元素特征：<ul><li>能够识别宽高</li><li>margin和padding的上下左右均对其有效</li><li>可以自动换行</li><li>多个块状元素标签写在一起，默认排列方式为从上至下</li></ul></li></ul></li></ul></li><li><p>inline-block和float的区别</p><ul><li>文档流（Document flow）:浮动元素会脱离文档流，并使得周围元素环绕这个元素。而inline-block元素仍在文档流内。因此设置inline-block不需要清除浮动。当然，周围元素不会环绕这个元素，你也不可能通过清除inline-block就让一个元素跑到下面去。</li><li>水平位置（Horizontal position）：很明显你不能通过给父元素设置text-align:center让浮动元素居中。事实上定位类属性设置到父元素上，均不会影响父元素内浮动的元素。但是父元素内元素如果设置了display：inline-block，则对父元素设置一些定位属性会影响到子元素。（这还是因为浮动元素脱离文档流的关系）。</li><li>垂直对齐（Vertical alignment）：inline-block元素沿着默认的基线对齐。浮动元素紧贴顶部。你可以通过vertical属性设置这个默认基线，但对浮动元素这种方法就不行了。这也是我倾向于inline-block的主要原因。</li><li>空白（Whitespace）：inline-block包含html空白节点。如果你的html中一系列元素每个元素之间都换行了，当你对这些元素设置inline-block时，这些元素之间就会出现空白。而浮动元素会忽略空白节点，互相紧贴.</li><li>scrolling=”no”<br>隐藏滚动条</li></ul></li><li><p>html很多标签都有默认样式，因此最好在样式中一开始就给表单标签去除默认的样式问题</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">input</span>,<span class="selector-tag">select</span>,<span class="selector-tag">option</span>,<span class="selector-tag">textarea</span>&#123;<span class="attribute">outline</span>: none;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body onload&#x3D;&quot;init()&quot;&gt;&#x2F;&#x2F;打开页面的同时调用init</span><br></pre></td></tr></table></figure><h2 id="OTHER（应合理分类并及时归类）"><a href="#OTHER（应合理分类并及时归类）" class="headerlink" title="OTHER（应合理分类并及时归类）"></a>OTHER（应合理分类并及时归类）</h2><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2019/07/07/JavaScript/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h1><h2 id="js实现继承的几种方式-https-www-cnblogs-com-chaixiaozhi-p-8515087-html"><a href="#js实现继承的几种方式-https-www-cnblogs-com-chaixiaozhi-p-8515087-html" class="headerlink" title="js实现继承的几种方式(https://www.cnblogs.com/chaixiaozhi/p/8515087.html)"></a>js实现继承的几种方式(<a href="https://www.cnblogs.com/chaixiaozhi/p/8515087.html" target="_blank" rel="noopener">https://www.cnblogs.com/chaixiaozhi/p/8515087.html</a>)</h2><h3 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h3><ul><li>核心：<em>将父类的实例作为子类的原型</em></li><li>缺点：<em>父类新增原型方法/原型属性，子类都能访问到，父类一变其他的都变了</em></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span> name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//对原型进行扩展</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Parent.prototype = <span class="keyword">new</span> Person(<span class="string">'老明'</span>);<span class="comment">//关键//通过构造器函数创建出一个新对象，把老对象的东西拿过来</span></span><br><span class="line"></span><br><span class="line">Parent.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Parent.prototype.getName = function()&#123;   </span></span><br><span class="line"><span class="comment">//可以重写父类继承来的方法，会优先调用自己的</span></span><br><span class="line"><span class="comment">//   console.log(222);</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> Parent(<span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result.getName());<span class="comment">//老明//调用了从Person原型中继承来的方法(继承到了当前对象的原型中)</span></span><br><span class="line">	<span class="built_in">console</span>.log(result.getAge());<span class="comment">//22//调用了从Parent原型中扩展来的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、构造继承"><a href="#2、构造继承" class="headerlink" title="2、构造继承"></a>2、构造继承</h3><ul><li>基本思想<ul><li>借用构造函数的基本思想就是利用call或者apply把父类中通过this指定的属性和方法复制(借用)到子类创建的实例中</li><li>因为this对象是运行时基于函数的执行环境绑定的。也就是说，在全局中，this等于Windows，而当函数被作为某个对象的方法调用时，this等于那个对象</li><li>call、apply方法可将与一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象</li><li>所以，这个借用构造函数就是，new对象的时候(new创建的时候，this指向创建的这个实例)，</li></ul></li></ul><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown文档Typora编辑器用法</title>
    <url>/2019/05/10/MarkDown%E6%96%87%E6%A1%A3Typora%E7%BC%96%E8%BE%91%E5%99%A8%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><p>1、标题<br>使用简单的 ctrl+数字键 就可以快速完成各种级别的标题</p><p>2、下划线<br>ctrl + u</p><p>3、删除线<br>alt + shift + 5</p><p>4、字体加粗<br>ctrl + b</p><p>5、字体倾斜<br>ctrl + i</p><p>6、无序列表</p><p>“-” + space + enter</p><p>嵌套无序列表</p><p>7、有序列表<br>数字键 + space + enter</p><p>8、引用</p><p>“&gt;” + space + enter 或者 ctrl + shift + q</p><p>9、插入链接<br>ctrl + k</p><p>10、插入图片<br>本地直接拖拉图片到 md 文件</p><p>或者</p><p>配合 MPic完成图片上传图床并复制链接到 md 文件（推荐）</p><p>或者</p><p>ctrl + shift + i</p><p>11、代码块<br>ctrl + shift + f，支持 java，python，groovy 等 绝大多数编程语言</p><p>12、文章跳转<br>ctrl + home 跳转至文章开头，ctrl + end 跳转至文章末尾，这个就不再演示了</p><p>13、选中英文单词/中文<br>ctrl + d 或者 ctrl + shift + left/right 左右进行文本选中</p><p>14、英文错误提示并自动修改</p><p>15、按行选中<br>ctrl + l</p><p>16、快速搜索<br>ctrl + f</p><p>支持区分英文大小写和整个单词搜索，也支持中文搜索</p><p>17、替换<br>ctrl + h</p><p>18、快速生成表格<br>ctrl + t</p><p>19、快速打开笔记<br>ctrl + p</p><p>20、toc 快速生成目录<br>[toc] + enter</p><p>21、着重关键字<br>ctrl + shift + 反引号键（tab 键上面那个键）</p><p>因为主题原因这里看不出来，换个主题就很明显了</p><p>22、表情符号<br>英文状态下的引号，输入字母自动显示表情符号</p><p>还有一种方式，使用输入法的快捷键，这里我使用的是微软输入法 ctrl + shift + b</p><p>23、新建文件<br>ctrl + n，这个就不再演示了</p><p>24、显示和隐藏侧边栏<br>ctrl + shift + l</p><p>25、全屏切换<br>f11 这个就不再演示了</p><p>26、分割线<br>— + enter，这个也不再演示</p><p>27、高亮显示<br>==文字==，这个也不再演示</p><p>28、创建表格</p><p>Ctrl + T</p><p>29、段落快捷键<br>ctrl + 0</p><p>30、定义脚注<br>文字 [ + ^ + 脚注 + ]</p><p>31、插入URL链接</p><p>&lt; + 链接 + &gt;</p><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2019/11/10/Linux-samba/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><h1 id="samba服务"><a href="#samba服务" class="headerlink" title="samba服务"></a>samba服务</h1><ul><li>yum install samba<ul><li></li></ul></li></ul><h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><ul><li>yum clean all<ul><li>yum 会把下载的软件包和header存储在cache中，而不自动删除</li><li>如果觉得占用磁盘空间，可以使用yum clean指令进行清除，更精确 的用法是<ul><li>yum clean headers清除header</li><li>yum clean packages清除下载的rpm包</li><li>yum clean all一全部清除</li></ul></li></ul></li><li>yum check-update<ul><li>列出所有可更新的软件清单</li></ul></li><li>yum update<ul><li>更新所有软件</li></ul></li><li>yum install &lt;package_name&gt;<ul><li>仅安装指定的软件</li></ul></li><li>yum update &lt;package_name&gt;<ul><li>仅更新指定的软件</li></ul></li><li>yum list<ul><li>列出所有可安裝的软件清单</li></ul></li></ul><h1 id="TIPs"><a href="#TIPs" class="headerlink" title="TIPs"></a>TIPs</h1><ul><li><p>环回网卡的作用</p><ul><li><p>可以在实验中用到，有的实验需要网卡处于连接状态，而此时你的物理网卡没有连接网线，于是就可以使用“环回网卡”来欺骗操作系统 - 网卡已经连接了。同理，虚拟光驱有时候也用于欺骗，即，光盘已经挂载上了~</p></li><li><p>microsoft loopback adapter就是安装在本机上的一块虚拟网卡，它跟本机上的其它物理网卡、和物理网卡连接的网络是没有关系的，你可以理解成这块网卡上的网线接到了另外一个空白网络。</p><p>它的作用仅仅是用来给那些需要本机配置有网络的服务程序调试用，它不能与实体网络进行通信。</p><p>举个最简单的例子，你的电脑没有网卡，想给本机安装WINDOWS的DNS服务试着玩，但DNS服务在启动时若检测到本机没有网络会报错停止，这时你安装块loopback adapter网卡就有用了</p></li></ul></li></ul><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>PHP</title>
    <url>/2019/07/24/PHP/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><p>mysql_connect()连接数据库</p><p>mysql_select_db选择数据库</p><p>mysql_fetch_assoc()获取结果集</p><p>mysql_query()执行sql语句</p><p>php<br>intval() 函数用于获取变量的整数值。<br>intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。</p><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql</title>
    <url>/2019/07/24/MySql/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul><li>数据库<ul><li>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</li></ul></li><li>RDBMS 即关系数据库管理系统(Relational Database Management System)的特点：<ul><li>1.数据以表格的形式出现</li><li>2.每行为各种记录名称</li><li>3.每列为记录名称所对应的数据域</li><li>4.许多的行和列组成一张表单</li><li>5.若干的表单组成database</li></ul></li><li>RDBMS术语<ul><li><strong>数据库:</strong> 数据库是一些关联表的集合。</li><li><strong>数据表:</strong> 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li><li><strong>列:</strong> 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。</li><li><strong>行：</strong>一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li><li><strong>冗余</strong>：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li><li><strong>主键</strong>：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li><li><strong>外键：</strong>外键用于关联两个表。</li><li><strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li><li><strong>索引：</strong>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li><li><strong>参照完整性:</strong> 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</li></ul></li></ul><h1 id="MySql常用命令行"><a href="#MySql常用命令行" class="headerlink" title="MySql常用命令行"></a>MySql常用命令行</h1><ul><li>连接数据库格式：<ul><li>mysql -h主机地址 -u用户名 －p用户密码</li></ul></li><li>查看数据库：<ul><li>show databases;</li></ul></li><li>选择并进入数据库<ul><li>use databasename;</li></ul></li><li>查看表<ul><li>show tables;</li></ul></li><li>查看表结构<ul><li>desc tablename;</li></ul></li><li>查看表数据<ul><li>select * from tablename;</li></ul></li><li>where条件语句<ul><li>select student_age from pre_student where student_age &gt; 14 and student_age &lt; 18;</li></ul></li><li>in枚举查询<ul><li>SELECT * FROM pre_article WHERE aid IN (1, 3, 5)</li></ul></li><li>%模糊查询<ul><li>SELECT <em>FROM pre_user WHERE username like “%张%”; // 所有<br>SELECT </em>FROM pre_user WHERE username like “%张”; // 小张张<br>SELECT * FROM pre_user WHERE username like “_张%”; // 小张张 大张伟</li><li>%：代替一个或多个字符</li><li>_：代替一个字符</li></ul></li><li>limit限制<ul><li>SELECT * FROM table LIMIT 5; // 直接查条数</li><li>SELECT * FROM table LIMIT （index, length）; // 以哪个下标开始，共多少条数据。</li></ul></li><li>order by排序<ul><li>降序：desc</li><li>升序：asc</li><li>select * from pre_student order by student_age desc</li></ul></li><li>插入数据<ul><li>INSERT INTO user (username,password) VALUES (‘admin’,’123456’);</li></ul></li><li>修改数据(必须指定条件 where，不然全部都会被修改到！)<ul><li>UPDATE user SET username = ‘admin1’, passwd =’12345678’ WHERE uid = 10</li></ul></li><li>删除数据<ul><li>DELETE FROM user WHERE uid = 10</li></ul></li><li></li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li><p><strong>my.ini</strong></p><ul><li><pre><code class="mysql">[client]
# 设置mysql客户端默认字符集
default-character-set=utf8

[mysqld]
# 设置3306端口
port = 3306
# 设置mysql的安装目录
basedir=C:\\web\\mysql-8.0.11
# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错
# datadir=C:\\web\\sqldata
# 允许最大连接数
max_connections=20
# 服务端使用的字符集默认为8比特编码的latin1字符集
character-set-server=utf8
# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
</code></pre></li></ul></li></ul><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js</title>
    <url>/2019/08/13/Node-js/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h1><h2 id="NodeJS访问数据库"><a href="#NodeJS访问数据库" class="headerlink" title="NodeJS访问数据库"></a>NodeJS访问数据库</h2><h3 id="mysqljs"><a href="#mysqljs" class="headerlink" title="mysqljs"></a>mysqljs</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"><span class="keyword">var</span> connection = mysql.createConnection(mysqlConfig);</span><br><span class="line"></span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line">connection.query(<span class="string">'SELECT 1 + 1 AS solution'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,results,fields</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(error)<span class="keyword">throw</span> error;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The solution is:'</span>,results[<span class="number">0</span>].solution);</span><br><span class="line">&#125;);</span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure><h3 id="egg-mysql"><a href="#egg-mysql" class="headerlink" title="egg-mysql"></a>egg-mysql</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> results = <span class="keyword">yield</span> app.mysql.select(<span class="string">'posts'</span>,&#123;</span><br><span class="line">    where:&#123;<span class="attr">status</span>:<span class="string">'draft'</span>&#125;,</span><br><span class="line">    orders:[[<span class="string">'create_at'</span>,<span class="string">'desc'</span>],[<span class="string">'id'</span>,<span class="string">'desc'</span>]],</span><br><span class="line">    limit:<span class="number">10</span>,</span><br><span class="line">    offset:<span class="number">0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="写SQL实现一个服务端分页"><a href="#写SQL实现一个服务端分页" class="headerlink" title="写SQL实现一个服务端分页"></a>写SQL实现一个服务端分页</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拼接各种条件</span></span><br><span class="line"><span class="keyword">let</span> whereSql = <span class="string">'where online_version is not null and state &lt;&gt; 1'</span>;</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="string">'only'</span>) &#123;</span><br><span class="line">  whereSql += <span class="string">' and use_scope like "%'</span> + query.use_scope + <span class="string">'%"'</span>;</span><br><span class="line">&#125;</span><br><span class="line">whereSql += handleIn(query) + handleEqual(query) + handleLike(query);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得全部数据条数</span></span><br><span class="line"><span class="keyword">const</span> sqlTotal = <span class="string">'select count(*) as total from component'</span> + whereSql;</span><br><span class="line"><span class="keyword">const</span> resultTotal = <span class="keyword">yield</span> <span class="keyword">this</span>.app.mysql.query(sqlTotal, values);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得当前页数据</span></span><br><span class="line"><span class="keyword">let</span> sqlSelect = <span class="string">'select * from component'</span></span><br><span class="line">sqlSelect += whereSql;</span><br><span class="line">sqlSelect += <span class="string">' order by modified_time desc, id desc limit '</span>;</span><br><span class="line">sqlSelect += (pageIndex - <span class="number">1</span>) * pageSize + <span class="string">','</span> + pageSize;</span><br><span class="line"><span class="keyword">const</span> resultList = <span class="keyword">yield</span> <span class="keyword">this</span>.app.mysql.query(sqlSelect, values);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回分页结果</span></span><br><span class="line"><span class="keyword">const</span> result = &#123;</span><br><span class="line">  list: resultList,</span><br><span class="line">  total: resultTotal[<span class="number">0</span>].total,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>那有没有更简洁的方法去操作数据库呢，答案是肯定的社区有很多优秀的orm或sql builder的类库比如objection、sequelize、knexjs、squel等。</p><h2 id="同步太多容易造成异步回调黑洞"><a href="#同步太多容易造成异步回调黑洞" class="headerlink" title="同步太多容易造成异步回调黑洞"></a>同步太多容易造成异步回调黑洞</h2><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ul><li><p>nodejs导出导入原理</p><ul><li>？？</li></ul></li><li></li></ul><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端知识点</title>
    <url>/2019/09/28/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><h1 id="1、CSS禁用鼠标点击"><a href="#1、CSS禁用鼠标点击" class="headerlink" title="1、CSS禁用鼠标点击"></a>1、CSS禁用鼠标点击</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.disabled</span> &#123;</span><br><span class="line">    <span class="attribute">pointer-events</span>: none;</span><br><span class="line">    <span class="attribute">cursor</span>: default;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、get-post的理解和他们之间的区别"><a href="#2、get-post的理解和他们之间的区别" class="headerlink" title="2、get/post的理解和他们之间的区别"></a>2、get/post的理解和他们之间的区别</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><ul><li>超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。HTTP的工作方式是客户机与服务器之间的请求-应答协议。web浏览器可能是客户端也可能作为服务器端。</li></ul><h2 id="HTTP方法："><a href="#HTTP方法：" class="headerlink" title="HTTP方法："></a>HTTP方法：</h2><ul><li><p>HEAD：与GET相同，但只返回HTTP报头，不返回文档主体</p></li><li><p>PUT：上传指定的URI表示</p></li><li><p>DELETE：删除指定的资源</p></li><li><p>OPTIONS：返回服务器的支持的HTTP方法</p></li><li><p>CONNECT：把请求连接转换到透明的TCP/IP通道</p></li><li><p>POST：向指定的资源提交要被处理的数据</p></li><li><pre><code class="javascript"><span class="comment">// 查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的</span>
POST /test/demo_form.asp HTTP/<span class="number">1.1</span>
Host: w3schools.com
name1=value1&amp;name2=value2
</code></pre></li><li><p>GET：从指定的资源请求数据</p></li></ul><p><a href="https://juejin.im/post/5d8989296fb9a06b1f147070?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/5d8989296fb9a06b1f147070?utm_source=gold_browser_extension</a></p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>LIKE</title>
    <url>/2019/10/06/LIKE/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>前端面试题</title>
    <url>/2019/09/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><h1 id="前端综合"><a href="#前端综合" class="headerlink" title="前端综合"></a>前端综合</h1><h2 id="http从输入地址开始到浏览器渲染做了什么？"><a href="#http从输入地址开始到浏览器渲染做了什么？" class="headerlink" title="http从输入地址开始到浏览器渲染做了什么？"></a>http从输入地址开始到浏览器渲染做了什么？</h2><ol><li><p>浏览器进行地址解析</p><ol><li>浏览器得到url地址后开始解析，获取该地址的端口号、域名、协议、路径等信息</li><li>有些信息不是必须的，浏览器会默认补齐</li></ol></li><li><p>将解析的域名进行dns解析</p><p>将第一步的解析信息转换成对应的IP地址，这就是DNS解析，分为以下步骤</p><ol><li>首先查看浏览器中是否有对应的DNS缓存，如果有则直接使用</li><li>如果没有查看操作系统DNS是否有对应的值（ｈｏｓｔ文件）</li><li>如果还是没有则向本地DNS服务商发送查询请求</li><li>如果仍然没有则直接Root　Server域名服务器请求解析</li></ol></li><li><p>通过IP地址寻找服务器地址</p><ol><li>获取到IP地址后寻找IP地址对应的服务器</li></ol></li><li><p>与服务器进行三次握手建立连接</p><ol><li>浏览器请求报文到达服务器之后，服务器接口会对请求报文进行处理，执行接口对应的代码，处理完成响应客户端。由于ｈｔｔｐ是无状态的，正常情况下，客户端收到响应后就会直接断开连接，然后一次HTTP事务就完成了。但是ｈｔｔｐ　１.０有一个ｋｅｅｐ－ａｌｉｖｅ的请求字段，可以在一定时间内不断开（有时时间甚至很长）。HTTP　１.１直接就默认开启了ｋｅｅｐ－ａｌｉｖｅ选项。这导致了一个严重的后果是服务器已经处理完请求，但是客户端不会主动断开连接，这就导致服务器资源一直被占用。这时服务器就不得不自己主动断开连接，而主动断开连接，而主动断开连接的一方会出现TIME_WAIT,占用连接池，这就是产生SYN　Flood攻击的原因</li></ol></li><li><p>浏览器发送数据，等待服务器的响应</p></li><li><p>服务器响应并返回数据</p></li><li><p>浏览器接受到数据</p></li><li><p>浏览器开始渲染页面</p></li></ol><h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1><h2 id="JavaScript基本数据类型有哪些"><a href="#JavaScript基本数据类型有哪些" class="headerlink" title="JavaScript基本数据类型有哪些"></a>JavaScript基本数据类型有哪些</h2><ol><li>Number</li><li>Boolean</li><li>String</li><li>Null</li><li>Underfined</li><li>Symbol</li></ol><h2 id="＝＝与＝＝＝的区别"><a href="#＝＝与＝＝＝的区别" class="headerlink" title="＝＝与＝＝＝的区别"></a>＝＝与＝＝＝的区别</h2><ul><li>＝＝会自动转换数据类型再进行比较</li><li>＝＝＝不会转换数据类型，数据类型不一致时直接false，一致再比较</li></ul><h2 id="事件委托代理"><a href="#事件委托代理" class="headerlink" title="事件委托代理"></a>事件委托代理</h2><p>在构建应用程序时，有时需要将事件绑定到页面上的按钮、文本或图像，以便在用户与元素交互时执行某些操作。</p><p>如果我们以一个简单的代办事项列表为例，面试官可能会告诉你，当用户点击列表中的一个列表项时执行某些操作。他们希望你用JavaScript实现这个功能，假设设有如下HTML代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"todo-app"</span>&gt;</span><br><span class="line">  &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;Walk the dog&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li class="item"&gt;Pay bills&lt;/</span>li&gt;</span><br><span class="line">  &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;Make dinner&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li class="item"&gt;Code for one hour&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br></pre></td></tr></table></figure><h1 id="NodeJS"><a href="#NodeJS" class="headerlink" title="ＮｏｄｅＪＳ"></a>ＮｏｄｅＪＳ</h1><h2 id="nodejs导出导入原理"><a href="#nodejs导出导入原理" class="headerlink" title="nodejs导出导入原理"></a>nodejs导出导入原理</h2><ul><li>？</li></ul><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>政治</title>
    <url>/2019/10/20/%E6%94%BF%E6%B2%BB/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>学习方法（三）：超强的学习能力</title>
    <url>/2019/10/20/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E4%B8%89/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><p><img src="https://pic2.zhimg.com/v2-d193722c862cc210f2c7cdd239c866a8_r.jpg" alt="img" style="zoom:200%"></p><p><img src="https://pic4.zhimg.com/v2-9546ce05ac00f893376966ebdce13bc3_r.jpg" alt="img" style="zoom:200%"></p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>学习方法（一）：记忆</title>
    <url>/2019/10/20/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><h1 id="北大中文系（大段文字的记忆方法：怎么记，以及怎么才能不忘记，做到信手拈来地引用-是记不是背）"><a href="#北大中文系（大段文字的记忆方法：怎么记，以及怎么才能不忘记，做到信手拈来地引用-是记不是背）" class="headerlink" title="北大中文系（大段文字的记忆方法：怎么记，以及怎么才能不忘记，做到信手拈来地引用//是记不是背）"></a>北大中文系（大段文字的记忆方法：怎么记，以及怎么才能不忘记，做到信手拈来地引用//是记不是背）</h1><ul><li>死死撑住，把它看完，并实践</li><li>一个重要的前提是：考试对这段文字的要求是，记住主要观点，能够化为己用；但并不需要一字不差地写于卷面上</li></ul><h2 id="一、短时记忆-》-加工-》-长时记忆"><a href="#一、短时记忆-》-加工-》-长时记忆" class="headerlink" title="一、短时记忆 》 加工 》 长时记忆"></a>一、短时记忆 》 加工 》 长时记忆</h2><ul><li>机械复述并不能有效增强记忆，只是短时记忆</li><li>要想记得快记得牢记得久，一定要经过充分的、有一定深度的加工，将短时记忆转化为长时记忆。</li><li>长时记忆没有容量限制，保存时间也更为长久</li><li>加工是指：对知识点加以自己的处理。对于记忆大段文字来说，加工的关键在于，用自己的语言叙述出来</li></ul><h2 id="二、原文-》-提炼-》-精细复述"><a href="#二、原文-》-提炼-》-精细复述" class="headerlink" title="二、原文 》 提炼 》 精细复述"></a>二、原文 》 提炼 》 精细复述</h2><ul><li><p>记东西并不是一次就能记住的，需要重复。机械复述的首次记忆并不牢靠，在第二次、第三次记忆时，依然需要耗费很多时间</p></li><li><p>书本的表述非常详细，但其目的是为了让读者更好的理解，绝非需要全部记忆。一般来说，提取最关键的几句话，就足够了</p></li><li>跟直接背诵原文相比，精细复述所要记忆的内容减少，速度并不比机械复述慢，甚至快的多</li><li>而且，越是在后面的复习中，精细复述的优势越能展现出来。你只会越来越熟练</li></ul><h2 id="三、如何用自己的语言叙述出来"><a href="#三、如何用自己的语言叙述出来" class="headerlink" title="三、如何用自己的语言叙述出来"></a>三、如何用自己的语言叙述出来</h2><ul><li>记忆书本原有的关键词、知识点等点信息，而后自己去连点成线。<ul><li>指的是把这一块的点信息串成有逻辑的内容</li><li>记住关键词和知识点之后，记关系：并列、因果、时间、空间、人物事件</li><li>用自己的语言逻辑、语言系统，把关键词串起来</li><li>想想把关键词连接起来的是什么</li></ul></li><li>示例：</li><li>关于长期睡眠不足：<ul><li>更容易感到压力、萌生欲望、受到诱惑、很难控制情绪和集中注意力</li><li>加工</li><li>增加压力、减弱控制力、情绪失控、注意力不足</li></ul></li></ul><h2 id="四、连点成线"><a href="#四、连点成线" class="headerlink" title="四、连点成线"></a>四、连点成线</h2><h3 id="三点"><a href="#三点" class="headerlink" title="三点"></a>三点</h3><ul><li>只需记关键词和逻辑关系，省时</li><li>串起来相当于进行了编码（心理学名词，意指对知识点进行加工处理），一定程度上说时自己的用语言</li><li>串起来时，有主动回想知识点的行为，相当于检测，主动回想而非机械重复，才是记忆的关键</li></ul><h3 id="另一个好处是"><a href="#另一个好处是" class="headerlink" title="另一个好处是"></a>另一个好处是</h3><ul><li>能够帮助你在考场上更流畅地答题</li><li>因为你已经预先进行了对逻辑关系的梳理，以及对语言表达的练习</li></ul><h2 id="五、记少不记多"><a href="#五、记少不记多" class="headerlink" title="五、记少不记多"></a>五、记少不记多</h2><ul><li>如果时某一块知识点，有很多诠释性的句子，彼此补充、互相解释，那么选取最核心的那句话进行记忆。不必非是一句话，两三句都可以，剩下的暂时舍弃，即使它们补充了许多细节，但只记核心句即可<ul><li>这么做的原因是<ul><li>教材和论著上的表达，往往过于详实、细节丰盈、内容量大，但书本是为了帮助理解。</li><li>往往一整块材料，只需提炼最关键的几句话，除了那些真正需要一字不差写的，基本看个人发挥</li><li>记少会让你记得更多，并不是你真的舍弃</li></ul></li></ul></li></ul><h2 id="六、记少是为了更好的记多"><a href="#六、记少是为了更好的记多" class="headerlink" title="六、记少是为了更好的记多"></a>六、记少是为了更好的记多</h2><ul><li>记少是指在第一次第二次记忆的时候</li><li>这时候的记少，可以减少任务量、缩减复习时间；并且，由于少，也熟悉的更快，记得更牢，能够提高记忆内容的覆盖面<ul><li>当考试时，基本能把关键观点全部罗列出来，时间不足时，尤其需要这么做</li></ul></li><li>在第三遍复习时，核心观点已成为你的已有的知识经验<ul><li>那么，当你把这一段段落剩下的陌生内容，与已有的知识经验结合记忆时，会更高效</li><li>因为这些知识点，只是相对陌生，它们与之前记下的核心观点，有着千丝万缕的关系。</li><li>如果你一开始就记多，相当于全部在记忆陌生内容，高下立见</li></ul></li></ul><h2 id="七、即使只记少，那也很能打"><a href="#七、即使只记少，那也很能打" class="headerlink" title="七、即使只记少，那也很能打"></a>七、即使只记少，那也很能打</h2><ul><li>当你真正理解、牢固记忆了某一块段落的核心观点，在后续记多的时候，你会发现剩下的几乎不需要记了，它们表达的东西，和核心观点无大差别</li><li>这是因为，一开始，这块知识点对我们而言，全部是陌生的，所以才觉得全部需要记忆。但是熟悉之后，方能看到它们的共通之处。那么这个时候，少也不必再增多了</li><li>总之，无论时间是否充足，在面对大量需要记忆的内容时，都先记少，有时间再继续记多</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><h3 id="想长期记忆内容，必须经过加工。机械复述并不能有效增强记忆"><a href="#想长期记忆内容，必须经过加工。机械复述并不能有效增强记忆" class="headerlink" title="想长期记忆内容，必须经过加工。机械复述并不能有效增强记忆"></a>想长期记忆内容，必须经过加工。机械复述并不能有效增强记忆</h3></li><li><h3 id="加工的意思是，对知识点加以自己的处理。对于记忆大段文字来说，加工的关键在于，用自己的语言叙述出来"><a href="#加工的意思是，对知识点加以自己的处理。对于记忆大段文字来说，加工的关键在于，用自己的语言叙述出来" class="headerlink" title="加工的意思是，对知识点加以自己的处理。对于记忆大段文字来说，加工的关键在于，用自己的语言叙述出来"></a>加工的意思是，对知识点加以自己的处理。对于记忆大段文字来说，加工的关键在于，用自己的语言叙述出来</h3></li><li><h3 id="精细进行复述是存储信息最有效的方法，它是指把要记住的内容和已有的知识经验联系起来"><a href="#精细进行复述是存储信息最有效的方法，它是指把要记住的内容和已有的知识经验联系起来" class="headerlink" title="精细进行复述是存储信息最有效的方法，它是指把要记住的内容和已有的知识经验联系起来"></a>精细进行复述是存储信息最有效的方法，它是指把要记住的内容和已有的知识经验联系起来</h3></li><li><h3 id="再记忆大段文字时，转化为自己的语言，之所以高效，是因为我们自己的语言系统、叙述风格和习惯，也属于已有的知识经验"><a href="#再记忆大段文字时，转化为自己的语言，之所以高效，是因为我们自己的语言系统、叙述风格和习惯，也属于已有的知识经验" class="headerlink" title="再记忆大段文字时，转化为自己的语言，之所以高效，是因为我们自己的语言系统、叙述风格和习惯，也属于已有的知识经验"></a>再记忆大段文字时，转化为自己的语言，之所以高效，是因为我们自己的语言系统、叙述风格和习惯，也属于已有的知识经验</h3></li><li><h3 id="跟机械复述相比，精细复述所要记忆的内容少、速度快，而且，记忆效果更牢靠"><a href="#跟机械复述相比，精细复述所要记忆的内容少、速度快，而且，记忆效果更牢靠" class="headerlink" title="跟机械复述相比，精细复述所要记忆的内容少、速度快，而且，记忆效果更牢靠"></a>跟机械复述相比，精细复述所要记忆的内容少、速度快，而且，记忆效果更牢靠</h3></li><li><h3 id="如何用自己的语言叙述出来？记忆书本原有的关键词、知识点等点信息，以及逻辑关系，而后用自己的语言逻辑、语言系统，把关键词串起来，连点成线"><a href="#如何用自己的语言叙述出来？记忆书本原有的关键词、知识点等点信息，以及逻辑关系，而后用自己的语言逻辑、语言系统，把关键词串起来，连点成线" class="headerlink" title="如何用自己的语言叙述出来？记忆书本原有的关键词、知识点等点信息，以及逻辑关系，而后用自己的语言逻辑、语言系统，把关键词串起来，连点成线"></a>如何用自己的语言叙述出来？记忆书本原有的关键词、知识点等点信息，以及逻辑关系，而后用自己的语言逻辑、语言系统，把关键词串起来，连点成线</h3></li><li><h3 id="一定要有串起来进行表述的这个练习，不但有助于记忆，而且有助于答题"><a href="#一定要有串起来进行表述的这个练习，不但有助于记忆，而且有助于答题" class="headerlink" title="一定要有串起来进行表述的这个练习，不但有助于记忆，而且有助于答题"></a>一定要有串起来进行表述的这个练习，不但有助于记忆，而且有助于答题</h3></li><li><h3 id="记忆大段文字的诀窍，是记少不记多，而后由少记多"><a href="#记忆大段文字的诀窍，是记少不记多，而后由少记多" class="headerlink" title="记忆大段文字的诀窍，是记少不记多，而后由少记多"></a>记忆大段文字的诀窍，是记少不记多，而后由少记多</h3></li><li><h3 id="选取最核心的那句话进行记忆，把它变成自己已有的知识经验，而后再去记多"><a href="#选取最核心的那句话进行记忆，把它变成自己已有的知识经验，而后再去记多" class="headerlink" title="选取最核心的那句话进行记忆，把它变成自己已有的知识经验，而后再去记多"></a>选取最核心的那句话进行记忆，把它变成自己已有的知识经验，而后再去记多</h3></li><li><h3 id="当你记住少之后，很多时候已经不需要继续记多"><a href="#当你记住少之后，很多时候已经不需要继续记多" class="headerlink" title="当你记住少之后，很多时候已经不需要继续记多"></a>当你记住少之后，很多时候已经不需要继续记多</h3></li></ul><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2019/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>先进后出(Last in First out) =&gt;有序集合</li><li>新添加与待删除都是在栈尾，称作栈顶，另一端为栈底</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>先进先出(First in First out) =&gt;有序项</li><li>尾部添加新元素，头部移除元素，最新添加的元素必须排在队列的末尾</li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>有序的元素集合 =&gt; 不同于数组，元素在内存中不连续放置</li><li>每个元素由一个元素本身节点和一个指向下一个元素的引用(指针 / 链接)组成</li></ul><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul><li>由一组无序且唯一的项组成</li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul><li>以【键，值】对为数据形态的数据结构 =&gt; 键名用来查询特定元素</li></ul><h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><ul><li>根据关键码值 ( Key Value ) 直接进行访问</li><li>通过把关键码值映射到表中的一个位置来访问记录，以加快查找速度</li><li>映射函数叫做散列函数，存放记录的数组叫做散列数组</li></ul><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul><li><p>由 n ( n &gt; = 1 ) 个有限节点组成的一个具有层次关系的集合，呈一对多关系</p></li><li><p>根节点至少有两个儿子</p></li><li><p>公式</p><ul><li><p>第 n 层的节点数最多为<br>$$<br>2^n<br>$$<br>个节点</p></li><li><p>n 层二叉树最多有<br>$$<br>2^0+…+2^n=2^{n+1}<br>$$<br>个节点</p></li><li><p>第一个非叶子节点：length / 2</p></li><li><p>一个节点的孩子节点：2n、2n+1</p></li></ul></li><li><p>基本结构</p><ul><li>插入、遍历、深度</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data,left,right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data</span><br><span class="line">    <span class="keyword">this</span>.left = left</span><br><span class="line">    <span class="keyword">this</span>.right = right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node.prototype = &#123;</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span></span></span><br></pre></td></tr></table></figure></li><li><p>遍历</p><ul><li><p>中序遍历： 左侧子节点 =&gt; 节点本身 =&gt; 右侧子节点</p><p><img src="https://user-gold-cdn.xitu.io/2017/6/26/2d6ff3a0dd44891eb9bca20bba565bb5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>先序遍历： 节点本身 =&gt; 左侧子节点 =&gt; 右侧子节点</p><p><img src="https://user-gold-cdn.xitu.io/2017/6/26/1508a9f6bae66ac40291eeafee8b266d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>后序遍历： 左侧子节点 =&gt; 节点本身 =&gt; 右侧子节点</p><p><img src="https://user-gold-cdn.xitu.io/2017/6/26/062b8bb01a4070f6209367dadc084381?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li></ul></li></ul><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ul><li>网络结构的抽象模型</li><li>图是一组由边连接的节点</li><li>任何二元关系都可以用图来表示，呈多对多关系</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><img src="https://user-gold-cdn.xitu.io/2017/6/26/1c0d89f77fd70c21910229bd68857de5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h4 id="冒泡排序：-O-n²"><a href="#冒泡排序：-O-n²" class="headerlink" title="冒泡排序： O(n²)"></a>冒泡排序： O(n²)</h4><p><img src="https://user-gold-cdn.xitu.io/2017/6/26/baca5f1861b9534eb85c2a2f7340a18f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><ul><li>比较任何两个相邻的项，如果第一个比第二个大，则交换它们；元素项向上移动至正确的顺序，好似气泡上升至表面一般，因此得名</li></ul><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><img src="https://user-gold-cdn.xitu.io/2017/6/26/fd1cf9bccf6b4147b5442f4d36fc0d59?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><ul><li>每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，以此循环，直至排序完毕</li></ul><h4 id="插入排序：O-n²"><a href="#插入排序：O-n²" class="headerlink" title="插入排序：O(n²)"></a>插入排序：O(n²)</h4><p><img src="https://user-gold-cdn.xitu.io/2017/6/26/240c41b9aed4a6ef01abd1e225e11610?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><ul><li>将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，此算法适用于少量数据的排序，时间复杂度为 O(n^2)</li></ul><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><img src="https://user-gold-cdn.xitu.io/2017/6/26/6e75ddc8f4974aecf1619c24a9a5ce5b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><ul><li>将原始序列切分成较小的序列，只到每个小序列无法再切分，然后执行合并，即将小序列归并成大的序列，合并过程进行比较排序，只到最后只有一个排序完毕的大序列，时间复杂度为 O(n log n)</li></ul><h4 id="快速排序-O-nlog-n"><a href="#快速排序-O-nlog-n" class="headerlink" title="快速排序: O(nlog^n)"></a>快速排序: O(nlog^n)</h4><ul><li>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行上述递归排序，以此达到整个数据变成有序序列，时间复杂度为 O(n log n)</li></ul><h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><p><img src="https://user-gold-cdn.xitu.io/2017/6/26/83f1dad22cff06ee59df054a80e12633?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h4 id="顺序算法"><a href="#顺序算法" class="headerlink" title="顺序算法"></a>顺序算法</h4><p><img src="https://user-gold-cdn.xitu.io/2017/6/26/49d991b7d348351a41ce11bdb0c30f0b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><ul><li>让目标元素与列表中的每一个元素逐个比较，直到找出与给定元素相同的元素为止，缺点是效率低下</li></ul><h4 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h4><p><img src="https://user-gold-cdn.xitu.io/2017/6/26/968d79444c32475772c0b0d1859a6334?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><ul><li>在一个有序列表，以中间值为基准拆分为两个子列表，拿目标元素与中间值作比较从而再在目标的子列表中递归此方法，直至找到目标元素</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><ul><li>1和2的斐波那契数是1</li><li>n(n &gt; 2) 的斐波那契数是 (n-1)的斐波那契数 + n(n-2)的斐波那契数</li></ul><h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><ul><li>在对问题求解时，不考虑全局，总是做出局部最优解的方法</li></ul><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li>在对问题求解时，由以求出的局部最优解来推导全局最优解</li></ul><h4 id="复杂度概念"><a href="#复杂度概念" class="headerlink" title="复杂度概念"></a>复杂度概念</h4><p><img src="https://user-gold-cdn.xitu.io/2017/6/26/ac255e2c8c67bfe42ddd67ea03c72342?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2017/6/26/418be9230bb45d16436b4476540725e6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2019/8/20/16cac3540b752726?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><ul><li><p>算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。</p><ul><li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述</li><li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述</li></ul></li><li><p>时间复杂度</p><ul><li><p>大O符号表示法</p><ul><li><strong>T(n) = O(f(n))</strong>： <strong>算法的渐进时间复杂度</strong><ul><li>f(n) 表示每行代码执行次数之和</li><li>O 表示正比例关系</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">	j =i;</span><br><span class="line">	j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n)</p><ul><li><p>常见的时间复杂度量级</p><ul><li>从上至下依次的时间复杂度越来越大，执行的效率越来越低<ul><li>常数阶O(1)</li><li>对数阶O(logN)</li><li>线性阶O(n)</li><li>线性对数阶O(nlogN)</li><li>平方阶O(n²)</li><li>立方阶O(n³)</li><li>K次方阶O(n^k)【n的k次方，符号不会敲】</li><li>指数阶(2^n)</li></ul></li></ul></li><li><p>常用的时间复杂度量级</p><ul><li><p><strong>常数阶O(1)</strong></p><ul><li>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">int i = <span class="number">1</span>;</span><br><span class="line">int j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line">int m = i + j;</span><br></pre></td></tr></table></figure></li><li><p><strong>线性阶O(n)</strong></p><ul><li>for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>对数阶O(logN)</strong></p><ul><li>普通应用都是10，计算机学科是2，编程语言里面是e</li><li>常用编程语言中Math.log一般都是以E为底（MATLAB里面是以e为底的）</li><li>ln是以e为底数，lg是以10为底数</li><li>此处log底数为2</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">int i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n【这里是log 2的n次方，符号不会敲】也就是说当循环 log2n【这里是log 2的n次方，符号不会敲】 次以后，这个代码就结束了</li></ul></li><li><p><strong>线性对数阶O(nlogN)</strong></p><ul><li>线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(m=<span class="number">1</span>; m&lt;n; m++)</span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>平方阶O(n²)</strong></p><ul><li>O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>; i&lt;=n; x++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(n²)</p><ul><li>将其中一层循环的n改成m</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>; i&lt;=m; x++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(m*n)</p></li></ul></li></ul></li></ul></li><li><p>空间复杂度</p><ul><li><strong>空间复杂度 O(1)</strong></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">int i = <span class="number">1</span>;</span><br><span class="line">int j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line">int m = i + j;</span><br></pre></td></tr></table></figure><ul><li><strong>空间复杂度 O(n)</strong></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">int[] m = <span class="keyword">new</span> int[n]</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>###</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>学习方法（二）：如何长时间高效学习</title>
    <url>/2019/10/20/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E4%BA%8C/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><h2 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h2><ul><li>25分钟</li><li>没有任何干扰</li><li><p>专心学习</p><p>最后当这25分钟结束后，你需要休息5分钟。</p></li></ul><ul><li>你需要不断的练习来增强大脑中的连接，形成比较深刻的记忆模式。</li><li>记忆分为<strong>长期记忆 (Lone-term memory) 和工作记忆 (Working memory)。</strong>工作记忆也就是短期记忆，一般认为可以存放4块 (Chunks, 关于chunk后面会深入介绍) 信息，就像一块不太好用的黑板，不仅大小有限，而且很容易就被抹掉了，所以你需要不断重复，比如记电话号码，你需要一直重复直到你有机会把它写下来。而长期记忆的容量很大，从工作记忆转化到长期记忆需要时间以及不断的重复，这里提到了一个小技巧：<strong>spaced repetition</strong>, 就是一晚上重复20遍的效果不如你每天重复几遍。</li><li><strong>睡眠对学习也十分重要。</strong>我们觉醒时大脑会产生有毒的物质，而睡觉时大脑细胞收缩，细胞间隙变大，脑脊液可以通过并且清理掉这些东西。睡眠的意义不止于此，它也是学习与记忆的重要的一部分。睡眠时大脑会整理你的想法和你学习的内容，不重要的记忆会被清理掉，而你想要记住的会得到加强。睡眠时大脑还可以重复你白天学习的复杂知识，对解决难题和理解知识都有帮助。在睡觉之前看的东西更容易进入你的梦境，而梦到它又有助于你对它的理解</li><li><strong>另外，**</strong>锻炼身体很重要。<strong>除了散步洗澡听音乐等让你放松的方式会帮助你进入发散模式，锻炼身体能让你从之前集中精力的地方解放出来，使得发散模式有机会呈现，锻炼身体对大脑生长新的神经元有益。</strong></li><li>隐喻和类比是强大的学习技巧。**</li></ul><h2 id="Chunking"><a href="#Chunking" class="headerlink" title="Chunking"></a>Chunking</h2><p>Chunk中文直译是“块”，在这里是指<strong>组合起来的有意义的知识</strong>。比如字母d,o,g你可以很容易的把它们组成单词dog并在脑海中浮现狗的模样；比如拼图，鼻子眼睛耳朵背景等等，最后凑成一张图。chunk也像是把一些相近的文件做成的压缩包，节省空间的同时，便于搜索。之所以关心chunk，是因为<strong>chunk是已经加工好的知识，是我们解决问题的时候真正会使用的东西。</strong></p><p>如何形成chunk呢？</p><p>学一首新的吉他曲（可以视为一个chunk），通常是先完整听几遍曲子，看别人弹，然后自己一个小节一个小节练熟，最后串起来。 学一门新语言，一般会先从基本的音节，然后把音节串成单词，熟练了再把词串成句子，还要不断的融合语音语调之类的更多的细节。 这些都是给了我们形成chunk的直观感受：由mini chunk不断拼接，直到最后在我们的大脑形成了坚固的神经通路，使我们可以不用多想就可以迅速作出反应。</p><p><strong>生成chunk的方法：Focus, Understand, Practice。</strong></p><p>首先需要集中注意力。在形成chunk的时候，工作记忆像一只四脚章鱼一样，在努力建立新的神经结构，分心会占用章鱼有限的四只脚使得原本的chunk很难形成。</p><p>接着是理解，理解像是强力胶水，能让chunk之间相互关联，使得知识更容易被想到和使用。</p><p>最后一步就是练习，形成context（上下文），从而巩固chunk，并建立多个指向chunk的入口。</p><p><img src="https://pic4.zhimg.com/80/f6cd77bc37612b434a8c2e05d39e4958_hd.jpg" alt="img"></p><p>要形成上下文，得跳出原来要解决的问题，开阔思路，不断的使用相关的或不相关的chunk进行练习，<strong>直到我们不仅理解了何时该使用这个chunk，还能知道什么时候不能用它为止。</strong></p><p><strong>另外，学习时**</strong>不要过多的画重点<strong>，因为这可能会给你一种错觉：你记住了这些划过的内容，提倡在学习的过程中多提炼中心思想。对于我们已经掌握的东西，没必要一直重复学习了，</strong>你更应该多花时间和精力在你感觉最难的部分，这就叫deliberate practice**。著名的10000小时理论也十分强调deliberate practice, deliberate practice往往能把顶尖和普通的学生区分开来。</p><h2 id="拖延和记忆"><a href="#拖延和记忆" class="headerlink" title="拖延和记忆"></a>拖延和记忆</h2><h3 id="习惯的养成有四个部分：导火索-cue-，习惯动作-routine-，奖励-rewards-，信念-belief-。"><a href="#习惯的养成有四个部分：导火索-cue-，习惯动作-routine-，奖励-rewards-，信念-belief-。" class="headerlink" title="习惯的养成有四个部分：导火索(cue)，习惯动作(routine)，奖励(rewards)，信念(belief)。"></a><strong>习惯的养成有四个部分：导火索(cue)，习惯动作(routine)，奖励(rewards)，信念(belief)。</strong></h3><ol><li>导火索就是触发事件的原因，可能是时间，地点，感受，对外界的反应，比如午饭，沙发，疲劳，互联网，短信，邮件等。导火索会在不知不觉中让你做出习惯动作，它本身是没有好坏之分的，有好坏之分的是接下来的习惯动作，比如对“做数学作业”你的习惯动作是打开电脑先上会儿网，那就不好了。在这个阶段可以做到是尽可能减少危险的导火索，比如手机一震你就要看手机然后半小时回不了神，那就别带手机或者关机；一开电脑就想刷社交网络，那就断网或者别用电脑。</li><li>习惯动作就是你对导火索的反应，它之所以叫习惯动作，是因为你在无意识中就做了动作，比如你一要做作业就先上网玩了一会儿。很明显，这步很重要，你要重建会导致拖延的习惯动作。怎么重建？做计划，在脑中先想象自己一会儿要做的事，比如“我走进了图书馆，拿出来打印好的作业，读了第一道题，用书上例题中类似的方法和步骤解了出来，然后看第二题……”，到了真正去写作业的时候，就按照自己想象的计划做，这时候需要用一点意志力。再比如你每次学了一小时想休息一下，习惯性地刷刷朋友圈，结果停不下来了，如果做了计划，休息的时候只听某一两首歌，或者出去走一圈，就好很多。你做的计划一开始可能不能完美执行，没关系，尽力坚持就好，习惯慢慢肯定可以改过来。</li><li>奖励是指在养成习惯的过程中每当有收获就给自己奖品，比如买点自己心仪的东西，或者毫无悔恨的放开玩等。它在养成习惯的过程中是非常重要，也是容易被忽视的。非常重要是因为如果你的奖励是你非常想要得到的，比如一项荣誉，一个舍不得买的物品等，在你想到它的时候会激励你坚持下去。从来只付出不奖励自己，在养成习惯的效果上会差很多，应该善用奖励机制。</li><li>信念就是要相信自己能形成新的习惯，能战胜拖延。恶疾容易复发，经常会有朋友新习惯没坚持多久就又回到老习惯的情况。别在意，要相信之前的付出是有用的，为了更好的贯彻信念，可以找志同道合的朋友一起努力。</li></ol><ul><li><h3 id="存在痛苦的感受是很正常的，关键是你如何看待这些痛苦。那些不拖延的人，遇到困难之后告诉自己的是：我知道你很难过，但别浪费时间，开始做一点点吧，一定会慢慢变好的。你要相信确实是有办法让情况好转的。"><a href="#存在痛苦的感受是很正常的，关键是你如何看待这些痛苦。那些不拖延的人，遇到困难之后告诉自己的是：我知道你很难过，但别浪费时间，开始做一点点吧，一定会慢慢变好的。你要相信确实是有办法让情况好转的。" class="headerlink" title="存在痛苦的感受是很正常的，关键是你如何看待这些痛苦。那些不拖延的人，遇到困难之后告诉自己的是：我知道你很难过，但别浪费时间，开始做一点点吧，一定会慢慢变好的。你要相信确实是有办法让情况好转的。"></a>存在痛苦的感受是很正常的，关键是你如何看待这些痛苦。<strong>那些不拖延的人，遇到困难之后告诉自己的是：我知道你很难过，但别浪费时间，开始做一点点吧，一定会慢慢变好的。你要相信确实是有办法让情况好转的。</strong></h3></li></ul><ul><li><h3 id="一个技巧是：专注于过程，而非结果-Focus-on-process-rather-than-product-。番茄工作法之所以有用，就是因为他让你专注过程的25分钟。"><a href="#一个技巧是：专注于过程，而非结果-Focus-on-process-rather-than-product-。番茄工作法之所以有用，就是因为他让你专注过程的25分钟。" class="headerlink" title="一个技巧是：专注于过程，而非结果 (Focus on process rather than product)。番茄工作法之所以有用，就是因为他让你专注过程的25分钟。"></a><strong>一个技巧是：专注于过程，而非结果 (Focus on process rather than product)。</strong>番茄工作法之所以有用，就是因为他让你专注过程的25分钟。</h3></li></ul><ul><li><h3 id="另一个建议是做计划，weekly-list-of-key-tasks-and-daily-to-do-list。每周对主要任务列个计划，每天再列个待办事项。"><a href="#另一个建议是做计划，weekly-list-of-key-tasks-and-daily-to-do-list。每周对主要任务列个计划，每天再列个待办事项。" class="headerlink" title="另一个建议是做计划，weekly list of key tasks, and daily to-do list。每周对主要任务列个计划，每天再列个待办事项。"></a><strong>另一个建议是做计划，weekly list of key tasks, and daily to-do list。</strong>每周对主要任务列个计划，每天再列个待办事项。</h3></li></ul><h2 id="还有三个提升效率的技巧和建议："><a href="#还有三个提升效率的技巧和建议：" class="headerlink" title="还有三个提升效率的技巧和建议："></a>还有三个提升效率的技巧和建议：</h2><ol><li><strong>最难的事情最先做。</strong>因为越难越需要最充足的脑力去战斗，而且最难的最容易拖延的事情都解决了，后面都好办。</li><li><strong>给自己定一个结束时间，这跟制定工作时间一样重要。</strong>比如定好下午5点以后就不学了，之后去吃去玩去运动，所以5点之前，就专注把清单上的任务一个个做下来，尽量抓紧时间多做些，5点就解放。</li><li><strong>遇到困难先试试再说。</strong>只要试一下，头不疼了，心不乱了，过一会儿就发现，居然做完了。</li></ol><p>一定要战胜拖延症。学习是一个日积月累的过程，人脑需要时间来建造神经蓝图，就像健身增肌那样。所以我们要保持一个良好的学习惯性，避免拖延到最后一刻，以防在脑内搭建豆腐渣工程。建立新的习惯是战胜拖延的良方，可以从习惯的四个部分入手养成好习惯。关注过程而非结果，做好计划都是提高效率的技巧。</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>破冰行动-蔡永强</title>
    <url>/2019/06/02/%E7%A0%B4%E5%86%B0%E8%A1%8C%E5%8A%A8-%E8%94%A1%E6%B0%B8%E5%BC%BA/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:43 GMT+0800 (GMT+08:00) --><p><em>[内容源于网络]</em></p><h2 id="我国著名语言艺术家、职场生存大师、实证主义理论家思想家、东山公安局最佳辩手、看破不说破大师、金句boy蔡永强语录"><a href="#我国著名语言艺术家、职场生存大师、实证主义理论家思想家、东山公安局最佳辩手、看破不说破大师、金句boy蔡永强语录" class="headerlink" title="我国著名语言艺术家、职场生存大师、实证主义理论家思想家、东山公安局最佳辩手、看破不说破大师、金句boy蔡永强语录"></a>我国著名语言艺术家、职场生存大师、实证主义理论家思想家、东山公安局最佳辩手、看破不说破大师、金句boy蔡永强语录</h2><p>言归正传。蔡永强的自述光芒四射，但关键信息点却落在蔡永强与李维民的对话上。先来看这三段对话设计。</p><p>对话一：</p><p>李维民：“你让谁秘密接触林三宝？”</p><p>蔡永强：“就我自己，局里队里没有任何人知道我们以何种方式联络。什么时间什么地点，他们一概不知。”</p><p>李维民：“为什么？”</p><p>蔡永强：“刚才说过，公安局是一个情报中心。”</p><p>对话二：</p><p>李维民：“你对马云波不相信？”</p><p>蔡永强：“我有这方面的暗示吗？”</p><p>对话三：</p><p>李维民：“你对林三宝车祸身亡怎么看？”</p><p>蔡永强：“无非两种结论，一种是正常的车祸，他运气差，我们运气也差。另外一种结论，他被杀人灭口了，我们运气更差，因为没有证据。”</p><p>李维民：“你倾向于哪一边？”</p><p>蔡永强：“我没有倾向性，证据说话。”</p><p>李维民：“你有点言不由衷。”</p><p>蔡永强：“不是每个人都看得见真相，但每个人一定能成为真相。”</p><p>对话四：</p><p>李维民：“你怎么看待陈光荣？”</p><p>蔡永强：“工作能力很强，办案有一套，有资源，有人脉，有个性。”</p><p>李维民：“全是优点，缺点呢？”</p><p>蔡永强：“有时候优点，就可能变成缺点。”</p><p>看出共同点了吗？面对李维民多次蕴风雷于平淡中的询问，他始终没有给出正面肯定的回答，但是每一次回答又没有一句谎话。</p><p>为什么？因为蔡永强不信任李维民。李维民的每一次提问看上去像是他对蔡永强的质疑，其实又何尝不是蔡永强对李维民的试探？</p><p>“有个笑话，说谣言和真相是一对双胞胎，谣言性子急，走在前面，大家发现他是冒充的，被拍死了，等真相慢慢出了门，大家发现原来谣言和真相，一模一样。”</p><p>这段话语意深远！李飞可以在审讯中反复用肯定句进行无证推断，因为他和李维民彼此信任，但是蔡永强不可以，他和李维民之间横亘着一条猜疑链，如果李维民是狼呢？他怀疑马云波，李飞怀疑他，而马云波和李飞又是李维民的嫡系，在没有证据的情况下讲错一句话，被当成谣言拍死的就是他。</p><p>成年人的成熟是从“忍得住”开始的。</p><p>还有人觉得蔡永强滴水不漏的说话艺术仅仅是信奉明哲保身吗？他对李维民的试探是他主动出击的方式，一旦付出信任，蔡永强将毅然成为缉毒前线一把最强的火枪。</p><p>缉毒是以肉饲虎！不图名利，不图权势，每天面对的都是穷凶极恶的亡命之徒，正常人谁会去干这个？信仰的力量，可填山海。致敬和平年代的真心英雄！</p><h2 id="囚徒困境和猜疑链"><a href="#囚徒困境和猜疑链" class="headerlink" title="囚徒困境和猜疑链"></a>囚徒困境和猜疑链</h2><p>蔡永强和李飞联手审讯毒贩这场戏真的是目前为止最过瘾、最有戏剧张力、最火花四溅的一场戏，审讯艺术与戏剧艺术的结合妙至毫巅。</p><p>引用两个名词：囚徒困境和猜疑链。</p><p>囚徒困境出自博弈论。两个囚徒同时被捕，在无法互相沟通的前提下，如果两个人合作互不揭发，因证据不足，每个人都坐牢一年；如果一人揭发，另一个沉默，揭发者会因为立功而获释或减刑，沉默者则入刑十年；如果互相揭发，两个人都会因为证据确凿而获罪八年。</p><p>大虾和麻子就是囚徒困境中的这两名犯人。</p><p>走出囚徒困境的方法其实很简单，保持信任，创建合作。起初大虾和麻子是这样做的，各自保持沉默。按这个情形下去，两人的罪名顶多是吸毒和容留吸毒，无法找到突破性的关键证词。</p><p>如何让这两个人互相揭发呢？轮到猜疑链发挥作用。</p><p>猜疑链出自科幻小说《三体》。猜疑链导致文明无法互相判断彼此之间的善恶，并最终驱使双方相互敌视，无法形成共同认知。同样，猜疑链放到人类关系中也可以适用。</p><p>蔡永强真是深谙人性的高手，合作哪有那么简单？人总是自私自为且不彼此信任的动物。他先通过猜硬币的方式将两人隔离，触发猜疑链，随后李飞借假口供制造大虾已招的假象，毒瘾发作判断力下降的麻子无法判断大虾是否会出卖他，紧接着，蔡永强和李飞迅速跟进对他进行诱导加强，两个人一唱一和默契唱起了双簧，很快就让麻子的心理防线全面崩溃。</p><p>既然麻子已经吐得干干净净，合作创建失败，眼下的局面对大虾已经没有任何实质性的好处，一味死扛甚至可能会赔上性命，蔡永强此时说出的“我橄榄枝，只给你抛一次”，便是压垮骆驼的最后一根稻草。</p><p>行云流水，步步推进，成竹在胸，难怪李飞会说庆幸里面坐的不是他。</p><p>我的眼睛里只能看见一个人，蔡永强队长。这个人我可以夸到词穷，夸到笔墨难言。但是故事落幕，我不想这么简单地夸夸而已了。我想了解他，记住他。</p><p>他的故事，是这部剧最感动我的部分。</p><h2 id="第一集-塔寨雨夜"><a href="#第一集-塔寨雨夜" class="headerlink" title="第一集 塔寨雨夜"></a><strong>第一集 塔寨雨夜</strong></h2><p>整个故事的开始，是一个暴雨之夜的抓捕行动。</p><p>东山市公安局禁毒大队的两个年轻民警带领三名从盘锦市来的同志夜袭塔寨村，抓捕了一名叫林胜文的制贩毒嫌疑人。</p><p>本来以为这只是一个简单的抓捕行动，没人想到，就是这次抓捕拉开了广东省乃至全国最大的一次打击毒品战役的序幕。而那个暗中布局拉动绳索的人，就是他。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180099632.webp" alt="img"></p><p>林胜文被抓回来后，蔡队质问李飞为何不在惠东林的岳家抓人，却擅闯塔寨</p><p>林胜文所在的塔寨村，是东山市禁毒模范村。东山市一切打击毒品相关的行动，到了塔寨全部绕路而行。</p><p>李飞成功抓捕林胜文回来后，与队长蔡永强发生了对峙。</p><p>蔡永强质问他为什么擅闯塔寨，句句都是指责，却也句句都是暗示。然而此时的李飞已经对蔡永强失去信任，错过了他话语中的信息。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180102670.webp" alt="img"></p><p>暗示塔寨全村涉毒极为危险</p><p>蔡永强提到之前的一次行动，由于抓捕时进错了屋，六个警察被村民围困一天一夜。这就是导致东山市禁毒举步维艰的最大原因：宗亲关系盘根错节，宗族之内相互掩护。</p><p><img src="https://img1.doubanio.com/view/group_topic/l/public/p180102909.webp" alt="img"></p><p>以往事为鉴，所以蔡队昨夜暗暗安排了全队在村外接应（哥哥叉腰好可爱）</p><p>就在林胜文被抓捕审讯后的第二天，龙坪市天平司法鉴定中心开出鉴定报告，林胜文因身患“心脏疾病”，符合保释条例。他被保释了。李飞愤怒地质问蔡永强，为什么在申请鉴定的报告上签字？</p><p>是啊！为什么呢？很快你就会知道了。</p><p>东山，没好人。</p><p>在这里，想活下去，太难了。想留着命和手中武器，挣扎去打击犯罪，难上加难。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180103083.webp" alt="img"></p><p>林胜文被火速保释，面对李飞的愤怒质问，蔡队有口难言</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180099662.jpg" alt="img"></p><p>神图镇楼，哥哥苏到极限的一秒！</p><h2 id="第二集-杀机重重"><a href="#第二集-杀机重重" class="headerlink" title="第二集 杀机重重"></a><strong>第二集 杀机重重</strong></h2><p>南井村。养鸡场。</p><p>蔡永强赶到时，一切都已经晚了。</p><p>他看见那两个年轻人，一个被毫无尊严地捆绑屠杀，一个满身血污命悬一线。</p><p>这是一个针对他们两个精心布置的陷阱。而让他们走到了一脚踩进陷阱的如今的开端，正是不久前的那一场夜袭。</p><p>蔡永强没想到自己算到了一切，却没有算到林胜文这个小虾竟然吐出了“你们领导挣300万”的猛料。而恰恰是他将李飞与自己在立场上割离的决策，让李飞决定对他隐瞒了这个致命的信息。</p><p>“东山，没好人。”那个年轻人说。</p><p>心如刀割。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180154486.webp" alt="img"></p><p>一死，一伤。蔡永强终于体会什么叫心如刀割。</p><p>李飞被送进东山市人民医院。他身上扎着输液管，门外还坐着一名警员。</p><p>蔡永强带着周恺和另一名队员赶到医院时，看见的是一个踉跄跑出病房的李飞。</p><p>“李飞！不要动！”他不会傻得要逃走吧？这时候走了跟认了自己有罪有什么区别？</p><p>蔡永强按住李飞，他这个时候还以为自己能控制住局面，审讯李飞的权力能留在自己手中。</p><p>“蔡永强，你怀疑我？？？”</p><p>我不怀疑你。我最信任的就是你。但是你可老实点儿吧！</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180155164.webp" alt="img"></p><p>蔡永强把李飞按回病房，以为自己还能控制局面</p><p>李飞被上手铐了=_=||| 作为一个病人，他太不“老实”。</p><p>蔡永强一眼就看见乱七八糟的病房和地上散落的碎玻璃片。这不对劲。</p><p>早先副队陈自力给他打来电话，枪弹检验报告显示，李飞和宋杨身上的枪伤分别是对方的警枪造成的。这明明白白就是在说，是李飞杀害了宋杨。</p><p>这是个局！设局人什么都算好了，连同宋杨前女友弟弟车上的冰毒，和李飞家里的一百多万现金，一并奉上给你看。</p><p>而他们禁毒大队，他蔡永强，被排斥在外了。</p><p>自己的队员出了事，上司却嘱咐“检验报告别让他们拿到”。</p><p>是谁？罗旭？还是马云波？</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180155265.webp" alt="img"></p><p>涉及李飞本人的案子，蔡永强将费力打探来的信息全无保留告知。明白在说：我信任你，你是自己人。</p><p>码字好累，欣赏一下永强哥哥的长睫毛慰劳下自己！</p><p><img src="https://img1.doubanio.com/view/group_topic/l/public/p180155737.webp" alt="img"></p><p>哥哥的睫毛！轻轻抚在我的心上！</p><p>陈光荣来要李飞。</p><p>面对这个多年的战友，蔡永强心情非常复杂。情感上，陈光荣是自己多年的战友、朋友，说两人亲如兄弟也不为过；可理智上，蔡永强告诉自己，要和他保持距离。</p><p>“五·一三案成立了专案组。你的名字，不在专案组名单上。”</p><p>蔡永强看着陈光荣。你怎么掺和进这件事来？是上面的命令？还是你主动寻来的机会？</p><p>怀疑曾经一起并肩作战的战友，是痛苦的。</p><p>无论如何，李飞不能交出去。这个人是自己手下的队员，更是自己把他推出去做那把割破塔寨黑幕的尖刀。若是进了黑白不明的刑侦大队，没准有无数手段在等着他。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180159006.webp" alt="img"></p><p>电话挂断，无果。蔡永强脸上毫无表情，心里却泛起愤怒。</p><p>对上司，对自己，对眼前这个善恶难辨的前战友。</p><p>可是不是有句话说吗？把脾气压下去，是本事。愤怒有什么用？关键是怎么解决掉眼下这个麻烦。</p><p>刚才的电话已经拖延了一点时间，李飞能不能自己跑掉？刚才他是不是就想跑来着？他还戴着手铐吧……</p><p>要是他还在房里，怎么迅速搜集证据给他翻案？做局的人很可能就是顶头上司……难啊！蔡永强！</p><p>门打开了。</p><p>太好了。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180162115.webp" alt="img"></p><p>蔡队一眼识破，却给周恺打眼色不要声张，随后让周恺把地上的可疑玻璃片拿去化验。</p><h2 id="第三集-一线希望"><a href="#第三集-一线希望" class="headerlink" title="第三集 一线希望"></a><strong>第三集 一线希望</strong></h2><p>五·一三案，蔡永强被彻底排斥在外了。自从李飞顺利从医院病房溜走，他就再没有消息传回来过。</p><p>这太正常了。他不信任蔡永强。蔡永强面上总是过分谨慎、明哲保身，林胜文被火速保释后，李飞甚至怀疑蔡永强就是东山毒贩的保护伞。在他被当作重大嫌疑人通缉、朝不保夕之际，他最不可能联系的一个人，就是蔡永强。</p><p>但蔡永强不是完全没有办法。公安局，是一个信息的集散地。</p><p>“丰益宾馆”，他得到了这四个字。李飞会去中山吗？</p><p>副队陈自立带来了一个信息，蔡永强不知是好还是坏。</p><p>“一提到‘丰益宾馆’，中山的兄弟都讳莫如深，打听不出什么消息。”</p><p>打听不到消息，就说明了一个答案，同时也是一个暗示。</p><p>赵学超不接电话了。这说明李飞极有可能去了中山，并且赵学超能找到他。</p><p>这很好。赵学超此人是李维民的亲信，不论李维民立场如何，他总不会害李飞。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180337702.webp" alt="img"></p><p>蔡队的语气中有无奈，也有一点放心</p><p>而此时不接电话的赵学超在干什么呢？</p><p><img src="https://img1.doubanio.com/view/group_topic/l/public/p180338707.webp" alt="img"></p><p>此时，就在千方百计打探消息的蔡永强所不知道的地方，一个专门为了此案成立的联合调查组成型了，负责人正是广东省公安厅禁毒局副局长李维民，同他一同前来的还有一名公安部禁毒局的处长，左兰。</p><p>对蔡永强来说，这将是一个千载难逢的机会。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180340176.webp" alt="img"></p><p>联合调查组抵达东山</p><h2 id="第五集-千载难逢"><a href="#第五集-千载难逢" class="headerlink" title="第五集 千载难逢"></a><strong>第五集 千载难逢</strong></h2><p>李维民来了，带来了由广东省和公安部两级领导组成的“五·一三案联合调查组”。</p><p>李维民是谁？广东省公安厅禁毒局副局长，广东省资历最深的老缉毒警，干缉毒的老祖宗。</p><p>李维民和公安部禁毒局处长左兰的到来让蔡永强看见一个千载难逢的机会，他几乎要按捺不住胸中那团默默烧了多年的暗火，直要让它一把将东山这个烂泥潭燎个干净！！</p><p>然而就在热血上头的一刻，他忽然冷静了。</p><p>李维民，是马云波的师父，是一手把马云波带到如今这个位置的人。他完全可靠吗？蔡永强不敢赌。</p><p>直到李维民的到来掀起了一场波澜，蔡永强才放下了大半的心。</p><p>有人不想李维民来东山。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180351962.webp" alt="img"></p><p>蔡队和周恺对视一眼，发现事情并不简单( ﹁ ﹁ )</p><p><img src="https://img1.doubanio.com/view/group_topic/l/public/p180353167.webp" alt="img"></p><p>就在蔡永强知道了李维民所处的困境之后，左兰处长收到了一个匿名短信，短信里将闹事现场那几个活跃分子的黑历史扒得一干二净。聪明如你肯定当时就猜到这个信息是谁发的啦！即使驽钝如我，随着剧情的发展，这个谜底也被揭开了。</p><p>蔡永强的一双火眼金睛，仅凭着被“有心人”传上网络的一段短短的视频，就将那几个熟面孔一眼识破。这说明东山的涉毒分子，不论大小，在他的心中全部了如指掌。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180357251.webp" alt="img"></p><p>有蔡队这个强力辅助，李维民才能轻轻松松一举破局</p><p>李维民来东山，是来调查五·一三案的。而他来之前，李飞就给他提供了一个可怀疑的目标。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180360180.webp" alt="img"></p><p>蔡队知道李飞在怀疑他，他从未怪过李飞</p><p>调查组抵达东山后，蔡永强和李飞在一墙之隔的两间审讯室同时接受了问询。</p><p>蔡永强把接待盘锦同志的任务交给李飞，李飞通过水伯查出“黑豆”就是塔寨村林胜文后，立刻向蔡永强请示进村抓人。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180362714.webp" alt="img"></p><p>李飞接了盘锦的案子，认出“黑豆”就是塔寨村林胜文，于是向蔡队汇报请求抓人</p><p>然而蔡永强一开始以自己在外地为由暗示不同意他立刻去抓人，在他的坚持下又命令他将抓捕林胜文的消息保密，随后林胜文刚抓捕就被火速保释，这让李飞对蔡永强产生了极大的怀疑。林胜文对他吐出“300万保护伞”的消息后，他坚持认为这顶保护伞就是蔡永强。</p><p><img src="https://img1.doubanio.com/view/group_topic/l/public/p180369229.webp" alt="img"></p><p>蔡永强的过分谨慎和叮嘱他对队内保密的行为让李飞怀疑</p><p>该来的终于来了。蔡永强知道，如果不能对当初刻意把自己和李飞宋杨的抓捕行动切割开的行为做出一个合理的解释，将坐实调查组对自己的怀疑。</p><p>但是能说吗？为什么装作不同意去塔寨抓人？为什么只让李飞宋扬两个人去？为什么明明派了全队人在村外接应保护，却让李飞他们守口如瓶？</p><p>说不出。</p><p>在不清楚李维民会对马云波极可能已经腐化的猜想采取什么立场之前，在没有抓到马云波就是保护伞的实质证据之前，蔡永强什么都不能说。</p><p>不过没关系，河源的案子是早就准备好的借口。</p><p>自己远在河源，其他队员手里都有案子，让李飞和宋杨去就顺理成章。</p><p>不知蔡永强想没想到，李飞会将自己嘱咐他们将行动对人保密的话告知给调查组，而周恺在犹豫后，证实了这一点。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180381810.webp" alt="img"></p><p>抓不到马云波的把柄，又摸不准李维民的态度，蔡永强只能用借口敷衍调查组</p><p>在被问到为何要李宋二人对队员保密时，他犹豫了。</p><p>没有借口了。要说吗？</p><p><img src="https://img1.doubanio.com/view/group_topic/l/public/p180382408.webp" alt="img"></p><h2 id="第六集-滴水不漏"><a href="#第六集-滴水不漏" class="headerlink" title="第六集 滴水不漏"></a><strong>第六集 滴水不漏</strong></h2><p>“你为什么要向李飞交待，不要跟队里所有人讲。”</p><p>蔡永强知道，如果这个问题自己做不出合理解释，自己身上的疑点就会一直存在。但是一天抓不到马云波的把柄，他就一天说不出真话。</p><p>犹豫了几秒，他用技巧回避了。</p><p>“我不记得我说过这句话。”</p><p><img src="https://img1.doubanio.com/view/group_topic/l/public/p180388717.webp" alt="img"></p><p>抓不到马云波的把柄，又摸不准李维民的态度，蔡永强不敢说出自己的真实意图，只能回避。</p><p>为什么让李飞他们保密？因为要防着马云波。</p><p>李飞和马云波走得太近了。他不服蔡永强，不信他，怀疑他。但是他信马云波，听马云波的话。李飞因为抓捕林胜文吃了蔡永强一个处分后，马云波一句“这是组织商讨的决定”就打消了他的不平。他给马云波挡过子弹，把马云波当自己的大哥。</p><p>而蔡永强，这个温吞谨慎，看似明哲保身、小心翼翼的家伙，李飞瞧不起他，也不屑于知道他到底是怎么想的。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180390932.webp" alt="img"></p><p>林胜文的火速保释，和蔡永强在鉴定申请书上的签名，成了李飞怀疑他的要点，而这一点显然引起了调查组的注意。</p><p>蔡永强才不去管这个签名会不会成为他职业生涯中的一个的黑点，他只对自己说，机会来了。</p><p>塔寨有人出面要求保释林胜文，蔡永强向马云波请示。他没有证据能够证明马云波已经站在塔寨一边，只好用这个方法去试探他的态度。</p><p>而马云波会怎么说，蔡永强也预想到了。如果他不同意保释林胜文，他当时就会直接挡回去，但他回答的是：如果符合条件，你自行决定。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180407151.webp" alt="img"></p><p>蔡永强不是主动去申请鉴定林胜文是否够格保释，而是林耀东出面了，他才向马云波请示。</p><p>结果当然是符合条件。</p><p>调查组问到林胜文的保释，这简直正中蔡永强的下怀。他找到机会，在话里特别强调了那家给林胜文提供保释条件的“龙坪天平司法鉴定中心”。</p><p>蔡永强都数不清有多少次，今天抓的嫌疑人，明天就被人保释出去。</p><p>这个号称“天平”的机构明显有问题，蔡永强已经盯它很久了。今天就趁着调查组的东风，揭一揭它的画皮。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180409882.webp" alt="img"></p><p>法人是谁，什么背景，蔡永强想尽办法去调查。</p><p>“出具过很多次类似的鉴定报告”、“能量很大，上面总有人替她说话。但背后的势力是谁，我不知道。”</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180410264.webp" alt="img"></p><p>但就算他关系再广，也有查不到的人。</p><p>因为林胜文的火速保释，李飞敏锐地意识到问题出在塔寨村。一定是塔寨村有人出面了，他才会那么快被“捞”出去。</p><p>李维民终于问出这个让蔡永强谨慎、不忿了多年的问题：“你认为塔寨村有问题吗？”</p><p>有！问题大了！什么禁毒模范村！东山市戴了多少年的毒帽？这几年里大大小小无数次扫毒行动，到了塔寨全部绕道而行，你说塔寨有没有问题？</p><p>但是蔡永强能像李飞一样，凭着直觉提出指控吗？</p><p>他不能。他没有证据。毫无证据之下，贸然指控一个禁毒模范村、一个两级人大代表有问题，这是要犯政治错误的。他蔡永强还想不想留着这个禁毒大队长的位子，在东山继续跟毒贩子们、跟塔寨斗下去了？</p><p>此时此刻，任何没有证据的指控，都是没有意义的。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180415385.webp" alt="img"></p><p>蔡永强的一切城府和谨慎，都是吃够经验教训学来的。</p><p>然而李维民似乎铁了心不吃这一套。在他的追问下，蔡永强给出了这场审讯的第二个技巧性回答：</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180416215.webp" alt="img"></p><p>滴水不漏</p><h2 id="第七集（上）-一尘不染"><a href="#第七集（上）-一尘不染" class="headerlink" title="第七集（上）  一尘不染"></a><strong>第七集（上） 一尘不染</strong></h2><p>蔡永强受到了指控。这不是我自找的吗？他自嘲地想。</p><p>李飞坚持，蔡永强，还有坚定站在他身边的陈自立和周恺，就是东山毒贩的保护伞。他出身大小毒贩出没的南井村，和毒贩子们沾亲带故，不是亲戚就是同学，走动起来毫不避嫌。今天抓进来的毒贩子，过几天就被“捞”出去了，放他们出去的不是他蔡永强，还能是谁？</p><p><img src="https://img1.doubanio.com/view/group_topic/l/public/p180523848.webp" alt="img"></p><p>蔡永强啊蔡永强，一个东山人在东山干缉毒，你真是自找的。</p><p>当年从村里考上来干警察的时候，蔡永强就想，我到底要不要干缉毒。远的不看，就看看班上那些同学里，有多少个沾上毒品家破人亡？又有多少个为了挣这个脏钱六亲不认丧心病狂？</p><p>东山，太黑了。在东山干缉毒，太难。</p><p>往上三辈都是亲戚，出门五步都是同学。白天抓了一个，晚上就有十七八个亲戚朋友拐着弯儿的来家里探消息，送礼，试探能不能“捞人”。</p><p>越干越孤独。越干心越硬。</p><p>毒贩子们刀尖舔血挣的是一夜暴富，他干缉毒的拿命去拼挣的是一个月三千块。</p><p>面对儿子书包里的两万块钱，没冲击吗？蔡杰什么都没说，也没提任何要求，就是装了两万块，在自己还在上小学的儿子的书包里。什么意思？我认识你儿子。今天我能往他书包里塞钱，明天不一定还能干点什么。</p><p>那天蔡永强盯着那个书包，盯了一宿合不上眼。</p><p>而今天，这个“东山人”的身份，终于天然地让组织怀疑了。</p><p><img src="https://img1.doubanio.com/view/group_topic/l/public/p180536617.webp" alt="img"></p><p>“你能证明我要了吗？”</p><p>调查组同志怀疑、打量的眼神，让蔡永强有点无奈。</p><p>知道这么难，为什么还要干缉毒？你是不是傻啊蔡永强！你为的就是那一个月三千块钱的工资吗？你为的就是混到现在亲朋疏远、孤身一人吗？</p><p>我到底要的是什么？每过一段时间，蔡永强就会问问自己。</p><p>然后他就听见了自己心里的答案。每一次，都一样。这个答案多少年都没有变过。</p><p>谁是毒贩，这对我不重要。没有毒品，这对我很重要！</p><p>看看那些被毒品祸害的老百姓！东山，不应该是这个样子！</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180534440.webp" alt="img"></p><p>亲戚朋友不理解，同志战友有怀疑。蔡队跟谁诉过苦？</p><p>有证据的话，就来指控我吧。蔡永强心想。</p><p>要是对那些个大大小小的保护伞我也能这么轻轻松松地提出指控，那省了我多少功夫？</p><p><img src="https://img1.doubanio.com/view/group_topic/l/public/p180537229.webp" alt="img"></p><p>身是菩提树，心如明镜台。</p><p>蔡永强不是圣人，可有时候，一个普通人也能做成最伟大的事。</p><h2 id="第七集（下）处处艰难"><a href="#第七集（下）处处艰难" class="headerlink" title="第七集（下）处处艰难"></a><strong>第七集（下）处处艰难</strong></h2><p>李飞怀疑指控蔡永强，蔡永强从没怪过他。他责怪自己。但是李飞对马云波的盲目信任，让蔡永强对他有些埋怨。</p><p>明明咱们大队个个都是好样儿的，为什么他就是信不过？偏偏毫无理由地就信任马云波这个外来的。东山人怎么了？东山人在缉毒这行里就是原罪吗？东山人是最护着自己人的！</p><p>他能去给马云波挡子弹，把队里大事小情全都跟他讲，还在事情没搞清楚之前，就去马云波面前告自己的状！</p><p>“告密者”。蔡永强知道队里怎么看李飞。仗着跟副局长的关系，告了自己一状。看在最信任尊敬自己这个队长的周恺的眼里，这几乎等同于背叛。</p><p>蔡永强不怪李飞，因为他不清楚实情。但是他更无法责怪为自己鸣不平的周恺。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180567752.webp" alt="img"></p><p>凭直觉做判断，有时是李飞的优势，有时却会成为他致命的弱点。</p><p>马云波再英雄，他也是离你三尺远的副局长。你的兄弟们看着再平庸，关键时刻都是他们在盯你的背后啊！</p><p>东山这潭水，太黑、太深了。明枪暗箭，防不胜防。不多长十七八个心眼，怎么活得下去？没有一帮过命的兄弟，怎么在一场场行动中全身而退？光凭着一腔孤勇、不顾己身，就能成事吗？</p><p><img src="https://img1.doubanio.com/view/group_topic/l/public/p180568187.webp" alt="img"></p><p>蔡队金句。</p><p>把脾气拿出来，是本事；把脾气压下去，是本事。</p><p>因为在马云波面前告了自己一状，李飞被队里孤立了。蔡永强可以替他说话，替他在队里斡旋，挽回他的人际关系。实际上，蔡永强是一个很温柔的人，他可以原谅很多在普通人眼里是非常冒犯的事，再说他也从没因为这个怪过李飞。</p><p>但是这个温柔的人做了一个无情的决定。他什么都没有做。他把李飞从自己的立场中割离开，连带着一起的还有宋杨。他选中了李飞，去做一把尖刀。</p><p>宋杨死后，蔡永强无数次问过自己，后不后悔？后悔。不仅后悔，而且痛苦。但是重来一次，他骗不了自己，他还是会这么选。</p><p><img src="https://img1.doubanio.com/view/group_topic/l/public/p180574189.webp" alt="img"></p><p>李飞和宋杨被全队人孤立，请注意，并不是蔡永强设计的，而是他做出了一个近乎背叛的行为。</p><p>马云波。</p><p>这个名字估计是蔡永强每天在脑子里念叨次数最多的一个。</p><p>当年蔡永强有机会凭功绩升上东山市公安局副局长，可是半路冒出来一个空降兵，结果他就留在了禁毒大队，一留这么多年。</p><p>这个空降兵就是马云波。省禁毒局副局长李维民嫡系弟子，全省出了名的禁毒英雄。这次他被派到东山来是奔着罗旭的位子去的，奈何深深扎根在疗养院的罗旭就是死占着坑不肯挪，他就成了副局长。</p><p>马云波以往的禁毒工作太顺了，以至于他到了东山后，第一个看不上眼的就是他蔡永强和他手下这个禁毒大队。</p><p>“东山如今禁毒形势严峻，你蔡永强，难辞其咎！”</p><p><img src="https://img1.doubanio.com/view/group_topic/l/public/p180585377.webp" alt="img"></p><p>马云波新官上任，就借着李飞搭的梯子烧了一把火。看看恺恺的眼神，李飞就是这么被孤立的。</p><p>马云波不明白为何一个手握国家机器的禁毒大队长，会弯下身段去调节几房村民的冲突矛盾，陪笑送烟，权威形象尽失。</p><p>他不明白为何一个小小的东山，戴了几年的毒帽子都摘不下去。不就是一些毒贩子，能拧得过公安局的大腿？</p><p>基层。稳定。宗亲。关系。</p><p>越是小的地方，越是没有秘密。他们对你没有，你对他们亦然。</p><p>新官上任，马云波烧到蔡永强头上的一把火，蔡永强能理解。但是如今的马云波，是蔡永强必须想办法拔掉的一颗钉子。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180585775.webp" alt="img"></p><p>保护伞，又多了一顶。</p><h2 id="第八集-霜刃暗藏"><a href="#第八集-霜刃暗藏" class="headerlink" title="第八集 霜刃暗藏"></a><strong>第八集 霜刃暗藏</strong></h2><p>马云波刚刚走马上任，就当着全大队的面，点名将蔡永强骂了个颜面扫地。</p><p>调查组问，马云波当着所有人的面点你名，你是觉得委屈，还是愤怒？</p><p>其实现在回想起来，蔡永强已经不太记得当时的心情。委屈吗？或许有一点。愤怒吗？也有一些吧。然而这愤怒不是冲着马云波，而是对自己，对自己的那种无力，更准确地说，那应该是一种难堪和羞愧。</p><p>“我必须承认，他说的有道理。”</p><p>东山禁毒局面如此艰难，他蔡永强这个禁毒大队长的确难辞其咎。</p><p>马云波的一把火烧过后，蔡永强忍不住问自己，到底还有哪里没考虑到？为什么没能做得更好？到底有什么办法能把笼罩在东山的重重黑雾一把驱散个干净？</p><p>蔡永强，你真的能行吗？他开始怀疑自己。怀疑自己的能力，怀疑自己的运气，甚至怀疑……</p><p>不。他绝不怀疑自己的信仰。</p><p>一天不行，两天。一年不行，两年。只要扛下去，别被打倒，别放弃寻找时机，总有一天会让他找到机会，把东山这大大小小的毒窝、保护伞，拔个干净。</p><p><img src="https://img1.doubanio.com/view/group_topic/l/public/p180844377.webp" alt="img"></p><p>蔡永强此时说的不是客套话，而是真心话。在“唐旭吴刚演技大赏”一楼会详细分析。</p><p>李飞。蔡永强注意到了这个热血的、聪明的、也有些莽撞的年轻人。</p><p>他的热情和当年的自己真像啊！还有这小子那惊人的直觉。蔡永强仿佛看见了年轻时候的自己。年长一些后，蔡永强才发觉，那不是“直觉”，而是“观察力”和“潜意识”结合的产物。</p><p>蔡永强欣赏李飞，不光是因为他的思维方式和自己极像，更是因为他对信仰的忠诚追求，和自己一模一样。而马云波和李飞亲近的关系，让蔡永强产生了一个想法。</p><p>这个想法一冒头，蔡永强就对自己说：真是可怕。蔡永强，你看看自己是个什么人？</p><p>然而一念生起，蔡永强再也没办法对它视而不见。它不停地在劝诱：听我的。多少年了？你不想动动塔寨吗？这个年轻人简直是最合适的利刃。他果敢，又有些冲动，最棒的是，有一个公安局副局长能在他的背后给他撑腰。就让他去动一动塔寨！你只需要保证他的安全，他的前途完全不需要你操心。你不是一直在等一个机会吗？李飞就是你的机会呀……</p><p>这个声音不停、不停地在他心底轻搔，他做出了决定。</p><p>“你会因为李飞跟马云波的关系，就对他另眼相看吗？”</p><p>蔡永强，你是个什么人？</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180850511.webp" alt="img"></p><p>蔡永强回避了，我猜不出他此时情绪如何。或许有愧疚吧。</p><p>因为李飞的指控，调查组对蔡三毛的案子寻根究底。蔡三毛到底是怎么死的？这是一个无法回避的问题。</p><p>顺风顺水的马云波不理解，李维民也很难赞同，身为一名国家机器的代言人，专职打击毒品犯罪的大队长，竟然会在调节几房村民的矛盾上面花上一个多月的时间，左右劝解，陪笑买烟。</p><p>“这是你的本职工作吗？”</p><p>在东山，没有基层关系的缉毒干警，是会有麻烦的。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180870024.webp" alt="img"></p><p>东山老百姓可以是庇护毒贩的百姓，也可以是警民一家的百姓。</p><p>话是良言，可李维民才不上套。问你的是蔡三毛的真正死因，说到基层关系是不是答非所问？</p><p>蔡永强犹豫了一下，将自己暗中发展线人的举动向他坦白了。</p><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p180871030.webp" alt="img"></p><p>不论李维民对马云波立场如何，蔡永强相信他对打击毒品犯罪，是真正的铁腕。</p><p>十年磨剑，屡屡折戟。</p><p>直到遇上了李飞，蔡永强终于找到了一把霜刃。及锋而试，可有大功 。</p><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>电视剧</tag>
      </tags>
  </entry>
  <entry>
    <title>超好听的合唱音乐</title>
    <url>/2019/11/07/%E8%B6%85%E5%A5%BD%E5%90%AC%E7%9A%84%E5%90%88%E5%94%B1%E9%9F%B3%E4%B9%90/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:44 GMT+0800 (GMT+08:00) --><h2 id="可惜不是你"><a href="#可惜不是你" class="headerlink" title="可惜不是你"></a>可惜不是你</h2><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom:20px"></div><script>!function(){var e=new DPlayer({container:document.getElementById("dplayer0"),theme:"#FADFA3",video:{url:"http://cdn.silverlft.com/%E5%8F%AF%E6%83%9C%E4%B8%8D%E6%98%AF%E4%BD%A0.mp4"}});window.dplayers||(window.dplayers=[]),window.dplayers.push(e)}()</script><h2 id="我爱你中国"><a href="#我爱你中国" class="headerlink" title="我爱你中国"></a>我爱你中国</h2><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom:20px"></div><script>!function(){var e=new DPlayer({container:document.getElementById("dplayer1"),theme:"#FADFA3",video:{url:"http://cdn.silverlft.com/%E6%88%91%E7%88%B1%E4%BD%A0%EF%BC%8C%E4%B8%AD%E5%9B%BD.mp4"}});window.dplayers||(window.dplayers=[]),window.dplayers.push(e)}()</script><h2 id="夜空中最亮的星"><a href="#夜空中最亮的星" class="headerlink" title="夜空中最亮的星"></a>夜空中最亮的星</h2><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom:20px"></div><script>!function(){var E=new DPlayer({container:document.getElementById("dplayer2"),theme:"#FADFA3",video:{url:"http://cdn.silverlft.com/%E5%8E%A6%E9%97%A8%E5%85%AD%E4%B8%AD%E5%90%88%E5%94%B1%E5%9B%A2%E6%9C%80%E6%96%B0%E6%BC%94%E7%BB%8E%E3%80%8A%E5%A4%9C%E7%A9%BA%E4%B8%AD%E6%9C%80%E4%BA%AE%E7%9A%84%E6%98%9F%E3%80%8B.54926397_x264.mp4"}});window.dplayers||(window.dplayers=[]),window.dplayers.push(E)}()</script><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>高等数学</title>
    <url>/2019/10/20/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:44 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>英语</title>
    <url>/2019/10/20/%E8%8B%B1%E8%AF%AD/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:44 GMT+0800 (GMT+08:00) --><h1 id="四六级作文"><a href="#四六级作文" class="headerlink" title="四六级作文"></a>四六级作文</h1><h2 id="三种类型"><a href="#三种类型" class="headerlink" title="三种类型"></a>三种类型</h2><ul><li>examples：必须要有例子</li><li>entitle：必须要用所给的标题</li><li>topic：切合主题</li></ul><h2 id="五个出题方式"><a href="#五个出题方式" class="headerlink" title="五个出题方式"></a>五个出题方式</h2><h3 id="英文谚语"><a href="#英文谚语" class="headerlink" title="英文谚语"></a>英文谚语</h3><ul><li>第一段：抄谚语+解释</li><li>第二段：评价：重要性、原因、危害</li><li>第三段：个人行为</li></ul><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>网络基础知识</title>
    <url>/2019/10/24/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:44 GMT+0800 (GMT+08:00) --><p>1）什么是链接？</p><p>链接是指两个设备之间的连接。它包括用于一个设备能够与另一个设备通信的电缆类型和协议。</p><p>2）OSI 参考模型的层次是什么？</p><p>有 7 个 OSI 层：物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。</p><p>3）什么是骨干网？</p><p>骨干网络是集中的基础设施，旨在将不同的路由和数据分发到各种网络。它还处理带宽管理和各种通道。</p><p>4）什么是 LAN？</p><p>LAN 是局域网的缩写。它是指计算机与位于小物理位置的其他网络设备之间的连接。</p><p>5）什么是节点？</p><p>节点是指连接发生的点。它可以是作为网络一部分的计算机或设备。为了形成网络连接，需要两个或更多个节点。</p><p>6）什么是路由器？</p><p>路由器可以连接两个或更多网段。这些是在其路由表中存储信息的智能网络设备，例如路径，跳数等。有了这个信息，他们就可以确定数据传输的最佳路径。路由器在 OSI 网络层运行。</p><p>7）什么是点对点链接？</p><p>它是指网络上两台计算机之间的直接连接。除了将电缆连接到两台计算机的 NIC卡之外，点对点连接不需要任何其他网络设备。</p><p>8）什么是匿名 FTP？</p><p>匿名 FTP 是授予用户访问公共服务器中的文件的一种方式。允许访问这些服务器中的数据的用户不需要识别自己，而是以匿名访客身份登录。</p><p>9）什么是子网掩码？</p><p>子网掩码与 IP 地址组合，以识别两个部分：扩展网络地址和主机地址。像 IP 地址一样，子网掩码由 32 位组成。</p><p>10）UTP 电缆允许的最大长度是多少？</p><p>UTP 电缆的单段具有 90 到 100 米的允许长度。这种限制可以通过使用中继器和开关来克服</p><p>11）什么是数据封装？</p><p>数据封装是在通过网络传输信息之前将信息分解成更小的可管理块的过程。在这个过程中，源和目标地址与奇偶校验一起附加到标题中。</p><p>12）描述网络拓扑</p><p>网络拓扑是指计算机网络的布局。它显示了设备和电缆的物理布局，以及它们如何连接到彼此。</p><p>13）什么是 VPN？</p><p>VPN 意味着虚拟专用网络，这种技术允许通过网络（如 Internet）创建安全通道。</p><p>例如，VPN 允许您建立到远程服务器的安全拨号连接。</p><p>14）简要描述 NAT。</p><p>NAT 是网络地址转换。这是一种协议，为公共网络上的多台计算机提供一种方式来共享到 Internet 的单一连接。</p><p>15）OSI 参考模型下网络层的工作是什么？</p><p>网络层负责数据路由，分组交换和网络拥塞控制。路由器在此层下运行。</p><p>16）网络拓扑如何影响您在建立网络时的决策？</p><p>网络拓扑决定了互连设备必须使用什么媒介。它还作为适用于设置的材料，连接器和终端的基础。</p><p>17）什么是 RIP？</p><p>RIP，路由信息协议的简称由路由器用于将数据从一个网络发送到另一个网络。</p><p>它通过将其路由表广播到网络中的所有其他路由器来有效地管理路由数据。它以跳数为单位确定网络距离。</p><p>18）什么是不同的方式来保护计算机网络？</p><p>有几种方法可以做到这一点。在所有计算机上安装可靠和更新的防病毒程序。确保防火墙的设置和配置正确。用户认证也将有很大的帮助。所有这些组合将构成一个高度安全的网络。</p><p>19）什么是 NIC？</p><p>NIC 是网络接口卡（网卡）的缩写。这是连接到 PC 以连接到网络沈北。每个 NIC都有自己的 MAC 地址，用于标识网络上的 PC。</p><p>20）什么是 WAN？</p><p>WAN 代表广域网。它是地理上分散的计算机和设备的互连。它连接位于不同地区和国家/地区的网络。</p><p>21）OSI 物理层的重要性是什么？</p><p>物理层进行从数据位到电信号的转换，反之亦然。这是网络设备和电缆类型的考虑和设置。</p><p>22）TCP/IP 下有多少层？</p><p>有四层：网络层，互联网层，传输层和应用层。</p><p>23）什么是代理服务器，它们如何保护计算机网络？</p><p>代理服务器主要防止外部用户识别内部网络的 IP 地址。不知道正确的 IP 地址，甚至无法识别网络的物理位置。代理服务器可以使外部用户几乎看不到网络。</p><p>24）OSI 会话层的功能是什么？</p><p>该层为网络上的两个设备提供协议和方法，通过举行会话来相互通信。这包括设置会话，管理会话期间的信息交换以及终止会话时的解除过程。</p><p>25）实施容错系统的重要性是什么？有限吗？</p><p>容错系统确保持续的数据可用性。这是通过消除单点故障来实现的。但是，在某些情况下，这种类型的系统将无法保护数据，例如意外删除。</p><p>26）10Base-T 是什么意思？</p><p>10 是指数据传输速率，在这种情况下是 10Mbps。“Base”是指基带。T 表示双绞线，这是用于该网络的电缆。</p><p>27）什么是私有 IP 地址？</p><p>专用 IP 地址被分配用于内部网。这些地址用于内部网络，不能在外部公共网络上路由。这些确保内部网络之间不存在任何冲突，同时私有 IP 地址的范围同样可重复使用于多个内部网络，因为它们不会“看到”彼此。</p><p>28）什么是 NOS？</p><p>NOS 或网络操作系统是专门的软件，其主要任务是向计算机提供网络连接，以便能够与其他计算机和连接的设备进行通信。</p><p>29）什么是 DoS？</p><p>DoS 或拒绝服务攻击是试图阻止用户访问互联网或任何其他网络服务。这种攻击可能有不同的形式，由一群永久者组成。这样做的一个常见方法是使系统服务器过载，使其无法再处理合法流量，并将被强制重置。</p><p>30）什么是 OSI，它在电脑网络中扮演什么角色？</p><p>OSI（开放系统互连）作为数据通信的参考模型。它由 7 层组成，每层定义了网络设备如何相互连接和通信的特定方面。一层可以处理所使用的物理介质，而另一层则指示如何通过网络实际传输数据。</p><p>31）电缆被屏蔽并具有双绞线的目的是什么？</p><p>其主要目的是防止串扰。串扰是电磁干扰或噪声，可能影响通过电缆传输的数据。</p><p>32）地址共享的优点是什么？</p><p>通过使用地址转换而不是路由，地址共享提供了固有的安全性优势。这是因为互联网上的主机只能看到提供地址转换的计算机上的外部接口的公共 IP 地址，而不是内部网络上的私有 IP 地址。</p><p>33）什么是 MAC 地址？</p><p>MAC 或媒介访问控制，可以唯一地标识网络上的设备。它也被称为物理地址或以太网地址。MAC 地址由 6 个字节组成。</p><p>34）在 OSI 参考模型方面，TCP/IP 应用层的等同层或多层是什么？</p><p>TCP/IP 应用层实际上在 OSI 模型上具有三个对等体：会话层，表示层和应用层。</p><p>35）如何识别给定 IP 地址的 IP 类？</p><p>通过查看任何给定 IP 地址的第一个八位字节，您可以识别它是 A 类，B 类还是 C类。如果第一个八位字节以 0 位开头，则该地址为 Class A.如果以位 10 开头，则该地址为 B 类地址。如果从 110 开始，那么它是 C 类网络。</p><p>36）OSPF 的主要目的是什么？</p><p>OSPF 或开放最短路径优先，是使用路由表确定数据交换的最佳路径的链路状态路由协议。</p><p>37）什么是防火墙？</p><p>防火墙用于保护内部网络免受外部攻击。这些外部威胁可能是黑客谁想要窃取数据或计算机病毒，可以立即消除数据。它还可以防止来自外部网络的其他用户访问专用网络。</p><p>38）描述星形拓扑</p><p>星形拓扑由连接到节点的中央集线器组成。这是最简单的设置和维护之一。</p><p>39）什么是网关？</p><p>网关提供两个或多个网段之间的连接。它通常是运行网关软件并提供翻译服务的计算机。该翻译是允许不同系统在网络上通信的关键。</p><p>40）星型拓扑的缺点是什么？</p><p>星形拓扑的一个主要缺点是，一旦中央集线器或交换机被损坏，整个网络就变得不可用了。</p><p>41）什么是 SLIP？</p><p>SLIP 或串行线路接口协议实际上是在 UNIX 早期开发的旧协议。这是用于远程访问的协议之一。</p><p>42）给出一些私有网络地址的例子。</p><p>10.0.0.0，子网掩码为 255.0.0.0</p><p>172.16.0.0，子网掩码为 255.240.0.0</p><p>千人ccie认证交流群463904693</p><p>领取最新CCIE考试题库</p><p>CCIE 认证经验分享千人群：463904693</p><p>192.168.0.0，子网掩码为 255.255.0.0</p><p>43）什么是 tracert？</p><p>Tracert 是一个 Windows 实用程序，可用于跟踪从路由器到目标网络的数据采集的路由。它还显示了在整个传输路由期间采用的跳数。</p><p>44）网络管理员的功能是什么？</p><p>网络管理员有许多责任，可以总结为 3 个关键功能：安装网络，配置网络设置以及网络的维护/故障排除。</p><p>45）描述对等网络的一个缺点。</p><p>当您正在访问由网络上的某个工作站共享的资源时，该工作站的性能会降低。</p><p>46）什么是混合网络？</p><p>混合网络是利用客户端 - 服务器和对等体系结构的网络设置。</p><p>47）什么是 DHCP？</p><p>DHCP 是动态主机配置协议的缩写。其主要任务是自动为网络上的设备分配 IP 地址。它首先检查任何设备尚未占用的下一个可用地址，然后将其分配给网络设备。</p><p>48）ARP 的主要工作是什么？</p><p>ARP 或地址解析协议的主要任务是将已知的 IP 地址映射到 MAC 层地址。</p><p>49）什么是 TCP/IP？</p><p>TCP/IP 是传输控制协议/互联网协议的缩写。这是一组协议层，旨在在不同类型的计算机网络（也称为异构网络）上进行数据交换。</p><p>50）如何使用路由器管理网络？</p><p>路由器内置了控制台，可让您配置不同的设置，如安全和数据记录。您可以为计算机分配限制，例如允许访问的资源，或者可以浏览互联网的某一天的特定时间。</p><p>您甚至可以对整个网络中看不到的网站施加限制。</p><p>51）当您希望在不同平台（如 UNIX 系统和 Windows 服务器之间）传输文件时，可以应用什么协议？</p><p>使用 FTP（文件传输协议）在这些不同的服务器之间进行文件传输。这是可能的，因为 FTP 是平台无关的。</p><p>52）默认网关的使用是什么？</p><p>默认网关提供了本地网络连接到外部网络的方法。用于连接外部网络的默认网关通常是外部路由器端口的地址。</p><p>53）保护网络的一种方法是使用密码。什么可以被认为是好的密码？</p><p>良好的密码不仅由字母组成，还包括字母和数字的组合。结合大小写字母的密码比使用所有大写字母或全部小写字母的密码有利。密码必须不能被黑客很容易猜到，比如日期，姓名，收藏夹等等。</p><p>54）UTP 电缆的正确终止率是多少？</p><p>非屏蔽双绞线网线的正常终止是 100 欧姆。</p><p>55）什么是 netstat？</p><p>Netstat 是一个命令行实用程序。它提供有关连接当前 TCP/IP 设置的有用信息。</p><p>56）C 类网络中的网络 ID 数量是多少？</p><p>对于 C 类网络，可用的网络 ID 位数为 21。可能的网络 ID 数目为 2，提高到 21或 2,097,152。每个网络 ID 的主机 ID 数量为 2，增加到 8 减去 2，或 254。</p><p>57）使用长于规定长度的电缆时会发生什么？</p><p>电缆太长会导致信号丢失。这意味着数据传输和接收将受到影响，因为信号长度下降。</p><p>58）什么常见的软件问题可能导致网络缺陷？</p><p>软件相关问题可以是以下任何一种或其组合：</p><p>- 客户端服务器问题</p><p>- 应用程序冲突</p><p>- 配置错误</p><p>- 协议不匹配</p><p>- 安全问题</p><p>- 用户政策和权利问题</p><p>59）什么是 ICMP？</p><p>ICMP 是 Internet 控制消息协议。它为 TCP/IP 协议栈内的协议提供消息传递和通信。这也是管理由 PING 等网络工具使用的错误信息的协议。</p><p>60）什么是 Ping？</p><p>Ping 是一个实用程序，允许您检查网络上的网络设备之间的连接。您可以使用其IP 地址或设备名称（如计算机名称）ping 设备。</p><p>61）什么是点对点（P2P）？</p><p>对等是不在服务器上回复的网络。该网络上的所有 PC 都是单独的工作站。</p><p>62）什么是 DNS？</p><p>DNS 是域名系统。该网络服务的主要功能是为 TCP/IP 地址解析提供主机名。</p><p>63）光纤与其他介质有什么优势？</p><p>光纤的一个主要优点是不太容易受到电气干扰。它还支持更高的带宽，意味着可以发送和接收更多的数据。长距离信号降级也非常小。</p><p>64）集线器和交换机有什么区别？</p><p>集线器充当多端口中继器。然而，随着越来越多的设备连接到它，它将无法有效地管理通过它的流量。交换机提供了一个更好的替代方案，可以提高性能，特别是在所有端口上预期有高流量时。</p><p>65）Windows RRAS 服务支持的不同网络协议是什么？</p><p>支持三种主要的网络协议：NetBEUI，TCP/IP 和 IPX。</p><p>66）A，B 和 C 类网络中的最大网络和主机是什么？</p><p>对于 A 类，有 126 个可能的网络和 16,777,214 个主机</p><p>对于 B 类，有 16,384 个可能的网络和 65,534 个主机</p><p>对于 C 类，有 2,097,152 个可能的网络和 254 个主机</p><p>67）直通电缆的标准颜色顺序是什么？</p><p>橙色/白色，橙色，绿色/白色，蓝色，蓝色/白色，绿色，棕色/白色，棕色。</p><p>68）什么协议落在 TCP/IP 协议栈的应用层之下？</p><p>以下是 TCP/IP 应用层协议：FTP，TFTP，Telnet 和 SMTP。</p><p>69）您需要连接两台电脑进行文件共享。是否可以这样做，而不使用集线器或路由器？</p><p>是的，您可以使用一根电缆将两台计算机连接在一起。在这种情况下可以使用交叉型电缆。在这种设置中，一条电缆的数据传输引脚连接到另一条电缆的数据接收引脚，反之亦然。</p><p>70）什么是 ipconfig？</p><p>Ipconfig 是一个常用于识别网络上计算机的地址信息的实用程序。它可以显示物理地址以及 IP 地址。</p><p>71）直通和交叉电缆有什么区别？</p><p>直通电缆用于将计算机连接到交换机，集线器或路由器。交叉电缆用于将两个类似设备连接在一起，如 PC 到 PC 或集线器到集线器。</p><p>72）什么是客户端/服务器？</p><p>客户端/服务器是一种类型的网络，其中一个或多个计算机充当服务器。服务器提供集中的资源库，如打印机和文件。客户端是指访问服务器的工作站。</p><p>73）描述网络。</p><p>网络是指用于数据通信的计算机和外围设备之间的互连。可以使用有线电缆或通过无线链路进行网络连接。</p><p>74）将 NIC 卡从一台 PC 移动到另一台 PC 时，MAC 地址是否也被转移？</p><p>是的，那是因为 MAC 地址是硬连线到 NIC 电路，而不是 PC。这也意味着当 NIC卡被另一个替换时，PC 可以具有不同的 MAC 地址。</p><p>75）解释聚类支持</p><p>群集支持是指网络操作系统在容错组中连接多台服务器的能力。这样做的主要目的是在一台服务器发生故障的情况下，集群中的下一个服务器将继续进行所有处理。</p><p>76）在包含两个服务器和二十个工作站的网络中，安装防病毒程序的最佳位置是哪里？</p><p>必须在所有服务器和工作站上安装防病毒程序，以确保保护。这是因为个人用户可以访问任何工作站，并在插入可移动硬盘驱动器或闪存驱动器时引入计算机病毒。</p><p>77）描述以太网。</p><p>以太网是当今使用的流行网络技术之一。它是在 20 世纪 70 年代初开发的，并且基于 IEEE 中规定的规范。以太网在局域网中使用。</p><p>78）实现环形拓扑有什么缺点？</p><p>如果网络上的一个工作站发生故障，可能会导致整个网络丢失。另一个缺点是，当需要在网络的特定部分进行调整和重新配置时，整个网络也必须被暂时关闭。</p><p>79）CSMA/CD 和 CSMA/CA 有什么区别？</p><p>CSMA/CD 或碰撞检测，每当碰撞发生时重新发送数据帧。CSMA/CA 或碰撞避免，将首先在数据传输之前广播意图发送。</p><p>80）什么是 SMTP？</p><p>SMTP 是简单邮件传输协议的缩写。该协议处理所有内部邮件，并在 TCP/IP 协议栈上提供必要的邮件传递服务。</p><p>81）什么是组播路由？</p><p>组播路由是一种有针对性的广播形式，将消息发送到所选择的用户组，而不是将其发送到子网上的所有用户。</p><p>82）加密在网络上的重要性是什么？</p><p>加密是将信息转换成用户不可读的代码的过程。然后使用秘密密钥或密码将其翻译或解密回其正常可读格式。加密有助于确保中途截获的信息仍然不可读，因为用户必须具有正确的密码或密钥。</p><p>83）如何安排和显示 IP 地址？</p><p>IP 地址显示为一系列由周期或点分隔的四位十进制数字。这种安排的另一个术语是点分十进制格式。一个例子是 192.168.101.2</p><p>84）解释认证的重要性。</p><p>认证是在用户登录网络之前验证用户凭据的过程。它通常使用用户名和密码进行。这提供了限制来自网络上的有害入侵者的访问的安全手段。</p><p>85）隧道模式是什么意思？</p><p>这是一种数据交换模式，其中两个通信计算机本身不使用 IPSec。相反，将 LAN连接到中转网络的网关创建了一个使用 IPSec 协议来保护通过它的所有通信的虚拟隧道。</p><p>86）建立 WAN 链路涉及的不同技术有哪些？</p><p>模拟连接 - 使用常规电话线；数字连接 - 使用数字电话线；交换连接 - 使用发送方和接收方之间的多组链接来移动数据。</p><p>87）网格拓扑的一个优点是什么？</p><p>在一个链接失败的情况下，总会有另一个链接可用。网状拓扑实际上是最容错的网络拓扑之一。</p><p>88）在排除计算机网络问题时，可能会发生什么常见的硬件相关问题？</p><p>大部分网络由硬件组成。这些领域的问题可能包括硬盘故障，NIC 损坏甚至硬件启动。不正确的硬件配置也是其中一个疑难问题。</p><p>89）可以做什么来修复信号衰减问题？</p><p>处理这种问题的常见方法是使用中继器和集线器，因为它将有助于重新生成信号，从而防止信号丢失。检查电缆是否正确终止也是必须的。</p><p>90）动态主机配置协议如何协助网络管理？</p><p>网络管理员不必访问每台客户端计算机来配置静态 IP 地址，而是可以应用动态主机配置协议来创建称为可以动态分配给客户端的范围的 IP 地址池。</p><p>91）解释网络概念的概况？</p><p>配置文件是为每个用户设置的配置设置。例如，可以创建将用户置于组中的配置文件。</p><p>92）什么是 Sneakernet？</p><p>Sneakernet 被认为是最早的联网形式，其中使用可移动介质（如磁盘，磁带）物理传输数据。</p><p>93）IEEE 在计算机网络中的作用是什么？</p><p>IEEE 或电气和电子工程师学会是由电气和电子设备标准发布和管理的工程师组成的组织。这包括网络设备，网络接口，cablings 和连接器。</p><p>94）TCP/IP Internet 层下有哪些协议？</p><p>该层管理的协议有 4 种。这些是 ICMP，IGMP，IP 和 ARP。</p><p>95）谈到网络，什么是权限？</p><p>权限是指在网络上执行特定操作的授权许可。网络上的每个用户可以分配个人权限，具体取决于该用户必须允许的内容。</p><p>96）建立 VLAN 的一个基本要求是什么？</p><p>需要一个 VLAN，因为在交换机级别只有一个广播域，这意味着每当新用户连接时，该信息都会传播到整个网络。交换机上的 VLAN 有助于在交换机级别创建单独的广播域。它用于安全目的。</p><p>97）什么是 IPv6？</p><p>IPv6 或 Internet 协议版本 6 被开发以替代 IPv4。目前，IPv4 正在用于控制互联网流量，但 IPv4 已经饱和。IPv6 能够克服这个限制。</p><p>98）什么是 RSA 算法？</p><p>RSA 是 Rivest-Shamir-Adleman 算法的缩写。它是目前最常用的公钥加密算法。</p><p>99）什么是网格拓扑？</p><p>网格拓扑是一种设置，其中每个设备都直接连接到网络上的每个其他设备。因此，它要求每个设备具有至少两个网络连接。</p><p>100）100Base-FX 网络的最大段长度是多少？</p><p>使用 100Base-FX 的网段的最大允许长度为 412 米。整个网络的最大长度为 5 公里。</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>视频合集</title>
    <url>/2019/10/20/%E8%A7%86%E9%A2%91%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 11:57:44 GMT+0800 (GMT+08:00) --><h1 id="GMU-信通-amp-外语-2017迎新宣传"><a href="#GMU-信通-amp-外语-2017迎新宣传" class="headerlink" title="GMU-信通&amp;外语-2017迎新宣传"></a>GMU-信通&amp;外语-2017迎新宣传</h1><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom:20px"></div><script>!function(){var e=new DPlayer({container:document.getElementById("dplayer3"),theme:"#FADFA3",video:{url:"http://cdn.silverlft.com/%E4%BF%A1%E9%80%9A2017%E8%BF%8E%E6%96%B0%E6%99%9A%E4%BC%9A_x264.mp4"}});window.dplayers||(window.dplayers=[]),window.dplayers.push(e)}()</script><p>PS：现在再看一遍，其实也还好，帧数太低有点遗憾</p><h1 id="信息部2018送老"><a href="#信息部2018送老" class="headerlink" title="信息部2018送老"></a>信息部2018送老</h1><div id="dplayer4" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom:20px"></div><script>!function(){var e=new DPlayer({container:document.getElementById("dplayer4"),theme:"#FADFA3",video:{url:"http://cdn.silverlft.com/%E4%BF%A1%E6%81%AF%E9%83%A8%E9%80%81%E8%80%81%E8%A7%86%E9%A2%91_%E5%85%A8%E7%A8%8B%E7%82%AB%E6%8A%802018_batch.mp4"}});window.dplayers||(window.dplayers=[]),window.dplayers.push(e)}()</script><p>PS：讲真这视频做的真不错</p><h1 id="GMU-快闪"><a href="#GMU-快闪" class="headerlink" title="GMU-快闪"></a>GMU-快闪</h1><div id="dplayer5" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom:20px"></div><script>!function(){var e=new DPlayer({container:document.getElementById("dplayer5"),theme:"#FADFA3",video:{url:"http://cdn.silverlft.com/%E5%B9%BF%E8%88%AA%E5%BF%AB%E9%97%AA_x264.mp4"}});window.dplayers||(window.dplayers=[]),window.dplayers.push(e)}()</script><p>PS：原本自己觉得做的不咋地，后来发现抖音的点赞还挺多的</p><h1 id="2018-新生"><a href="#2018-新生" class="headerlink" title="2018-新生"></a>2018-新生</h1><div id="dplayer6" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom:20px"></div><script>!function(){var e=new DPlayer({container:document.getElementById("dplayer6"),theme:"#FADFA3",video:{url:"http://cdn.silverlft.com/%E4%BF%A1%E6%81%AF%E9%83%A82018%E6%96%B0%E7%94%9F_batch.mp4"}});window.dplayers||(window.dplayers=[]),window.dplayers.push(e)}()</script><p>PS：视频角度有点偏了，还有点晃，美中不足，而且感觉最后的字体也没用好</p><h1 id="我吃鸡超强"><a href="#我吃鸡超强" class="headerlink" title="我吃鸡超强"></a>我吃鸡超强</h1><div id="dplayer7" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom:20px"></div><script>!function(){var e=new DPlayer({container:document.getElementById("dplayer7"),theme:"#FADFA3",video:{url:"http://cdn.silverlft.com/%E7%99%BE%E7%BA%A7%E8%A7%86%E9%A2%91%28%E7%95%99%E4%BD%9C%E7%BA%AA%E5%BF%B5%29_batch.mp4"}});window.dplayers||(window.dplayers=[]),window.dplayers.push(e)}()</script><p>PS：卡点没卡好，素材不够多，有一两个重复</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>VUE 2.x</title>
    <url>/2019/09/22/vue-js/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!-- build time:Sat May 30 2020 14:15:17 GMT+0800 (GMT+08:00) --><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p><code>Vue.config</code> 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列属性：</p><h3 id="silent"><a href="#silent" class="headerlink" title="silent"></a><a href="https://cn.vuejs.org/v2/api/#silent" target="_blank" rel="noopener">silent</a></h3><ul><li><p><strong>类型</strong>：<code>boolean</code></p></li><li><p><strong>默认值</strong>：<code>false</code></p></li><li><p><strong>用法</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.config.silent &#x3D; true</span><br></pre></td></tr></table></figure><p>取消 Vue 所有的日志与警告。</p></li></ul><h3 id="optionMergeStrategies"><a href="#optionMergeStrategies" class="headerlink" title="optionMergeStrategies"></a><a href="https://cn.vuejs.org/v2/api/#optionMergeStrategies" target="_blank" rel="noopener">optionMergeStrategies</a></h3><ul><li><p><strong>类型</strong>：<code>{ [key: string]: Function }</code></p></li><li><p><strong>默认值</strong>：<code>{}</code></p></li><li><p><strong>用法</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.config.optionMergeStrategies._my_option &#x3D; function (parent, child, vm) &#123;</span><br><span class="line">  return child + 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Profile &#x3D; Vue.extend(&#123;</span><br><span class="line">  _my_option: 1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Profile.options._my_option &#x3D; 2</span><br></pre></td></tr></table></figure><p>自定义合并策略的选项。</p><p>合并策略选项分别接收在父实例和子实例上定义的该选项的值作为第一个和第二个参数，Vue 实例上下文被作为第三个参数传入。</p></li><li><p><strong>参考</strong> <a href="https://cn.vuejs.org/v2/guide/mixins.html#自定义选项混入策略" target="_blank" rel="noopener">自定义选项的混入策略</a></p></li></ul><h3 id="devtools"><a href="#devtools" class="headerlink" title="devtools"></a><a href="https://cn.vuejs.org/v2/api/#devtools" target="_blank" rel="noopener">devtools</a></h3><ul><li><p><strong>类型</strong>：<code>boolean</code></p></li><li><p><strong>默认值</strong>：<code>true</code> (生产版为 <code>false</code>)</p></li><li><p><strong>用法</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 务必在加载 Vue 之后，立即同步设置以下内容</span><br><span class="line">Vue.config.devtools &#x3D; true</span><br></pre></td></tr></table></figure><p>配置是否允许 <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="noopener">vue-devtools</a> 检查代码。开发版本默认为 <code>true</code>，生产版本默认为 <code>false</code>。生产版本设为 <code>true</code> 可以启用检查。</p></li></ul><h3 id="errorHandler"><a href="#errorHandler" class="headerlink" title="errorHandler"></a><a href="https://cn.vuejs.org/v2/api/#errorHandler" target="_blank" rel="noopener">errorHandler</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>默认值</strong>：<code>undefined</code></p></li><li><p><strong>用法</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.config.errorHandler = <span class="function"><span class="keyword">function</span> (<span class="params">err, vm, info</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">  <span class="comment">// `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子</span></span><br><span class="line">  <span class="comment">// 只在 2.2.0+ 可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。</p><blockquote><p>从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 <code>undefined</code> 时，被捕获的错误会通过 <code>console.error</code> 输出而避免应用崩溃。</p></blockquote><blockquote><p>从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了。</p></blockquote><blockquote><p>从 2.6.0 起，这个钩子也会捕获 <code>v-on</code> DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理。</p></blockquote><blockquote><p>错误追踪服务 <a href="https://sentry.io/" target="_blank" rel="noopener">Sentry</a> 和 <a href="https://docs.bugsnag.com/platforms/browsers/vue/" target="_blank" rel="noopener">Bugsnag</a> 都通过此选项提供了官方支持。</p></blockquote></li></ul><h3 id="warnHandler"><a href="#warnHandler" class="headerlink" title="warnHandler"></a><a href="https://cn.vuejs.org/v2/api/#warnHandler" target="_blank" rel="noopener">warnHandler</a></h3><blockquote><p>2.4.0 新增</p></blockquote><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>默认值</strong>：<code>undefined</code></p></li><li><p><strong>用法</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.config.warnHandler &#x3D; function (msg, vm, trace) &#123;</span><br><span class="line">  &#x2F;&#x2F; &#96;trace&#96; 是组件的继承关系追踪</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为 Vue 的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。</p></li></ul><h3 id="ignoredElements"><a href="#ignoredElements" class="headerlink" title="ignoredElements"></a><a href="https://cn.vuejs.org/v2/api/#ignoredElements" target="_blank" rel="noopener">ignoredElements</a></h3><ul><li><p><strong>类型</strong>：<code>Array</code></p></li><li><p><strong>默认值</strong>：<code>[]</code></p></li><li><p><strong>用法</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.config.ignoredElements &#x3D; [</span><br><span class="line">  &#39;my-custom-web-component&#39;,</span><br><span class="line">  &#39;another-web-component&#39;,</span><br><span class="line">  &#x2F;&#x2F; 用一个 &#96;RegExp&#96; 忽略所有“ion-”开头的元素</span><br><span class="line">  &#x2F;&#x2F; 仅在 2.5+ 支持</span><br><span class="line">  &#x2F;^ion-&#x2F;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>须使 Vue 忽略在 Vue 之外的自定义元素 (e.g. 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 <code>Unknown custom element</code> 的警告。</p></li></ul><h3 id="keyCodes"><a href="#keyCodes" class="headerlink" title="keyCodes"></a><a href="https://cn.vuejs.org/v2/api/#keyCodes" target="_blank" rel="noopener">keyCodes</a></h3><ul><li><p><strong>类型</strong>：<code>{ [key: string]: number | Array }</code></p></li><li><p><strong>默认值</strong>：<code>{}</code></p></li><li><p><strong>用法</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.config.keyCodes &#x3D; &#123;</span><br><span class="line">  v: 86,</span><br><span class="line">  f1: 112,</span><br><span class="line">  &#x2F;&#x2F; camelCase 不可用</span><br><span class="line">  mediaPlayPause: 179,</span><br><span class="line">  &#x2F;&#x2F; 取而代之的是 kebab-case 且用双引号括起来</span><br><span class="line">  &quot;media-play-pause&quot;: 179,</span><br><span class="line">  up: [38, 87]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; @keyup.media-play-pause&#x3D;&quot;method&quot;&gt;</span><br></pre></td></tr></table></figure><p>给 <code>v-on</code> 自定义键位别名。</p></li></ul><h3 id="performance"><a href="#performance" class="headerlink" title="performance"></a><a href="https://cn.vuejs.org/v2/api/#performance" target="_blank" rel="noopener">performance</a></h3><blockquote><p>2.2.0 新增</p></blockquote><ul><li><p><strong>类型</strong>：<code>boolean</code></p></li><li><p><strong>默认值</strong>：<code>false (自 2.2.3 起)</code></p></li><li><p><strong>用法</strong>：</p><p>设置为 <code>true</code> 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark" target="_blank" rel="noopener"><code>performance.mark</code></a> API 的浏览器上。</p></li></ul><h3 id="productionTip"><a href="#productionTip" class="headerlink" title="productionTip"></a><a href="https://cn.vuejs.org/v2/api/#productionTip" target="_blank" rel="noopener">productionTip</a></h3><blockquote><p>2.2.0 新增</p></blockquote><ul><li><p><strong>类型</strong>：<code>boolean</code></p></li><li><p><strong>默认值</strong>：<code>true</code></p></li><li><p><strong>用法</strong>：</p><p>设置为 <code>false</code> 以阻止 vue 在启动时生成生产提示。</p></li></ul><h2 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h2><h3 id="Vue-extend-options"><a href="#Vue-extend-options" class="headerlink" title="Vue.extend( options )"></a><a href="https://cn.vuejs.org/v2/api/#Vue-extend" target="_blank" rel="noopener">Vue.extend( options )</a></h3><ul><li><p><strong>参数</strong>：</p><ul><li><code>{Object} options</code></li></ul></li><li><p><strong>用法</strong>：</p><p>使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p><p><code>data</code> 选项是特例，需要注意 - 在 <code>Vue.extend()</code> 中它必须是函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;mount-point&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建构造器</span><br><span class="line">var Profile &#x3D; Vue.extend(&#123;</span><br><span class="line">  template: &#39;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;&#x2F;p&gt;&#39;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      firstName: &#39;Walter&#39;,</span><br><span class="line">      lastName: &#39;White&#39;,</span><br><span class="line">      alias: &#39;Heisenberg&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 创建 Profile 实例，并挂载到一个元素上。</span><br><span class="line">new Profile().$mount(&#39;#mount-point&#39;)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Walter White aka Heisenberg&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">组件</a></p></li></ul><h3 id="Vue-nextTick-callback-context"><a href="#Vue-nextTick-callback-context" class="headerlink" title="Vue.nextTick( [callback, context] )"></a><a href="https://cn.vuejs.org/v2/api/#Vue-nextTick" target="_blank" rel="noopener">Vue.nextTick( [callback, context] )</a></h3><ul><li><p><strong>参数</strong>：</p><ul><li><code>{Function} [callback]</code></li><li><code>{Object} [context]</code></li></ul></li><li><p><strong>用法</strong>：</p><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改数据</span><br><span class="line">vm.msg &#x3D; &#39;Hello&#39;</span><br><span class="line">&#x2F;&#x2F; DOM 还没有更新</span><br><span class="line">Vue.nextTick(function () &#123;</span><br><span class="line">  &#x2F;&#x2F; DOM 更新了</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span><br><span class="line">Vue.nextTick()</span><br><span class="line">  .then(function () &#123;</span><br><span class="line">    &#x2F;&#x2F; DOM 更新了</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。</p></blockquote></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/reactivity.html#异步更新队列" target="_blank" rel="noopener">异步更新队列</a></p></li></ul><h3 id="Vue-set-target-propertyName-index-value"><a href="#Vue-set-target-propertyName-index-value" class="headerlink" title="Vue.set( target, propertyName/index, value )"></a><a href="https://cn.vuejs.org/v2/api/#Vue-set" target="_blank" rel="noopener">Vue.set( target, propertyName/index, value )</a></h3><ul><li><p><strong>参数</strong>：</p><ul><li><code>{Object | Array} target</code></li><li><code>{string | number} propertyName/index</code></li><li><code>{any} value</code></li></ul></li><li><p><strong>返回值</strong>：设置的值。</p></li><li><p><strong>用法</strong>：</p><p>向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 <code>this.myObject.newProperty = &#39;hi&#39;</code>)</p><p>注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。</p></li></ul><h3 id="Vue-delete-target-propertyName-index"><a href="#Vue-delete-target-propertyName-index" class="headerlink" title="Vue.delete( target, propertyName/index )"></a><a href="https://cn.vuejs.org/v2/api/#Vue-delete" target="_blank" rel="noopener">Vue.delete( target, propertyName/index )</a></h3><ul><li><p><strong>参数</strong>：</p><ul><li><code>{Object | Array} target</code></li><li><code>{string | number} propertyName/index</code></li></ul><blockquote><p>仅在 2.2.0+ 版本中支持 Array + index 用法。</p></blockquote></li><li><p><strong>用法</strong>：</p><p>删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。</p><blockquote><p>在 2.2.0+ 中同样支持在数组上工作。</p></blockquote><p>目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">深入响应式原理</a></p></li></ul><h3 id="Vue-directive-id-definition"><a href="#Vue-directive-id-definition" class="headerlink" title="Vue.directive( id, [definition] )"></a><a href="https://cn.vuejs.org/v2/api/#Vue-directive" target="_blank" rel="noopener">Vue.directive( id, [definition] )</a></h3><ul><li><p><strong>参数</strong>：</p><ul><li><code>{string} id</code></li><li><code>{Function | Object} [definition]</code></li></ul></li><li><p><strong>用法</strong>：</p><p>注册或获取全局指令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册</span><br><span class="line">Vue.directive(&#39;my-directive&#39;, &#123;</span><br><span class="line">  bind: function () &#123;&#125;,</span><br><span class="line">  inserted: function () &#123;&#125;,</span><br><span class="line">  update: function () &#123;&#125;,</span><br><span class="line">  componentUpdated: function () &#123;&#125;,</span><br><span class="line">  unbind: function () &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册 (指令函数)</span><br><span class="line">Vue.directive(&#39;my-directive&#39;, function () &#123;</span><br><span class="line">  &#x2F;&#x2F; 这里将会被 &#96;bind&#96; 和 &#96;update&#96; 调用</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getter，返回已注册的指令</span><br><span class="line">var myDirective &#x3D; Vue.directive(&#39;my-directive&#39;)</span><br></pre></td></tr></table></figure></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">自定义指令</a></p></li></ul><h3 id="Vue-filter-id-definition"><a href="#Vue-filter-id-definition" class="headerlink" title="Vue.filter( id, [definition] )"></a><a href="https://cn.vuejs.org/v2/api/#Vue-filter" target="_blank" rel="noopener">Vue.filter( id, [definition] )</a></h3><ul><li><p><strong>参数</strong>：</p><ul><li><code>{string} id</code></li><li><code>{Function} [definition]</code></li></ul></li><li><p><strong>用法</strong>：</p><p>注册或获取全局过滤器。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册</span><br><span class="line">Vue.filter(&#39;my-filter&#39;, function (value) &#123;</span><br><span class="line">  &#x2F;&#x2F; 返回处理后的值</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getter，返回已注册的过滤器</span><br><span class="line">var myFilter &#x3D; Vue.filter(&#39;my-filter&#39;)</span><br></pre></td></tr></table></figure></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/filters.html" target="_blank" rel="noopener">过滤器</a></p></li></ul><h3 id="Vue-component-id-definition"><a href="#Vue-component-id-definition" class="headerlink" title="Vue.component( id, [definition] )"></a><a href="https://cn.vuejs.org/v2/api/#Vue-component" target="_blank" rel="noopener">Vue.component( id, [definition] )</a></h3><ul><li><p><strong>参数</strong>：</p><ul><li><code>{string} id</code></li><li><code>{Function | Object} [definition]</code></li></ul></li><li><p><strong>用法</strong>：</p><p>注册或获取全局组件。注册还会自动使用给定的<code>id</code>设置组件的名称</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册组件，传入一个扩展过的构造器</span><br><span class="line">Vue.component(&#39;my-component&#39;, Vue.extend(&#123; &#x2F;* ... *&#x2F; &#125;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册组件，传入一个选项对象 (自动调用 Vue.extend)</span><br><span class="line">Vue.component(&#39;my-component&#39;, &#123; &#x2F;* ... *&#x2F; &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取注册的组件 (始终返回构造器)</span><br><span class="line">var MyComponent &#x3D; Vue.component(&#39;my-component&#39;)</span><br></pre></td></tr></table></figure></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">组件</a></p></li></ul><h3 id="Vue-use-plugin"><a href="#Vue-use-plugin" class="headerlink" title="Vue.use( plugin )"></a><a href="https://cn.vuejs.org/v2/api/#Vue-use" target="_blank" rel="noopener">Vue.use( plugin )</a></h3><ul><li><p><strong>参数</strong>：</p><ul><li><code>{Object | Function} plugin</code></li></ul></li><li><p><strong>用法</strong>：</p><p>安装 Vue.js 插件。如果插件是一个对象，必须提供 <code>install</code> 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。</p><p>该方法需要在调用 <code>new Vue()</code> 之前被调用。</p><p>当 install 方法被同一个插件多次调用，插件将只会被安装一次。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/plugins.html" target="_blank" rel="noopener">插件</a></p></li></ul><h3 id="Vue-mixin-mixin"><a href="#Vue-mixin-mixin" class="headerlink" title="Vue.mixin( mixin )"></a><a href="https://cn.vuejs.org/v2/api/#Vue-mixin" target="_blank" rel="noopener">Vue.mixin( mixin )</a></h3><ul><li><p><strong>参数</strong>：</p><ul><li><code>{Object} mixin</code></li></ul></li><li><p><strong>用法</strong>：</p><p>全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。<strong>不推荐在应用代码中使用</strong>。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/mixins.html#全局混入" target="_blank" rel="noopener">全局混入</a></p></li></ul><h3 id="Vue-compile-template"><a href="#Vue-compile-template" class="headerlink" title="Vue.compile( template )"></a><a href="https://cn.vuejs.org/v2/api/#Vue-compile" target="_blank" rel="noopener">Vue.compile( template )</a></h3><ul><li><p><strong>参数</strong>：</p><ul><li><code>{string} template</code></li></ul></li><li><p><strong>用法</strong>：</p><p>在 render 函数中编译模板字符串。<strong>只在独立构建时有效</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var res &#x3D; Vue.compile(&#39;&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&#39;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: &#39;hello&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  render: res.render,</span><br><span class="line">  staticRenderFns: res.staticRenderFns</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">渲染函数</a></p></li></ul><h3 id="Vue-observable-object"><a href="#Vue-observable-object" class="headerlink" title="Vue.observable( object )"></a><a href="https://cn.vuejs.org/v2/api/#Vue-observable" target="_blank" rel="noopener">Vue.observable( object )</a></h3><blockquote><p>2.6.0 新增</p></blockquote><ul><li><p><strong>参数</strong>：</p><ul><li><code>{Object} object</code></li></ul></li><li><p><strong>用法</strong>：</p><p>让一个对象可响应。Vue 内部会用它来处理 <code>data</code> 函数返回的对象。</p><p>返回的对象可以直接用于<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">渲染函数</a>和<a href="https://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="noopener">计算属性</a>内，并且会在发生改变时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const state &#x3D; Vue.observable(&#123; count: 0 &#125;)</span><br><span class="line"></span><br><span class="line">const Demo &#x3D; &#123;</span><br><span class="line">  render(h) &#123;</span><br><span class="line">    return h(&#39;button&#39;, &#123;</span><br><span class="line">      on: &#123; click: () &#x3D;&gt; &#123; state.count++ &#125;&#125;</span><br><span class="line">    &#125;, &#96;count is: $&#123;state.count&#125;&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Vue 2.x 中，被传入的对象会直接被 <code>Vue.observable</code> 改变，所以如<a href="https://cn.vuejs.org/v2/guide/instance.html#数据与方法" target="_blank" rel="noopener">这里展示的</a>，它和被返回的对象是同一个对象。在 Vue 3.x 中，则会返回一个可响应的代理，而对源对象直接进行修改仍然是不可响应的。因此，为了向前兼容，我们推荐始终操作使用 <code>Vue.observable</code> 返回的对象，而不是传入源对象。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">深入响应式原理</a></p></li></ul><h3 id="Vue-version"><a href="#Vue-version" class="headerlink" title="Vue.version"></a><a href="https://cn.vuejs.org/v2/api/#Vue-version" target="_blank" rel="noopener">Vue.version</a></h3><ul><li><p><strong>细节</strong>：提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。</p></li><li><p><strong>用法</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var version &#x3D; Number(Vue.version.split(&#39;.&#39;)[0])</span><br><span class="line"></span><br><span class="line">if (version &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">  &#x2F;&#x2F; Vue v2.x.x</span><br><span class="line">&#125; else if (version &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">  &#x2F;&#x2F; Vue v1.x.x</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; Unsupported versions of Vue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="选项-数据"><a href="#选项-数据" class="headerlink" title="选项/数据"></a>选项/数据</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a><a href="https://cn.vuejs.org/v2/api/#data" target="_blank" rel="noopener">data</a></h3><ul><li><p><strong>类型</strong>：<code>Object | Function</code></p></li><li><p><strong>限制</strong>：组件的定义只接受 <code>function</code>。</p></li><li><p><strong>详细</strong>：</p><p>Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。<strong>对象必须是纯粹的对象 (含有零个或多个的 key/value 对)</strong>：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。</p><p>一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。</p><p>实例创建之后，可以通过 <code>vm.$data</code> 访问原始数据对象。Vue 实例也代理了 data 对象上所有的属性，因此访问 <code>vm.a</code> 等价于访问 <code>vm.$data.a</code>。</p><p>以 <code>_</code> 或 <code>$</code> 开头的属性 <strong>不会</strong> 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。你可以使用例如 <code>vm.$data._property</code> 的方式访问这些属性。</p><p>当一个<strong>组件</strong>被定义，<code>data</code> 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 <code>data</code> 仍然是一个纯粹的对象，则所有的实例将<strong>共享引用</strong>同一个数据对象！通过提供 <code>data</code> 函数，每次创建一个新实例后，我们能够调用 <code>data</code> 函数，从而返回初始数据的一个全新副本数据对象。</p><p>如果需要，可以通过将 <code>vm.$data</code> 传入 <code>JSON.parse(JSON.stringify(...))</code> 得到深拷贝的原始数据对象。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var data &#x3D; &#123; a: 1 &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 直接创建一个实例</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line">vm.a &#x2F;&#x2F; &#x3D;&gt; 1</span><br><span class="line">vm.$data &#x3D;&#x3D;&#x3D; data &#x2F;&#x2F; &#x3D;&gt; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Vue.extend() 中 data 必须是函数</span><br><span class="line">var Component &#x3D; Vue.extend(&#123;</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123; a: 1 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意，如果你为 <code>data</code> 属性使用了箭头函数，则 <code>this</code> 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: vm &#x3D;&gt; (&#123; a: vm.myProp &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">深入响应式原理</a></p></li></ul><h3 id="props"><a href="#props" class="headerlink" title="props"></a><a href="https://cn.vuejs.org/v2/api/#props" target="_blank" rel="noopener">props</a></h3><ul><li><p><strong>类型</strong>：<code>Array | Object</code></p></li><li><p><strong>详细</strong>：</p><p>props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。</p><p>你可以基于对象的语法使用以下选项：</p><ul><li><code>type</code>: 可以是下列原生构造函数中的一种：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Array</code>、<code>Object</code>、<code>Date</code>、<code>Function</code>、<code>Symbol</code>、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。Prop 类型的<a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-类型" target="_blank" rel="noopener">更多信息在此</a>。</li><li><code>default</code>: <code>any</code><br>为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。</li><li><code>required</code>: <code>Boolean</code><br>定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。</li><li><code>validator</code>: <code>Function</code><br>自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在<a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-验证" target="_blank" rel="noopener">这里</a>查阅更多 prop 验证的相关信息。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 简单语法</span><br><span class="line">Vue.component(&#39;props-demo-simple&#39;, &#123;</span><br><span class="line">  props: [&#39;size&#39;, &#39;myMessage&#39;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象语法，提供验证</span><br><span class="line">Vue.component(&#39;props-demo-advanced&#39;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    &#x2F;&#x2F; 检测类型</span><br><span class="line">    height: Number,</span><br><span class="line">    &#x2F;&#x2F; 检测类型 + 其他验证</span><br><span class="line">    age: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 0,</span><br><span class="line">      required: true,</span><br><span class="line">      validator: function (value) &#123;</span><br><span class="line">        return value &gt;&#x3D; 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/components-props.html" target="_blank" rel="noopener">Props</a></p></li></ul><h3 id="propsData"><a href="#propsData" class="headerlink" title="propsData"></a><a href="https://cn.vuejs.org/v2/api/#propsData" target="_blank" rel="noopener">propsData</a></h3><ul><li><p><strong>类型</strong>：<code>{ [key: string]: any }</code></p></li><li><p><strong>限制</strong>：只用于 <code>new</code> 创建的实例中。</p></li><li><p><strong>详细</strong>：</p><p>创建实例时传递 props。主要作用是方便测试。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Comp &#x3D; Vue.extend(&#123;</span><br><span class="line">  props: [&#39;msg&#39;],</span><br><span class="line">  template: &#39;&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var vm &#x3D; new Comp(&#123;</span><br><span class="line">  propsData: &#123;</span><br><span class="line">    msg: &#39;hello&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a><a href="https://cn.vuejs.org/v2/api/#computed" target="_blank" rel="noopener">computed</a></h3><ul><li><p><strong>类型</strong>：<code>{ [key: string]: Function | { get: Function, set: Function } }</code></p></li><li><p><strong>详细</strong>：</p><p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p><p>注意如果你为一个计算属性使用了箭头函数，则 <code>this</code> 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  aDouble: vm &#x3D;&gt; vm.a * 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖 (比如非响应式属性) 在该实例范畴之外，则计算属性是<strong>不会</strong>被更新的。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  data: &#123; a: 1 &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    &#x2F;&#x2F; 仅读取</span><br><span class="line">    aDouble: function () &#123;</span><br><span class="line">      return this.a * 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 读取和设置</span><br><span class="line">    aPlus: &#123;</span><br><span class="line">      get: function () &#123;</span><br><span class="line">        return this.a + 1</span><br><span class="line">      &#125;,</span><br><span class="line">      set: function (v) &#123;</span><br><span class="line">        this.a &#x3D; v - 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.aPlus   &#x2F;&#x2F; &#x3D;&gt; 2</span><br><span class="line">vm.aPlus &#x3D; 3</span><br><span class="line">vm.a       &#x2F;&#x2F; &#x3D;&gt; 2</span><br><span class="line">vm.aDouble &#x2F;&#x2F; &#x3D;&gt; 4</span><br></pre></td></tr></table></figure></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="noopener">计算属性</a></p></li></ul><h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a><a href="https://cn.vuejs.org/v2/api/#methods" target="_blank" rel="noopener">methods</a></h3><ul><li><p><strong>类型</strong>：<code>{ [key: string]: Function }</code></p></li><li><p><strong>详细</strong>：</p><p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 <code>this</code> 自动绑定为 Vue 实例。</p><p>注意，<strong>不应该使用箭头函数来定义 method 函数</strong> (例如 <code>plus: () =&gt; this.a++</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.a</code> 将是 undefined。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  data: &#123; a: 1 &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    plus: function () &#123;</span><br><span class="line">      this.a++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.plus()</span><br><span class="line">vm.a &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/events.html" target="_blank" rel="noopener">事件处理器</a></p></li></ul><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a><a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="noopener">watch</a></h3><ul><li><p><strong>类型</strong>：<code>{ [key: string]: string | Function | Object | Array }</code></p></li><li><p><strong>详细</strong>：</p><p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 <code>$watch()</code>，遍历 watch 对象的每一个属性。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: 3,</span><br><span class="line">    d: 4,</span><br><span class="line">    e: &#123;</span><br><span class="line">      f: &#123;</span><br><span class="line">        g: 5</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    a: function (val, oldVal) &#123;</span><br><span class="line">      console.log(&#39;new: %s, old: %s&#39;, val, oldVal)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 方法名</span><br><span class="line">    b: &#39;someMethod&#39;,</span><br><span class="line">    &#x2F;&#x2F; 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深</span><br><span class="line">    c: &#123;</span><br><span class="line">      handler: function (val, oldVal) &#123; &#x2F;* ... *&#x2F; &#125;,</span><br><span class="line">      deep: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 该回调将会在侦听开始之后被立即调用</span><br><span class="line">    d: &#123;</span><br><span class="line">      handler: &#39;someMethod&#39;,</span><br><span class="line">      immediate: true</span><br><span class="line">    &#125;,</span><br><span class="line">    e: [</span><br><span class="line">      &#39;handle1&#39;,</span><br><span class="line">      function handle2 (val, oldVal) &#123; &#x2F;* ... *&#x2F; &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        handler: function handle3 (val, oldVal) &#123; &#x2F;* ... *&#x2F; &#125;,</span><br><span class="line">        &#x2F;* ... *&#x2F;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &#x2F;&#x2F; watch vm.e.f&#39;s value: &#123;g: 5&#125;</span><br><span class="line">    &#39;e.f&#39;: function (val, oldVal) &#123; &#x2F;* ... *&#x2F; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.a &#x3D; 2 &#x2F;&#x2F; &#x3D;&gt; new: 2, old: 1</span><br></pre></td></tr></table></figure><p>注意，<strong>不应该使用箭头函数来定义 watcher 函数</strong> (例如 <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.updateAutocomplete</code> 将是 undefined。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/api/#vm-watch" target="_blank" rel="noopener">实例方法 / 数据 - vm.$watch</a></p></li></ul><h2 id="选项-DOM"><a href="#选项-DOM" class="headerlink" title="选项/DOM"></a>选项/DOM</h2><h3 id="el"><a href="#el" class="headerlink" title="el"></a><a href="https://cn.vuejs.org/v2/api/#el" target="_blank" rel="noopener">el</a></h3><ul><li><p><strong>类型</strong>：<code>string | Element</code></p></li><li><p><strong>限制</strong>：只在由 <code>new</code> 创建的实例中遵守。</p></li><li><p><strong>详细</strong>：</p><p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。</p><p>在实例挂载之后，元素可以用 <code>vm.$el</code> 访问。</p><p>如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 <code>vm.$mount()</code> 手动开启编译。</p><p>提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载 root 实例到 <code>或者</code> 上。</p><p>如果 <code>render</code> 函数和 <code>template</code> 属性都不存在，挂载 DOM 元素的 HTML 会被提取出来用作模板，此时，必须使用 Runtime + Compiler 构建的 Vue 库。</p></li><li><p><strong>参考</strong>：</p><ul><li><a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示" target="_blank" rel="noopener">生命周期图示</a></li><li><a href="https://cn.vuejs.org/v2/guide/installation.html#运行时-编译器-vs-只包含运行时" target="_blank" rel="noopener">运行时 + 编译器 vs. 只包含运行时</a></li></ul></li></ul><h3 id="template"><a href="#template" class="headerlink" title="template"></a><a href="https://cn.vuejs.org/v2/api/#template" target="_blank" rel="noopener">template</a></h3><ul><li><p><strong>类型</strong>：<code>string</code></p></li><li><p><strong>详细</strong>：</p><p>一个字符串模板作为 Vue 实例的标识使用。模板将会 <strong>替换</strong> 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。</p><p>如果值以 <code>#</code> 开始，则它将被用作选择符，并使用匹配元素的 innerHTML 作为模板。常用的技巧是用 <code></code> 包含模板。</p><p>出于安全考虑，你应该只使用你信任的 Vue 模板。避免使用其他人生成的内容作为你的模板。</p><p>如果 Vue 选项中包含渲染函数，该模板将被忽略。</p></li><li><p><strong>参考</strong>：</p><ul><li><a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示" target="_blank" rel="noopener">生命周期图示</a></li><li><a href="https://cn.vuejs.org/v2/guide/components.html#通过插槽分发内容" target="_blank" rel="noopener">通过插槽分发内容</a></li></ul></li></ul><h3 id="render"><a href="#render" class="headerlink" title="render"></a><a href="https://cn.vuejs.org/v2/api/#render" target="_blank" rel="noopener">render</a></h3><ul><li><p><strong>类型</strong>：<code>(createElement: () =&gt; VNode) =&gt; VNode</code></p></li><li><p><strong>详细</strong>：</p><p>字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 <code>createElement</code> 方法作为第一个参数用来创建 <code>VNode</code>。</p><p>如果组件是一个函数组件，渲染函数还会接收一个额外的 <code>context</code> 参数，为没有实例的函数组件提供上下文信息。</p><p>Vue 选项中的 <code>render</code> 函数若存在，则 Vue 构造函数不会从 <code>template</code> 选项或通过 <code>el</code> 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">渲染函数</a></p></li></ul><h3 id="renderError"><a href="#renderError" class="headerlink" title="renderError"></a><a href="https://cn.vuejs.org/v2/api/#renderError" target="_blank" rel="noopener">renderError</a></h3><blockquote><p>2.2.0 新增</p></blockquote><ul><li><p><strong>类型</strong>：<code>(createElement: () =&gt; VNode, error: Error) =&gt; VNode</code></p></li><li><p><strong>详细</strong>：</p><p><strong>只在开发者环境下工作。</strong></p><p>当 <code>render</code> 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 <code>renderError</code>。这个功能配合 hot-reload 非常实用。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    throw new Error(&#39;oops&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  renderError (h, err) &#123;</span><br><span class="line">    return h(&#39;pre&#39;, &#123; style: &#123; color: &#39;red&#39; &#125;&#125;, err.stack)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">渲染函数</a></p></li></ul><h2 id="选项-生命钩子"><a href="#选项-生命钩子" class="headerlink" title="选项/生命钩子"></a>选项/生命钩子</h2><p>所有的生命周期钩子自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)。这是因为箭头函数绑定了父上下文，因此 <code>this</code> 与你期待的 Vue 实例不同，<code>this.fetchTodos</code> 的行为未定义。</p><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a><a href="https://cn.vuejs.org/v2/api/#beforeCreate" target="_blank" rel="noopener">beforeCreate</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示" target="_blank" rel="noopener">生命周期图示</a></p></li></ul><h3 id="created"><a href="#created" class="headerlink" title="created"></a><a href="https://cn.vuejs.org/v2/api/#created" target="_blank" rel="noopener">created</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> 属性目前不可见。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示" target="_blank" rel="noopener">生命周期图示</a></p></li></ul><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a><a href="https://cn.vuejs.org/v2/api/#beforeMount" target="_blank" rel="noopener">beforeMount</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示" target="_blank" rel="noopener">生命周期图示</a></p></li></ul><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a><a href="https://cn.vuejs.org/v2/api/#mounted" target="_blank" rel="noopener">mounted</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p><code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</p><p>注意 <code>mounted</code> <strong>不会</strong>承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick" target="_blank" rel="noopener">vm.$nextTick</a> 替换掉 <code>mounted</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mounted: function () &#123;</span><br><span class="line">  this.$nextTick(function () &#123;</span><br><span class="line">    &#x2F;&#x2F; Code that will run only after the</span><br><span class="line">    &#x2F;&#x2F; entire view has been rendered</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示" target="_blank" rel="noopener">生命周期图示</a></p></li></ul><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a><a href="https://cn.vuejs.org/v2/api/#beforeUpdate" target="_blank" rel="noopener">beforeUpdate</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p><p><strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</strong></p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示" target="_blank" rel="noopener">生命周期图示</a></p></li></ul><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a><a href="https://cn.vuejs.org/v2/api/#updated" target="_blank" rel="noopener">updated</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p><p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用<a href="https://cn.vuejs.org/v2/api/#computed" target="_blank" rel="noopener">计算属性</a>或 <a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="noopener">watcher</a> 取而代之。</p><p>注意 <code>updated</code> <strong>不会</strong>承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick" target="_blank" rel="noopener">vm.$nextTick</a> 替换掉 <code>updated</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">updated: function () &#123;</span><br><span class="line">  this.$nextTick(function () &#123;</span><br><span class="line">    &#x2F;&#x2F; Code that will run only after the</span><br><span class="line">    &#x2F;&#x2F; entire view has been re-rendered</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示" target="_blank" rel="noopener">生命周期图示</a></p></li></ul><h3 id="activated"><a href="#activated" class="headerlink" title="activated"></a><a href="https://cn.vuejs.org/v2/api/#activated" target="_blank" rel="noopener">activated</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>keep-alive 组件激活时调用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li><li><p><strong>参考</strong>：</p><ul><li><a href="https://cn.vuejs.org/v2/api/#keep-alive" target="_blank" rel="noopener">构建组件 - keep-alive</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#在动态组件上使用-keep-alive" target="_blank" rel="noopener">动态组件 - keep-alive</a></li></ul></li></ul><h3 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a><a href="https://cn.vuejs.org/v2/api/#deactivated" target="_blank" rel="noopener">deactivated</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>keep-alive 组件停用时调用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li><li><p><strong>参考</strong>：</p><ul><li><a href="https://cn.vuejs.org/v2/api/#keep-alive" target="_blank" rel="noopener">构建组件 - keep-alive</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#在动态组件上使用-keep-alive" target="_blank" rel="noopener">动态组件 - keep-alive</a></li></ul></li></ul><h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a><a href="https://cn.vuejs.org/v2/api/#beforeDestroy" target="_blank" rel="noopener">beforeDestroy</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>实例销毁之前调用。在这一步，实例仍然完全可用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示" target="_blank" rel="noopener">生命周期图示</a></p></li></ul><h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a><a href="https://cn.vuejs.org/v2/api/#destroyed" target="_blank" rel="noopener">destroyed</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示" target="_blank" rel="noopener">生命周期图示</a></p></li></ul><h3 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a><a href="https://cn.vuejs.org/v2/api/#errorCaptured" target="_blank" rel="noopener">errorCaptured</a></h3><blockquote><p>2.5.0+ 新增</p></blockquote><ul><li><p><strong>类型</strong>：<code>(err: Error, vm: Component, info: string) =&gt; ?boolean</code></p></li><li><p><strong>详细</strong>：</p><p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播。</p><p>你可以在此钩子中修改组件的状态。因此在模板或渲染函数中设置其它内容的短路条件非常重要，它可以防止当一个错误被捕获时该组件进入一个无限的渲染循环。</p><p><strong>错误传播规则</strong></p><ul><li>默认情况下，如果全局的 <code>config.errorHandler</code> 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。</li><li>如果一个组件的继承或父级从属链路中存在多个 <code>errorCaptured</code> 钩子，则它们将会被相同的错误逐个唤起。</li><li>如果此 <code>errorCaptured</code> 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 <code>config.errorHandler</code>。</li><li>一个 <code>errorCaptured</code> 钩子能够返回 <code>false</code> 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 <code>errorCaptured</code> 钩子和全局的 <code>config.errorHandler</code>。</li></ul></li></ul><h2 id="选项-资源"><a href="#选项-资源" class="headerlink" title="选项/资源"></a>选项/资源</h2><h3 id="directives"><a href="#directives" class="headerlink" title="directives"></a><a href="https://cn.vuejs.org/v2/api/#directives" target="_blank" rel="noopener">directives</a></h3><ul><li><strong>类型</strong>：<code>Object</code></li><li><strong>详细</strong>：</li></ul><p>包含 Vue 实例可用指令的哈希表。</p><ul><li><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">自定义指令</a></li></ul><h3 id="filters"><a href="#filters" class="headerlink" title="filters"></a><a href="https://cn.vuejs.org/v2/api/#filters" target="_blank" rel="noopener">filters</a></h3><ul><li><strong>类型</strong>：<code>Object</code></li><li><strong>详细</strong>：</li></ul><p>包含 Vue 实例可用过滤器的哈希表。</p><ul><li><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/api/#Vue-filter" target="_blank" rel="noopener"><code>Vue.filter</code></a></li></ul><h3 id="components"><a href="#components" class="headerlink" title="components"></a><a href="https://cn.vuejs.org/v2/api/#components" target="_blank" rel="noopener">components</a></h3><ul><li><strong>类型</strong>：<code>Object</code></li><li><strong>详细</strong>：</li></ul><p>包含 Vue 实例可用组件的哈希表。</p><ul><li><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">组件</a></li></ul><h2 id="选项-组合"><a href="#选项-组合" class="headerlink" title="选项/组合"></a>选项/组合</h2><h3 id="parent"><a href="#parent" class="headerlink" title="parent"></a><a href="https://cn.vuejs.org/v2/api/#parent" target="_blank" rel="noopener">parent</a></h3><ul><li><p><strong>类型</strong>：<code>Vue instance</code></p></li><li><p><strong>详细</strong>：</p><p>指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 <code>this.$parent</code> 访问父实例，子实例被推入父实例的 <code>$children</code> 数组中。</p><p>节制地使用 <code>$parent</code> 和 <code>$children</code> - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信</p></li></ul><h3 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a><a href="https://cn.vuejs.org/v2/api/#mixins" target="_blank" rel="noopener">mixins</a></h3><ul><li><p><strong>类型</strong>：<code>Array</code></p></li><li><p><strong>详细</strong>：</p><p><code>mixins</code> 选项接受一个混入对象的数组。这些混入实例对象可以像正常的实例对象一样包含选项，他们将在 <code>Vue.extend()</code> 里最终选择使用相同的选项合并逻辑合并。举例：如果你的混入包含一个钩子而创建组件本身也有一个，两个函数将被调用。</p><p>Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mixin &#x3D; &#123;</span><br><span class="line">  created: function () &#123; console.log(1) &#125;</span><br><span class="line">&#125;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  created: function () &#123; console.log(2) &#125;,</span><br><span class="line">  mixins: [mixin]</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; 1</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; 2</span><br></pre></td></tr></table></figure></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/mixins.html" target="_blank" rel="noopener">混入</a></p></li></ul><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a><a href="https://cn.vuejs.org/v2/api/#extends" target="_blank" rel="noopener">extends</a></h3><ul><li><p><strong>类型</strong>：<code>Object | Function</code></p></li><li><p><strong>详细</strong>：</p><p>允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数)，而无需使用 <code>Vue.extend</code>。这主要是为了便于扩展单文件组件。</p><p>这和 <code>mixins</code> 类似。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var CompA &#x3D; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在没有调用 &#96;Vue.extend&#96; 时候继承 CompA</span><br><span class="line">var CompB &#x3D; &#123;</span><br><span class="line">  extends: CompA,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide / inject"></a><a href="https://cn.vuejs.org/v2/api/#provide-inject" target="_blank" rel="noopener">provide / inject</a></h3><blockquote><p>2.2.0 新增</p></blockquote><ul><li><p><strong>类型</strong>：</p><ul><li><strong>provide</strong>：<code>Object | () =&gt; Object</code></li><li><strong>inject</strong>：<code>Array | { [key: string]: string | Symbol | Object }</code></li></ul></li><li><p><strong>详细</strong>：</p><p><code>provide</code> 和 <code>inject</code> 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。</p><p>这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。</p><p><code>provide</code> 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 <code>Symbol</code> 和 <code>Reflect.ownKeys</code> 的环境下可工作。</p><p><code>inject</code> 选项应该是：</p><ul><li>一个字符串数组，或</li><li>一个对象，对象的 key 是本地的绑定名，value 是：<ul><li>在可用的注入内容中搜索用的 key (字符串或 Symbol)，或</li><li>一个对象，该对象的：<ul><li><code>from</code> 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol)</li><li><code>default</code> 属性是降级情况下使用的 value</li></ul></li></ul></li></ul><blockquote><p>提示：<code>provide</code> 和 <code>inject</code> 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。</p></blockquote></li><li><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父级组件提供 &#39;foo&#39;</span><br><span class="line">var Provider &#x3D; &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    foo: &#39;bar&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子组件注入 &#39;foo&#39;</span><br><span class="line">var Child &#x3D; &#123;</span><br><span class="line">  inject: [&#39;foo&#39;],</span><br><span class="line">  created () &#123;</span><br><span class="line">    console.log(this.foo) &#x2F;&#x2F; &#x3D;&gt; &quot;bar&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 ES2015 Symbols、函数 <code>provide</code> 和对象 <code>inject</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const s &#x3D; Symbol()</span><br><span class="line"></span><br><span class="line">const Provider &#x3D; &#123;</span><br><span class="line">  provide () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      [s]: &#39;foo&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Child &#x3D; &#123;</span><br><span class="line">  inject: &#123; s &#125;,</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接下来 2 个例子只工作在 Vue 2.2.1 或更高版本。低于这个版本时，注入的值会在 <code>props</code> 和 <code>data</code> 初始化之后得到。</p></blockquote><p>使用一个注入的值作为一个属性的默认值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Child &#x3D; &#123;</span><br><span class="line">  inject: [&#39;foo&#39;],</span><br><span class="line">  props: &#123;</span><br><span class="line">    bar: &#123;</span><br><span class="line">      default () &#123;</span><br><span class="line">        return this.foo</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个注入的值作为数据入口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Child &#x3D; &#123;</span><br><span class="line">  inject: [&#39;foo&#39;],</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      bar: this.foo</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 2.5.0+ 的注入可以通过设置默认值使其变成可选项：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Child &#x3D; &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    foo: &#123; default: &#39;foo&#39; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果它需要从一个不同名字的属性注入，则使用 <code>from</code> 来表示其源属性：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Child &#x3D; &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      from: &#39;bar&#39;,</span><br><span class="line">      default: &#39;foo&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 prop 的默认值类似，你需要对非原始值使用一个工厂方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Child &#x3D; &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      from: &#39;bar&#39;,</span><br><span class="line">      default: () &#x3D;&gt; [1, 2, 3]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="选项-其他"><a href="#选项-其他" class="headerlink" title="选项/其他"></a>选项/其他</h2><h3 id="name"><a href="#name" class="headerlink" title="name"></a><a href="https://cn.vuejs.org/v2/api/#name" target="_blank" rel="noopener">name</a></h3><ul><li><p><strong>类型</strong>：<code>string</code></p></li><li><p><strong>限制</strong>：只有作为组件选项时起作用。</p></li><li><p><strong>详细</strong>：</p><p>允许组件模板递归地调用自身。注意，组件在全局用 <code>Vue.component()</code> 注册时，全局 ID 自动作为组件的 name。</p><p>指定 <code>name</code> 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="noopener">vue-devtools</a>，未命名组件将显示成 <code></code>，这很没有语义。通过提供 <code>name</code> 选项，可以获得更有语义信息的组件树。</p></li></ul><h3 id="delimiters"><a href="#delimiters" class="headerlink" title="delimiters"></a><a href="https://cn.vuejs.org/v2/api/#delimiters" target="_blank" rel="noopener">delimiters</a></h3><ul><li><p><strong>类型</strong>：<code>Array</code></p></li><li><p><strong>默认值</strong>：<code>[&quot;, &quot;]</code></p></li><li><p><strong>限制</strong>：这个选项只在完整构建版本中的浏览器内编译时可用。</p></li><li><p><strong>详细</strong>：</p><p>改变纯文本插入分隔符。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  delimiters: [&#39;$&#123;&#39;, &#39;&#125;&#39;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 分隔符变成了 ES6 模板字符串的风格</span><br></pre></td></tr></table></figure></li></ul><h3 id="functional"><a href="#functional" class="headerlink" title="functional"></a><a href="https://cn.vuejs.org/v2/api/#functional" target="_blank" rel="noopener">functional</a></h3><ul><li><p><strong>类型</strong>：<code>boolean</code></p></li><li><p><strong>详细</strong>：</p><p>使组件无状态 (没有 <code>data</code> ) 和无实例 (没有 <code>this</code> 上下文)。他们用一个简单的 <code>render</code> 函数返回虚拟节点使他们更容易渲染。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/render-function.html#函数式组件" target="_blank" rel="noopener">函数式组件</a></p></li></ul><h3 id="model"><a href="#model" class="headerlink" title="model"></a><a href="https://cn.vuejs.org/v2/api/#model" target="_blank" rel="noopener">model</a></h3><blockquote><p>2.2.0 新增</p></blockquote><ul><li><p><strong>类型</strong>：<code>{ prop?: string, event?: string }</code></p></li><li><p><strong>详细</strong>：</p><p>允许一个自定义组件在使用 <code>v-model</code> 时定制 prop 和 event。默认情况下，一个组件上的 <code>v-model</code> 会把 <code>value</code> 用作 prop 且把 <code>input</code> 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 <code>value</code> prop 来达到不同的目的。使用 <code>model</code> 选项可以回避这些情况产生的冲突。</p></li><li><p><strong>Example</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;my-checkbox&#39;, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &#39;checked&#39;,</span><br><span class="line">    event: &#39;change&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    &#x2F;&#x2F; this allows using the &#96;value&#96; prop for a different purpose</span><br><span class="line">    value: String,</span><br><span class="line">    &#x2F;&#x2F; use &#96;checked&#96; as the prop which take the place of &#96;value&#96;</span><br><span class="line">    checked: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;my-checkbox v-model&#x3D;&quot;foo&quot; value&#x3D;&quot;some value&quot;&gt;&lt;&#x2F;my-checkbox&gt;</span><br></pre></td></tr></table></figure><p>上述代码相当于：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;my-checkbox</span><br><span class="line">  :checked&#x3D;&quot;foo&quot;</span><br><span class="line">  @change&#x3D;&quot;val &#x3D;&gt; &#123; foo &#x3D; val &#125;&quot;</span><br><span class="line">  value&#x3D;&quot;some value&quot;&gt;</span><br><span class="line">&lt;&#x2F;my-checkbox&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="inheritAttrs"><a href="#inheritAttrs" class="headerlink" title="inheritAttrs"></a><a href="https://cn.vuejs.org/v2/api/#inheritAttrs" target="_blank" rel="noopener">inheritAttrs</a></h3><blockquote><p>2.4.0 新增</p></blockquote><ul><li><p><strong>类型</strong>：<code>boolean</code></p></li><li><p><strong>默认值</strong>：<code>true</code></p></li><li><p><strong>详细</strong>：</p><p>默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 <code>inheritAttrs</code> 到 <code>false</code>，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 <code>$attrs</code> 可以让这些特性生效，且可以通过 <code>v-bind</code> 显性的绑定到非根元素上。</p><p>注意：这个选项<strong>不影响</strong> <code>class</code> 和 <code>style</code> 绑定。</p></li></ul><h3 id="comments"><a href="#comments" class="headerlink" title="comments"></a><a href="https://cn.vuejs.org/v2/api/#comments" target="_blank" rel="noopener">comments</a></h3><blockquote><p>2.4.0 新增</p></blockquote><ul><li><p><strong>类型</strong>：<code>boolean</code></p></li><li><p><strong>默认值</strong>：<code>false</code></p></li><li><p><strong>限制</strong>：这个选项只在完整构建版本中的浏览器内编译时可用。</p></li><li><p><strong>详细</strong>：</p><p>当设为 <code>true</code> 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。</p></li></ul><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="vm-data"><a href="#vm-data" class="headerlink" title="vm.$data"></a><a href="https://cn.vuejs.org/v2/api/#vm-data" target="_blank" rel="noopener">vm.$data</a></h3><ul><li><p><strong>类型</strong>：<code>Object</code></p></li><li><p><strong>详细</strong>：</p><p>Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象属性的访问。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/api/#data" target="_blank" rel="noopener">选项 / 数据 - data</a></p></li></ul><h3 id="vm-props"><a href="#vm-props" class="headerlink" title="vm.$props"></a><a href="https://cn.vuejs.org/v2/api/#vm-props" target="_blank" rel="noopener">vm.$props</a></h3><blockquote><p>2.2.0 新增</p></blockquote><ul><li><p><strong>类型</strong>：<code>Object</code></p></li><li><p><strong>详细</strong>：</p><p>当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象属性的访问。</p></li></ul><h3 id="vm-el"><a href="#vm-el" class="headerlink" title="vm.$el"></a><a href="https://cn.vuejs.org/v2/api/#vm-el" target="_blank" rel="noopener">vm.$el</a></h3><ul><li><p><strong>类型</strong>：<code>Element</code></p></li><li><p><strong>只读</strong></p></li><li><p><strong>详细</strong>：</p><p>Vue 实例使用的根 DOM 元素。</p></li></ul><h3 id="vm-options"><a href="#vm-options" class="headerlink" title="vm.$options"></a><a href="https://cn.vuejs.org/v2/api/#vm-options" target="_blank" rel="noopener">vm.$options</a></h3><ul><li><p><strong>类型</strong>：<code>Object</code></p></li><li><p><strong>只读</strong></p></li><li><p><strong>详细</strong>：</p><p>用于当前 Vue 实例的初始化选项。需要在选项中包含自定义属性时会有用处：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  customOption: &#39;foo&#39;,</span><br><span class="line">  created: function () &#123;</span><br><span class="line">    console.log(this.$options.customOption) &#x2F;&#x2F; &#x3D;&gt; &#39;foo&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="vm-parent"><a href="#vm-parent" class="headerlink" title="vm.$parent"></a><a href="https://cn.vuejs.org/v2/api/#vm-parent" target="_blank" rel="noopener">vm.$parent</a></h3><ul><li><p><strong>类型</strong>：<code>Vue instance</code></p></li><li><p><strong>只读</strong></p></li><li><p><strong>详细</strong>：</p><p>父实例，如果当前实例有的话。</p></li></ul><h3 id="vm-root"><a href="#vm-root" class="headerlink" title="vm.$root"></a><a href="https://cn.vuejs.org/v2/api/#vm-root" target="_blank" rel="noopener">vm.$root</a></h3><ul><li><p><strong>类型</strong>：<code>Vue instance</code></p></li><li><p><strong>只读</strong></p></li><li><p><strong>详细</strong>：</p><p>当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。</p></li></ul><h3 id="vm-children"><a href="#vm-children" class="headerlink" title="vm.$children"></a><a href="https://cn.vuejs.org/v2/api/#vm-children" target="_blank" rel="noopener">vm.$children</a></h3><ul><li><p><strong>类型</strong>：<code>Array</code></p></li><li><p><strong>只读</strong></p></li><li><p><strong>详细</strong>：</p><p>当前实例的直接子组件。<strong>需要注意 <code>$children</code> 并不保证顺序，也不是响应式的。</strong>如果你发现自己正在尝试使用 <code>$children</code> 来进行数据绑定，考虑使用一个数组配合 <code>v-for</code> 来生成子组件，并且使用 Array 作为真正的来源。</p></li></ul><h3 id="vm-slots"><a href="#vm-slots" class="headerlink" title="vm.$slots"></a><a href="https://cn.vuejs.org/v2/api/#vm-slots" target="_blank" rel="noopener">vm.$slots</a></h3><ul><li><p><strong>类型</strong>：<code>{ [name: string]: ?Array }</code></p></li><li><p><strong>只读</strong></p></li><li><p><strong>详细</strong>：</p><p>用来访问被<a href="https://cn.vuejs.org/v2/guide/components.html#通过插槽分发内容" target="_blank" rel="noopener">插槽分发</a>的内容。每个<a href="https://cn.vuejs.org/v2/guide/components-slots.html#具名插槽" target="_blank" rel="noopener">具名插槽</a> 有其相应的属性 (例如：<code>v-slot:foo</code> 中的内容将会在 <code>vm.$slots.foo</code> 中被找到)。<code>default</code> 属性包括了所有没有被包含在具名插槽中的节点，或 <code>v-slot:default</code> 的内容。</p><p><strong>注意:</strong> <code>v-slot:foo</code> 在 2.6 以上的版本才支持。对于之前的版本，你可以使用<a href="https://cn.vuejs.org/v2/guide/components-slots.html#废弃了的语法" target="_blank" rel="noopener">废弃了的语法</a>.</p><p>在使用<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">渲染函数</a>书写一个组件时，访问 <code>vm.$slots</code> 最有帮助。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;blog-post&gt;</span><br><span class="line">  &lt;template v-slot:header&gt;</span><br><span class="line">    &lt;h1&gt;About Me&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;p&gt;Here&#39;s some page content, which will be included in vm.$slots.default, because it&#39;s not inside a named slot.&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:footer&gt;</span><br><span class="line">    &lt;p&gt;Copyright 2016 Evan You&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;p&gt;If I have some content down here, it will also be included in vm.$slots.default.&lt;&#x2F;p&gt;.</span><br><span class="line">&lt;&#x2F;blog-post&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;blog-post&#39;, &#123;</span><br><span class="line">  render: function (createElement) &#123;</span><br><span class="line">    var header &#x3D; this.$slots.header</span><br><span class="line">    var body   &#x3D; this.$slots.default</span><br><span class="line">    var footer &#x3D; this.$slots.footer</span><br><span class="line">    return createElement(&#39;div&#39;, [</span><br><span class="line">      createElement(&#39;header&#39;, header),</span><br><span class="line">      createElement(&#39;main&#39;, body),</span><br><span class="line">      createElement(&#39;footer&#39;, footer)</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>参考</strong>：</p><ul><li><a href="https://cn.vuejs.org/v2/api/#slot" target="_blank" rel="noopener"><code></code> 组件</a></li><li><a href="https://cn.vuejs.org/v2/guide/components.html#通过插槽分发内容" target="_blank" rel="noopener">通过插槽分发内容</a></li><li><a href="https://cn.vuejs.org/v2/guide/render-function.html#插槽" target="_blank" rel="noopener">渲染函数 - 插槽</a></li></ul></li></ul><h3 id="vm-scopedSlots"><a href="#vm-scopedSlots" class="headerlink" title="vm.$scopedSlots"></a><a href="https://cn.vuejs.org/v2/api/#vm-scopedSlots" target="_blank" rel="noopener">vm.$scopedSlots</a></h3><blockquote><p>2.1.0 新增</p></blockquote><ul><li><p><strong>类型</strong>：<code>{ [name: string]: props =&gt; Array | undefined }</code></p></li><li><p><strong>只读</strong></p></li><li><p><strong>详细</strong>：</p><p>用来访问<a href="https://cn.vuejs.org/v2/guide/components-slots.html#作用域插槽" target="_blank" rel="noopener">作用域插槽</a>。对于包括 <code>默认 slot</code> 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。</p><p><code>vm.$scopedSlots</code> 在使用<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">渲染函数</a>开发一个组件时特别有用。</p><p><strong>注意</strong>：从 2.6.0 开始，这个属性有两个变化：</p><ol><li>作用域插槽函数现在保证返回一个 VNode 数组，除非在返回值无效的情况下返回 <code>undefined</code>。</li><li>所有的 <code>$slots</code> 现在都会作为函数暴露在 <code>$scopedSlots</code> 中。如果你在使用渲染函数，不论当前插槽是否带有作用域，我们都推荐始终通过 <code>$scopedSlots</code> 访问它们。这不仅仅使得在未来添加作用域变得简单，也可以让你最终轻松迁移到所有插槽都是函数的 Vue 3。</li></ol></li><li><p><strong>参考</strong>：</p><ul><li><a href="https://cn.vuejs.org/v2/api/#slot" target="_blank" rel="noopener"><code></code> 组件</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-slots.html#作用域插槽" target="_blank" rel="noopener">作用域插槽</a></li><li><a href="https://cn.vuejs.org/v2/guide/render-function.html#插槽" target="_blank" rel="noopener">渲染函数 - 插槽</a></li></ul></li></ul><h3 id="vm-refs"><a href="#vm-refs" class="headerlink" title="vm.$refs"></a><a href="https://cn.vuejs.org/v2/api/#vm-refs" target="_blank" rel="noopener">vm.$refs</a></h3><ul><li><p><strong>类型</strong>：<code>Object</code></p></li><li><p><strong>只读</strong></p></li><li><p><strong>详细</strong>：</p><p>一个对象，持有注册过 <a href="https://cn.vuejs.org/v2/api/#ref" target="_blank" rel="noopener"><code>ref</code> 特性</a> 的所有 DOM 元素和组件实例。</p></li><li><p><strong>参考</strong>：</p><ul><li><a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#访问子组件实例或子元素" target="_blank" rel="noopener">子组件引用</a></li><li><a href="https://cn.vuejs.org/v2/api/#ref" target="_blank" rel="noopener">特殊特性 - ref</a></li></ul></li></ul><h3 id="vm-isServer"><a href="#vm-isServer" class="headerlink" title="vm.$isServer"></a><a href="https://cn.vuejs.org/v2/api/#vm-isServer" target="_blank" rel="noopener">vm.$isServer</a></h3><ul><li><p><strong>类型</strong>：<code>boolean</code></p></li><li><p><strong>只读</strong></p></li><li><p><strong>详细</strong>：</p><p>当前 Vue 实例是否运行于服务器。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/ssr.html" target="_blank" rel="noopener">服务端渲染</a></p></li></ul><h3 id="vm-attrs"><a href="#vm-attrs" class="headerlink" title="vm.$attrs"></a><a href="https://cn.vuejs.org/v2/api/#vm-attrs" target="_blank" rel="noopener">vm.$attrs</a></h3><blockquote><p>2.4.0 新增</p></blockquote><ul><li><p><strong>类型</strong>：<code>{ [key: string]: string }</code></p></li><li><p><strong>只读</strong></p></li><li><p><strong>详细</strong>：</p><p>包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (<code>class</code> 和 <code>style</code> 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (<code>class</code> 和 <code>style</code> 除外)，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件——在创建高级别的组件时非常有用。</p></li></ul><h3 id="vm-listeners"><a href="#vm-listeners" class="headerlink" title="vm.$listeners"></a><a href="https://cn.vuejs.org/v2/api/#vm-listeners" target="_blank" rel="noopener">vm.$listeners</a></h3><blockquote><p>2.4.0 新增</p></blockquote><ul><li><p><strong>类型</strong>：<code>{ [key: string]: Function | Array }</code></p></li><li><p><strong>只读</strong></p></li><li><p><strong>详细</strong>：</p><p>包含了父作用域中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件——在创建更高层次的组件时非常有用。</p></li></ul><h2 id="实例方法-数据"><a href="#实例方法-数据" class="headerlink" title="实例方法/数据"></a>实例方法/数据</h2><h3 id="vm-watch-expOrFn-callback-options"><a href="#vm-watch-expOrFn-callback-options" class="headerlink" title="vm.$watch( expOrFn, callback, [options] )"></a><a href="https://cn.vuejs.org/v2/api/#vm-watch" target="_blank" rel="noopener">vm.$watch( expOrFn, callback, [options] )</a></h3><ul><li><p><strong>参数</strong>：</p><ul><li><p><code>{string | Function} expOrFn</code></p></li><li><p><code>{Function | Object} callback</code></p></li><li><p><code>`</code><br>{Object} [options]</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - &#96;&#123;boolean&#125; deep&#96;</span><br><span class="line">    - &#96;&#123;boolean&#125; immediate&#96;</span><br><span class="line"></span><br><span class="line">- **返回值**：&#96;&#123;Function&#125; unwatch&#96;</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。</span><br><span class="line"></span><br><span class="line">  注意：在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象&#x2F;数组。Vue 不会保留变异之前值的副本。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br></pre></td></tr></table></figure><p>// 键路径<br>vm.$watch(‘a.b.c’, function (newVal, oldVal) {<br>// 做点什么<br>})</p></li></ul><p>// 函数<br>vm.$watch(<br>function () {</p><pre><code>// 表达式 `this.a + this.b` 每次得出一个不同的结果时
// 处理函数都会被调用。
// 这就像监听一个未被定义的计算属性
return this.a + this.b
</code></pre><p>},<br>function (newVal, oldVal) {</p><pre><code>// 做点什么
</code></pre><p>}<br>)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;vm.$watch&#96; 返回一个取消观察函数，用来停止触发回调：</span><br></pre></td></tr></table></figure><p>var unwatch = vm.$watch(‘a’, cb)<br>// 之后取消观察<br>unwatch()</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **选项：deep**</span><br><span class="line"></span><br><span class="line">  为了发现对象内部值的变化，可以在选项参数中指定 &#96;deep: true&#96; 。注意监听数组的变动不需要这么做。</span><br></pre></td></tr></table></figure><p>vm.$watch(‘someObject’, callback, {<br>deep: true<br>})<br>vm.someObject.nestedValue = 123<br>// callback is fired</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **选项：immediate**</span><br><span class="line"></span><br><span class="line">  在选项参数中指定 &#96;immediate: true&#96; 将立即以表达式的当前值触发回调：</span><br></pre></td></tr></table></figure><p>vm.$watch(‘a’, callback, {<br>immediate: true<br>})<br>// 立即以 <code>a</code> 的当前值触发回调</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">注意在带有 &#96;immediate&#96; 选项时，你不能在第一次回调时取消侦听给定的 property。</span><br></pre></td></tr></table></figure><p>// 这会导致报错<br>var unwatch = vm.$watch(<br>‘value’,<br>function () {</p><pre><code>doSomething()
unwatch()
</code></pre><p>},<br>{ immediate: true }<br>)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果你仍然希望在回调内部调用一个取消侦听的函数，你应该先检查其函数的可用性：</span><br></pre></td></tr></table></figure><p>var unwatch = vm.$watch(<br>‘value’,<br>function () {</p><pre><code>doSomething()
if (unwatch) {
  unwatch()
}
</code></pre><p>},<br>{ immediate: true }<br>)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### [vm.$set( target, propertyName&#x2F;index, value )](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#vm-set)</span><br><span class="line"></span><br><span class="line">- **参数**：</span><br><span class="line"></span><br><span class="line">  - &#96;&#123;Object | Array&#125; target&#96;</span><br><span class="line">  - &#96;&#123;string | number&#125; propertyName&#x2F;index&#96;</span><br><span class="line">  - &#96;&#123;any&#125; value&#96;</span><br><span class="line"></span><br><span class="line">- **返回值**：设置的值。</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  这是全局 &#96;Vue.set&#96; 的**别名**。</span><br><span class="line"></span><br><span class="line">- **参考**：[Vue.set](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#Vue-set)</span><br><span class="line"></span><br><span class="line">### [vm.$delete( target, propertyName&#x2F;index )](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#vm-delete)</span><br><span class="line"></span><br><span class="line">- **参数**：</span><br><span class="line"></span><br><span class="line">  - &#96;&#123;Object | Array&#125; target&#96;</span><br><span class="line">  - &#96;&#123;string | number&#125; propertyName&#x2F;index&#96;</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  这是全局 &#96;Vue.delete&#96; 的**别名**。</span><br><span class="line"></span><br><span class="line">- **参考**：[Vue.delete](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#Vue-delete)</span><br><span class="line"></span><br><span class="line">## [实例方法 &#x2F; 事件](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#实例方法-事件)</span><br><span class="line"></span><br><span class="line">### [vm.$on( event, callback )](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#vm-on)</span><br><span class="line"></span><br><span class="line">- **参数**：</span><br><span class="line"></span><br><span class="line">  - &#96;&#123;string | Array&#125; event&#96; (数组只在 2.2.0+ 中支持)</span><br><span class="line">  - &#96;&#123;Function&#125; callback&#96;</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  监听当前实例上的自定义事件。事件可以由&#96;vm.$emit&#96;触发。回调函数会接收所有传入事件触发函数的额外参数。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br></pre></td></tr></table></figure><p>vm.$on(‘test’, function (msg) {<br>console.log(msg)<br>})<br>vm.$emit(‘test’, ‘hi’)<br>// =&gt; “hi”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### [vm.$once( event, callback )](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#vm-once)</span><br><span class="line"></span><br><span class="line">- **参数**：</span><br><span class="line"></span><br><span class="line">  - &#96;&#123;string&#125; event&#96;</span><br><span class="line">  - &#96;&#123;Function&#125; callback&#96;</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。</span><br><span class="line"></span><br><span class="line">### [vm.$off( [event, callback\] )](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#vm-off)</span><br><span class="line"></span><br><span class="line">- **参数**：</span><br><span class="line"></span><br><span class="line">  - &#96;&#123;string | Array&#125; event&#96; (只在 2.2.2+ 支持数组)</span><br><span class="line">  - &#96;&#123;Function&#125; [callback]&#96;</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  移除自定义事件监听器。</span><br><span class="line"></span><br><span class="line">  - 如果没有提供参数，则移除所有的事件监听器；</span><br><span class="line">  - 如果只提供了事件，则移除该事件所有的监听器；</span><br><span class="line">  - 如果同时提供了事件与回调，则只移除这个回调的监听器。</span><br><span class="line"></span><br><span class="line">### [vm.$emit( eventName, […args\] )](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#vm-emit)</span><br><span class="line"></span><br><span class="line">- **参数**：</span><br><span class="line"></span><br><span class="line">  - &#96;&#123;string&#125; eventName&#96;</span><br><span class="line">  - &#96;[...args]&#96;</span><br><span class="line"></span><br><span class="line">  触发当前实例上的事件。附加参数都会传给监听器回调。</span><br><span class="line"></span><br><span class="line">- **示例：**</span><br><span class="line"></span><br><span class="line">  只配合一个事件名使用 &#96;$emit&#96;：</span><br></pre></td></tr></table></figure><p>Vue.component(‘welcome-button’, {<br>template: `</p><pre><code>&lt;button v-on:click=&quot;$emit(&apos;welcome&apos;)&quot;&gt;
  Click me to be welcomed
&lt;/button&gt;
</code></pre><p>`<br>})</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><div id="emit-example-simple"><br><welcome-button v-on:welcome="sayHi"></welcome-button><br></div><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>new Vue({<br>el: ‘#emit-example-simple’,<br>methods: {<br>sayHi: function () {<br>alert(‘Hi!’)<br>}<br>}<br>})<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Click me to be welcomed</span><br><span class="line"></span><br><span class="line">配合额外的参数使用 &#96;$emit&#96;：</span><br></pre></td></tr></table></figure><br>Vue.component(‘magic-eight-ball’, {<br>data: function () {<br>return {<br>possibleAdvice: [‘Yes’, ‘No’, ‘Maybe’]<br>}<br>},<br>methods: {<br>giveAdvice: function () {<br>var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)<br>this.$emit(‘give-advice’, this.possibleAdvice[randomAdviceIndex])<br>}<br>},<br>template: <code>&lt;button v-on:click=&quot;giveAdvice&quot;&gt; Click me for advice &lt;/button&gt;</code><br>})<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><div id="emit-example-argument"><br><magic-eight-ball v-on:give-advice="showAdvice"></magic-eight-ball><br></div><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>new Vue({<br>el: ‘#emit-example-argument’,<br>methods: {<br>showAdvice: function (advice) {<br>alert(advice)<br>}<br>}<br>})<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  Click me for advice</span><br><span class="line"></span><br><span class="line">## [实例方法 &#x2F; 生命周期](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#实例方法-生命周期)</span><br><span class="line"></span><br><span class="line">### [vm.$mount( [elementOrSelector\] )](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#vm-mount)</span><br><span class="line"></span><br><span class="line">- **参数**：</span><br><span class="line"></span><br><span class="line">  - &#96;&#123;Element | string&#125; [elementOrSelector]&#96;</span><br><span class="line">  - &#96;&#123;boolean&#125; [hydrating]&#96;</span><br><span class="line"></span><br><span class="line">- **返回值**：&#96;vm&#96; - 实例自身</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 &#96;vm.$mount()&#96; 手动地挂载一个未挂载的实例。</span><br><span class="line"></span><br><span class="line">  如果没有提供 &#96;elementOrSelector&#96; 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。</span><br><span class="line"></span><br><span class="line">  这个方法返回实例自身，因而可以链式调用其它实例方法。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br></pre></td></tr></table></figure><br>var MyComponent = Vue.extend({<br>template: ‘<div>Hello!</div>‘<br>})<br><br>// 创建并挂载到 #app (会替换 #app)<br>new MyComponent().$mount(‘#app’)<br><br>// 同上<br>new MyComponent({ el: ‘#app’ })<br><br>// 或者，在文档之外渲染并且随后挂载<br>var component = new MyComponent().$mount()<br>document.getElementById(‘app’).appendChild(component.$el)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **参考**：</span><br><span class="line"></span><br><span class="line">  - [生命周期图示](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;instance.html#生命周期图示)</span><br><span class="line">  - [服务端渲染](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;ssr.html)</span><br><span class="line"></span><br><span class="line">### [vm.$forceUpdate()](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#vm-forceUpdate)</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br><span class="line"></span><br><span class="line">  迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</span><br><span class="line"></span><br><span class="line">### [vm.$nextTick( [callback\] )](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#vm-nextTick)</span><br><span class="line"></span><br><span class="line">- **参数**：</span><br><span class="line"></span><br><span class="line">  - &#96;&#123;Function&#125; [callback]&#96;</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 &#96;Vue.nextTick&#96; 一样，不同的是回调的 &#96;this&#96; 自动绑定到调用它的实例上。</span><br><span class="line"></span><br><span class="line">  &gt; 2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不是原生支持 Promise (IE：你们都看我干嘛)，你得自行 polyfill。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br></pre></td></tr></table></figure><br>new Vue({<br>// …<br>methods: {<br>// …<br>example: function () {<br>// 修改数据<br>this.message = ‘changed’<br>// DOM 还没有更新<br>this.$nextTick(function () {<br>// DOM 现在更新了<br>// <code>this</code> 绑定到当前实例<br>this.doSomethingElse()<br>})<br>}<br>}<br>})<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **参考**</span><br><span class="line"></span><br><span class="line">  - [Vue.nextTick](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#Vue-nextTick)</span><br><span class="line">  - [异步更新队列](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;reactivity.html#异步更新队列)</span><br><span class="line"></span><br><span class="line">### [vm.$destroy()](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#vm-destroy)</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。</span><br><span class="line"></span><br><span class="line">  触发 &#96;beforeDestroy&#96; 和 &#96;destroyed&#96; 的钩子。</span><br><span class="line"></span><br><span class="line">  在大多数场景中你不应该调用这个方法。最好使用 &#96;v-if&#96; 和 &#96;v-for&#96; 指令以数据驱动的方式控制子组件的生命周期。</span><br><span class="line"></span><br><span class="line">- **参考**：[生命周期图示](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;instance.html#生命周期图示)</span><br><span class="line"></span><br><span class="line">## [指令](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#指令)</span><br><span class="line"></span><br><span class="line">### [v-text](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-text)</span><br><span class="line"></span><br><span class="line">- **预期**：&#96;string&#96;</span><br><span class="line"></span><br><span class="line">- **详细**：</span><br><span class="line"></span><br><span class="line">  更新元素的 &#96;textContent&#96;。如果要更新部分的 &#96;textContent&#96; ，需要使用 &#96;&#123;&#123; Mustache &#125;&#125;&#96; 插值。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br></pre></td></tr></table></figure><br><span v-text="msg"></span><br><br><span></span><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **参考**：[数据绑定语法 - 插值](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;syntax.html#插值)</span><br><span class="line"></span><br><span class="line">### [v-html](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-html)</span><br><span class="line"></span><br><span class="line">- **预期**：&#96;string&#96;</span><br><span class="line"></span><br><span class="line">- **详细**：</span><br><span class="line"></span><br><span class="line">  更新元素的 &#96;innerHTML&#96; 。**注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译** 。如果试图使用 &#96;v-html&#96; 组合模板，可以重新考虑是否通过使用组件来替代。</span><br><span class="line"></span><br><span class="line">  在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 [XSS 攻击](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cross-site_scripting)。只在可信内容上使用 &#96;v-html&#96;，**永不**用在用户提交的内容上。</span><br><span class="line"></span><br><span class="line">  在[单文件组件](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;single-file-components.html)里，&#96;scoped&#96; 的样式不会应用在 &#96;v-html&#96; 内部，因为那部分 HTML 没有被 Vue 的模板编译器处理。如果你希望针对 &#96;v-html&#96; 的内容设置带作用域的 CSS，你可以替换为 [CSS Modules](https:&#x2F;&#x2F;vue-loader.vuejs.org&#x2F;en&#x2F;features&#x2F;css-modules.html) 或用一个额外的全局 &#96;&#96; 元素手动设置类似 BEM 的作用域策略。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br></pre></td></tr></table></figure><br><div v-html="html"></div><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **参考**：[数据绑定语法 - 插值](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;syntax.html#纯-HTML)</span><br><span class="line"></span><br><span class="line">### [v-show](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-show)</span><br><span class="line"></span><br><span class="line">- **预期**：&#96;any&#96;</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  根据表达式之真假值，切换元素的 &#96;display&#96; CSS 属性。</span><br><span class="line"></span><br><span class="line">  当条件变化时该指令触发过渡效果。</span><br><span class="line"></span><br><span class="line">- **参考**：[条件渲染 - v-show](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;conditional.html#v-show)</span><br><span class="line"></span><br><span class="line">### [v-if](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-if)</span><br><span class="line"></span><br><span class="line">- **预期**：&#96;any&#96;</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 &#x2F; 组件被销毁并重建。如果元素是 &#96; ，将提出它的内容作为条件块。</span><br><span class="line"></span><br><span class="line">  当条件变化时该指令触发过渡效果。</span><br><span class="line"></span><br><span class="line">  当和 &#96;v-if&#96; 一起使用时，&#96;v-for&#96; 的优先级比 &#96;v-if&#96; 更高。详见[列表渲染教程](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;list.html#v-for-with-v-if)</span><br><span class="line"></span><br><span class="line">- **参考**：[条件渲染 - v-if](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;conditional.html)</span><br><span class="line"></span><br><span class="line">### [v-else](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-else)</span><br><span class="line"></span><br><span class="line">- **不需要表达式**</span><br><span class="line"></span><br><span class="line">- **限制**：前一兄弟元素必须有 &#96;v-if&#96; 或 &#96;v-else-if&#96;。</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  为 &#96;v-if&#96; 或者 &#96;v-else-if&#96; 添加“else 块”。</span><br></pre></td></tr></table></figure><br><div v-if="Math.random() > 0.5"><br>Now you see me<br></div><br><div v-else><br>Now you don’t<br></div><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **参考**：[条件渲染 - v-else](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;conditional.html#v-else)</span><br><span class="line"></span><br><span class="line">### [v-else-if](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-else-if)</span><br><span class="line"></span><br><span class="line">&gt; 2.1.0 新增</span><br><span class="line"></span><br><span class="line">- **类型**：&#96;any&#96;</span><br><span class="line"></span><br><span class="line">- **限制**：前一兄弟元素必须有 &#96;v-if&#96; 或 &#96;v-else-if&#96;。</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  表示 &#96;v-if&#96; 的 “else if 块”。可以链式调用。</span><br></pre></td></tr></table></figure><br><div v-if="type === 'A'"><br>A<br></div><br><div v-else-if="type === 'B'"><br>B<br></div><br><div v-else-if="type === 'C'"><br>C<br></div><br><div v-else><br>Not A/B/C<br></div><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **参考**：[条件渲染 - v-else-if](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;conditional.html#v-else-if)</span><br><span class="line"></span><br><span class="line">### [v-for](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-for)</span><br><span class="line"></span><br><span class="line">- **预期**：&#96;Array | Object | number | string | Iterable (2.6 新增)&#96;</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 &#96;alias in expression&#96; ，为当前遍历的元素提供别名：</span><br></pre></td></tr></table></figure><br><div v-for="item in items"><br><br></div><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">另外也可以为数组索引指定别名 (或者用于对象的键)：</span><br></pre></td></tr></table></figure><br><div v-for="(item, index) in items"></div><br><div v-for="(val, key) in object"></div><br><div v-for="(val, name, index) in object"></div><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;v-for&#96; 默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素，你需要提供一个 &#96;key&#96; 的特殊属性：</span><br></pre></td></tr></table></figure><br><div v-for="item in items" :key="item.id"><br><br></div><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  从 2.6 起，&#96;v-for&#96; 也可以在实现了[可迭代协议](https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Iteration_protocols#可迭代协议)的值上使用，包括原生的 &#96;Map&#96; 和 &#96;Set&#96;。不过应该注意的是 Vue 2.x 目前并不支持可响应的 &#96;Map&#96; 和 &#96;Set&#96; 值，所以无法自动探测变更。</span><br><span class="line"></span><br><span class="line">  当和 &#96;v-if&#96; 一起使用时，&#96;v-for&#96; 的优先级比 &#96;v-if&#96; 更高。详见[列表渲染教程](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;list.html#v-for-with-v-if)</span><br><span class="line"></span><br><span class="line">  &#96;v-for&#96; 的详细用法可以通过以下链接查看教程详细说明。</span><br><span class="line"></span><br><span class="line">- **参考**：</span><br><span class="line"></span><br><span class="line">  - [列表渲染](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;list.html)</span><br><span class="line">  - [key](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;list.html#key)</span><br><span class="line"></span><br><span class="line">### [v-on](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-on)</span><br><span class="line"></span><br><span class="line">- **缩写**：&#96;@&#96;</span><br><span class="line"></span><br><span class="line">- **预期**：&#96;Function | Inline Statement | Object&#96;</span><br><span class="line"></span><br><span class="line">- **参数**：&#96;event&#96;</span><br><span class="line"></span><br><span class="line">- **修饰符**：</span><br><span class="line"></span><br><span class="line">  - &#96;.stop&#96; - 调用 &#96;event.stopPropagation()&#96;。</span><br><span class="line">  - &#96;.prevent&#96; - 调用 &#96;event.preventDefault()&#96;。</span><br><span class="line">  - &#96;.capture&#96; - 添加事件侦听器时使用 capture 模式。</span><br><span class="line">  - &#96;.self&#96; - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</span><br><span class="line">  - &#96;.&#123;keyCode | keyAlias&#125;&#96; - 只当事件是从特定键触发时才触发回调。</span><br><span class="line">  - &#96;.native&#96; - 监听组件根元素的原生事件。</span><br><span class="line">  - &#96;.once&#96; - 只触发一次回调。</span><br><span class="line">  - &#96;.left&#96; - (2.2.0) 只当点击鼠标左键时触发。</span><br><span class="line">  - &#96;.right&#96; - (2.2.0) 只当点击鼠标右键时触发。</span><br><span class="line">  - &#96;.middle&#96; - (2.2.0) 只当点击鼠标中键时触发。</span><br><span class="line">  - &#96;.passive&#96; - (2.3.0) 以 &#96;&#123; passive: true &#125;&#96; 模式添加侦听器</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</span><br><span class="line"></span><br><span class="line">  用在普通元素上时，只能监听[**原生 DOM 事件**](https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;Events)。用在自定义元素组件上时，也可以监听子组件触发的**自定义事件**。</span><br><span class="line"></span><br><span class="line">  在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 &#96;$event&#96; 属性：&#96;v-on:click&#x3D;&quot;handle(&#39;ok&#39;, $event)&quot;&#96;。</span><br><span class="line"></span><br><span class="line">  从 &#96;2.4.0&#96; 开始，&#96;v-on&#96; 同样支持不带参数绑定一个事件&#x2F;监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br></pre></td></tr></table></figure><br><br><button v-on:click="doThis"></button><br><br><br><button v-on:[event]="doThis"></button><br><br><br><button v-on:click="doThat('hello', $event)"></button><br><br><br><button @click="doThis"></button><br><br><br><button @[event]="doThis"></button><br><br><br><button @click.stop="doThis"></button><br><br><br><button @click.prevent="doThis"></button><br><br><br><form @submit.prevent></form><br><br><br><button @click.stop.prevent="doThis"></button><br><br><br><input @keyup.enter="onEnter"><br><br><br><input @keyup.13="onEnter"><br><br><br><button v-on:click.once="doThis"></button><br><br><br><button v-on="{ mousedown: doThis, mouseup: doThat }"></button><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)：</span><br></pre></td></tr></table></figure><br><my-component @my-event="handleThis"></my-component><br><br><br><my-component @my-event="handleThis(123, $event)"></my-component><br><br><br><my-component @click.native="onClick"></my-component><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **参考**：</span><br><span class="line"></span><br><span class="line">  - [事件处理器](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;events.html)</span><br><span class="line">  - [组件 - 自定义事件](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;components.html#监听子组件事件)</span><br><span class="line"></span><br><span class="line">### [v-bind](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-bind)</span><br><span class="line"></span><br><span class="line">- **缩写**：&#96;:&#96;</span><br><span class="line"></span><br><span class="line">- **预期**：&#96;any (with argument) | Object (without argument)&#96;</span><br><span class="line"></span><br><span class="line">- **参数**：&#96;attrOrProp (optional)&#96;</span><br><span class="line"></span><br><span class="line">- **修饰符**：</span><br><span class="line"></span><br><span class="line">  - &#96;.prop&#96; - 被用于绑定 DOM 属性 (property)。([差别在哪里？](https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;6003819&#x2F;properties-and-attributes-in-html#answer-6004028))</span><br><span class="line">  - &#96;.camel&#96; - (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持)</span><br><span class="line">  - &#96;.sync&#96; (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 &#96;v-on&#96; 侦听器。</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  动态地绑定一个或多个特性，或一个组件 prop 到表达式。</span><br><span class="line"></span><br><span class="line">  在绑定 &#96;class&#96; 或 &#96;style&#96; 特性时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。</span><br><span class="line"></span><br><span class="line">  在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。</span><br><span class="line"></span><br><span class="line">  没有参数时，可以绑定到一个包含键值对的对象。注意此时 &#96;class&#96; 和 &#96;style&#96; 绑定不支持数组和对象。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br></pre></td></tr></table></figure><br><br><img v-bind:src="imageSrc"><br><br><br><button v-bind:[key]="value"></button><br><br><br><img :src="imageSrc"><br><br><br><button :[key]="value"></button><br><br><br><img :src="'/path/to/images/' + fileName"><br><br><br><div :class="{ red: isRed }"></div><br><div :class="[classA, classB]"></div><br><div :class="[classA, { classB: isB, classC: isC }]"><br><br><br><div :style="{ fontSize: size + 'px' }"></div><br><div :style="[styleObjectA, styleObjectB]"></div><div v-bind="{ id: someProp, 'other-attr': otherProp }"></div><div v-bind:text-content.prop="text"></div><p><my-component :prop="someThing"></my-component></p><p><child-component v-bind="$props"></child-component></p><p><svg><a :xlink:special="foo"></a></svg></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;.camel&#96; 修饰符允许在使用 DOM 模板时将 &#96;v-bind&#96; 属性名称驼峰化，例如 SVG 的 &#96;viewBox&#96; 属性：</span><br></pre></td></tr></table></figure><p><svg :view-box.camel="viewBox"></svg></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  在使用字符串模板或通过 &#96;vue-loader&#96;&#x2F;&#96;vueify&#96; 编译时，无需使用 &#96;.camel&#96;。</span><br><span class="line"></span><br><span class="line">- **参考**：</span><br><span class="line"></span><br><span class="line">  - [Class 与 Style 绑定](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;class-and-style.html)</span><br><span class="line">  - [组件 - Props](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;components.html#通过-Prop-向子组件传递数据)</span><br><span class="line">  - [组件 - &#96;.sync&#96; 修饰符](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;components-custom-events.html#sync-修饰符)</span><br><span class="line"></span><br><span class="line">### [v-model](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-model)</span><br><span class="line"></span><br><span class="line">- **预期**：随表单控件类型不同而不同。</span><br><span class="line"></span><br><span class="line">- **限制**：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;</span><br><span class="line">  - &#96;&#96;</span><br><span class="line">  - &#96;&#96;</span><br><span class="line">  - components</span><br><span class="line"></span><br><span class="line">- **修饰符**：</span><br><span class="line"></span><br><span class="line">  - [&#96;.lazy&#96;](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;forms.html#lazy) - 取代 &#96;input&#96; 监听 &#96;change&#96; 事件</span><br><span class="line">  - [&#96;.number&#96;](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;forms.html#number) - 输入字符串转为有效的数字</span><br><span class="line">  - [&#96;.trim&#96;](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;forms.html#trim) - 输入首尾空格过滤</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  在表单控件或者组件上创建双向绑定。细节请看下面的教程链接。</span><br><span class="line"></span><br><span class="line">- **参考**：</span><br><span class="line"></span><br><span class="line">  - [表单控件绑定](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;forms.html)</span><br><span class="line">  - [组件 - 在输入组件上使用自定义事件](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;components-custom-events.html#将原生事件绑定到组件)</span><br><span class="line"></span><br><span class="line">### [v-slot](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-slot)</span><br><span class="line"></span><br><span class="line">- **缩写**：&#96;#&#96;</span><br><span class="line"></span><br><span class="line">- **预期**：可放置在函数参数位置的 JavaScript 表达式 (在[支持的环境下](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;components-slots.html#解构插槽-Props)可使用解构)。可选，即只需要在为插槽传入 prop 的时候使用。</span><br><span class="line"></span><br><span class="line">- **参数**：插槽名 (可选，默认值是 &#96;default&#96;)</span><br><span class="line"></span><br><span class="line">- **限用于**</span><br><span class="line"></span><br><span class="line">  - &#96;</span><br><span class="line">  - [组件](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;components-slots.html#独占默认插槽的缩写语法) (对于一个单独的带 prop 的默认插槽)</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  提供具名插槽或需要接收 prop 的插槽。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br></pre></td></tr></table></figure><p><base-layout></base-layout></p><template v-slot:header><br>Header content<br></template><p>Default slot content</p><p><template v-slot:footer></template></p><pre><code>Footer content
</code></pre><p><br></p><p><infinite-scroll><br><template v-slot:item="slotProps"></template></infinite-scroll></p><pre><code>&lt;div class=&quot;item&quot;&gt;
  {{ slotProps.item.text }}
&lt;/div&gt;
</code></pre><p><br></p><p><mouse-position v-slot="{ x, y }"><br>Mouse position: ,<br></mouse-position></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  更多细节请查阅以下链接。</span><br><span class="line"></span><br><span class="line">- **参考**：</span><br><span class="line"></span><br><span class="line">  - [组件 - 插槽](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;components-slots.html)</span><br><span class="line">  - [RFC-0001](https:&#x2F;&#x2F;github.com&#x2F;vuejs&#x2F;rfcs&#x2F;blob&#x2F;master&#x2F;active-rfcs&#x2F;0001-new-slot-syntax.md)</span><br><span class="line"></span><br><span class="line">### [v-pre](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-pre)</span><br><span class="line"></span><br><span class="line">- **不需要表达式**</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br></pre></td></tr></table></figure><p><span v-pre>{ { this will not be compiled } }</span></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### [v-cloak](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-cloak)</span><br><span class="line"></span><br><span class="line">- **不需要表达式**</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 &#96;[v-cloak] &#123; display: none &#125;&#96; 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br></pre></td></tr></table></figure><p>[v-cloak] {<br>display: none;<br>}</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><div v-cloak><p></p><p></p></div><p></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  不会显示，直到编译结束。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### [v-once](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-once)</span><br><span class="line"></span><br><span class="line">- **不需要表达式**</span><br><span class="line"></span><br><span class="line">- **详细**：</span><br><span class="line"></span><br><span class="line">  只渲染元素和组件**一次**。随后的重新渲染，元素&#x2F;组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</span><br></pre></td></tr></table></figure><p><span v-once>This will never change:</span></p><p></p><div v-once><br><h1>comment</h1><p></p><p></p><br></div><br><br><my-component v-once :comment="msg"></my-component><br><br><ul><br><li v-for="i in list" v-once></li><br></ul><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **参考**：</span><br><span class="line"></span><br><span class="line">  - [数据绑定语法- 插值](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;syntax.html#插值)</span><br><span class="line">  - [组件 - 对低开销的静态组件使用 &#96;v-once&#96;](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;components-edge-cases.html#通过-v-once-创建低开销的静态组件)</span><br><span class="line"></span><br><span class="line">## [特殊特性](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#特殊特性)</span><br><span class="line"></span><br><span class="line">### [key](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#key)</span><br><span class="line"></span><br><span class="line">- **预期**：&#96;number | string&#96;</span><br><span class="line"></span><br><span class="line">  &#96;key&#96; 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复&#x2F;再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</span><br><span class="line"></span><br><span class="line">  有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误。</span><br><span class="line"></span><br><span class="line">  最常见的用例是结合 &#96;v-for&#96;：</span><br></pre></td></tr></table></figure><br><ul><br><li v-for="item in items" :key="item.id">…</li><br></ul><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">它也可以用于强制替换元素&#x2F;组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</span><br><span class="line"></span><br><span class="line">- 完整地触发组件的生命周期钩子</span><br><span class="line">- 触发过渡</span><br><span class="line"></span><br><span class="line">例如：</span><br></pre></td></tr></table></figure><br><transition><br><span :key="text"></span><br></transition><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  当 &#96;text&#96; 发生改变时，&#96;&#96; 会随时被更新，因此会触发过渡。</span><br><span class="line"></span><br><span class="line">### [ref](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#ref)</span><br><span class="line"></span><br><span class="line">- **预期**：&#96;string&#96;</span><br><span class="line"></span><br><span class="line">  &#96;ref&#96; 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 &#96;$refs&#96; 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：</span><br></pre></td></tr></table></figure><br><br><p ref="p">hello</p><p><child-component ref="child"></child-component></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  当 &#96;v-for&#96; 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。</span><br><span class="line"></span><br><span class="line">  关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！&#96;$refs&#96; 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</span><br><span class="line"></span><br><span class="line">- **参考**：[子组件引用](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;components-edge-cases.html#访问子组件实例或子元素)</span><br><span class="line"></span><br><span class="line">### [is](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#is)</span><br><span class="line"></span><br><span class="line">- **预期**：&#96;string | Object (组件的选项对象)&#96;</span><br><span class="line"></span><br><span class="line">  用于[动态组件](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;components.html#动态组件)且基于 [DOM 内模板的限制](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;components.html#解析-DOM-模板时的注意事项)来工作。</span><br><span class="line"></span><br><span class="line">  示例：</span><br></pre></td></tr></table></figure><component v-bind:is="currentView"></component><p><table><br><tr is="my-row"></tr><br></table></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  更多的使用细节，请移步至下面的链接。</span><br><span class="line"></span><br><span class="line">- **See also**：</span><br><span class="line"></span><br><span class="line">  - [动态组件](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;components.html#动态组件)</span><br><span class="line">  - [DOM 模板解析说明](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;components.html#解析-DOM-模板时的注意事项)</span><br><span class="line"></span><br><span class="line">### [slot 废弃](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#slot-废弃)</span><br><span class="line"></span><br><span class="line">**推荐 2.6.0 新增的 [v-slot](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-slot)。**</span><br><span class="line"></span><br><span class="line">- **预期**：&#96;string&#96;</span><br><span class="line"></span><br><span class="line">  用于标记往哪个具名插槽中插入子组件内容。</span><br><span class="line"></span><br><span class="line">- **参考**：[具名插槽](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;components-slots.html#具名插槽)</span><br><span class="line"></span><br><span class="line">### [slot-scope 废弃](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#slot-scope-废弃)</span><br><span class="line"></span><br><span class="line">**推荐 2.6.0 新增的 [v-slot](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-slot)。**</span><br><span class="line"></span><br><span class="line">- **预期**：&#96;function argument expression&#96;</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  用于将元素或组件表示为作用域插槽。特性的值应该是可以出现在函数签名的参数位置的合法的 JavaScript 表达式。这意味着在支持的环境中，你还可以在表达式中使用 ES2015 解构。它在 2.5.0+ 中替代了 [&#96;scope&#96;](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#scope-replaced)。</span><br><span class="line"></span><br><span class="line">  此属性不支持动态绑定。</span><br><span class="line"></span><br><span class="line">- **参考**：[作用域插槽](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;components-slots.html#作用域插槽)</span><br><span class="line"></span><br><span class="line">### [scope 移除](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#scope-移除)</span><br><span class="line"></span><br><span class="line">**被 2.5.0 新增的 [slot-scope](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#slot-scope) 取代。推荐 2.6.0 新增的 [v-slot](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#v-slot)。**</span><br><span class="line"></span><br><span class="line">用于表示一个作为带作用域的插槽的 &#96; 元素，它在 2.5.0+ 中被 [&#96;slot-scope&#96;](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#slot-scope) 替代。</span><br><span class="line"></span><br><span class="line">- **用法：**</span><br><span class="line"></span><br><span class="line">  除了 &#96;scope&#96; 只可以用于 &#96; 元素，其它和 [&#96;slot-scope&#96;](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#slot-scope) 都相同。</span><br><span class="line"></span><br><span class="line">## [内置的组件](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#内置的组件)</span><br><span class="line"></span><br><span class="line">### [component](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#component)</span><br><span class="line"></span><br><span class="line">- **Props**：</span><br><span class="line"></span><br><span class="line">  - &#96;is&#96; - string | ComponentDefinition | ComponentConstructor</span><br><span class="line">  - &#96;inline-template&#96; - boolean</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  渲染一个“元组件”为动态组件。依 &#96;is&#96; 的值，来决定哪个组件被渲染。</span><br></pre></td></tr></table></figure><component :is="componentId"></component><p><component :is="$options.components.child"></component></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **参考**：[动态组件](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;components.html#动态组件)</span><br><span class="line"></span><br><span class="line">### [transition](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#transition)</span><br><span class="line"></span><br><span class="line">- **Props**：</span><br><span class="line"></span><br><span class="line">  - &#96;name&#96; - string，用于自动生成 CSS 过渡类名。例如：&#96;name: &#39;fade&#39;&#96; 将自动拓展为&#96;.fade-enter&#96;，&#96;.fade-enter-active&#96;等。默认类名为 &#96;&quot;v&quot;&#96;</span><br><span class="line">  - &#96;appear&#96; - boolean，是否在初始渲染时使用过渡。默认为 &#96;false&#96;。</span><br><span class="line">  - &#96;css&#96; - boolean，是否使用 CSS 过渡类。默认为 &#96;true&#96;。如果设置为 &#96;false&#96;，将只通过组件事件触发注册的 JavaScript 钩子。</span><br><span class="line">  - &#96;type&#96; - string，指定过渡事件类型，侦听过渡何时结束。有效值为 &#96;&quot;transition&quot;&#96; 和 &#96;&quot;animation&quot;&#96;。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。</span><br><span class="line">  - &#96;mode&#96; - string，控制离开&#x2F;进入的过渡时间序列。有效的模式有 &#96;&quot;out-in&quot;&#96; 和 &#96;&quot;in-out&quot;&#96;；默认同时生效。</span><br><span class="line">  - &#96;duration&#96; - number | &#123; &#96;enter&#96;: number, &#96;leave&#96;: number &#125; 指定过渡的持续时间。默认情况下，Vue 会等待过渡所在根元素的第一个 &#96;transitionend&#96; 或 &#96;animationend&#96; 事件。</span><br><span class="line">  - &#96;enter-class&#96; - string</span><br><span class="line">  - &#96;leave-class&#96; - string</span><br><span class="line">  - &#96;appear-class&#96; - string</span><br><span class="line">  - &#96;enter-to-class&#96; - string</span><br><span class="line">  - &#96;leave-to-class&#96; - string</span><br><span class="line">  - &#96;appear-to-class&#96; - string</span><br><span class="line">  - &#96;enter-active-class&#96; - string</span><br><span class="line">  - &#96;leave-active-class&#96; - string</span><br><span class="line">  - &#96;appear-active-class&#96; - string</span><br><span class="line"></span><br><span class="line">- **事件**：</span><br><span class="line"></span><br><span class="line">  - &#96;before-enter&#96;</span><br><span class="line">  - &#96;before-leave&#96;</span><br><span class="line">  - &#96;before-appear&#96;</span><br><span class="line">  - &#96;enter&#96;</span><br><span class="line">  - &#96;leave&#96;</span><br><span class="line">  - &#96;appear&#96;</span><br><span class="line">  - &#96;after-enter&#96;</span><br><span class="line">  - &#96;after-leave&#96;</span><br><span class="line">  - &#96;after-appear&#96;</span><br><span class="line">  - &#96;enter-cancelled&#96;</span><br><span class="line">  - &#96;leave-cancelled&#96; (&#96;v-show&#96; only)</span><br><span class="line">  - &#96;appear-cancelled&#96;</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  &#96;&#96; 元素作为单个元素&#x2F;组件的过渡效果。&#96;&#96; 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在检测过的组件层级中。</span><br></pre></td></tr></table></figure><transition><br><div v-if="ok">toggled content</div><br></transition><transition name="fade" mode="out-in" appear><br><component :is="view"></component><br></transition><p></p><div id="transition-demo"><br><transition @after-enter="transitionComplete"><p></p><pre><code>&lt;div v-show=&quot;ok&quot;&gt;toggled content&lt;/div&gt;
</code></pre><p></p></transition><br></div><p></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>new Vue({<br>…<br>methods: {</p><pre><code>transitionComplete: function (el) {
  // 传入 &apos;el&apos; 这个 DOM 元素作为参数。
}
</code></pre><p>}<br>…<br>}).$mount(‘#transition-demo’)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **参考**：[过渡：进入，离开和列表](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;transitions.html)</span><br><span class="line"></span><br><span class="line">### [transition-group](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#transition-group)</span><br><span class="line"></span><br><span class="line">- **Props**：</span><br><span class="line"></span><br><span class="line">  - &#96;tag&#96; - string，默认为 &#96;span&#96;</span><br><span class="line">  - &#96;move-class&#96; - 覆盖移动过渡期间应用的 CSS 类。</span><br><span class="line">  - 除了 &#96;mode&#96;，其他特性和 &#96;&#96; 相同。</span><br><span class="line"></span><br><span class="line">- **事件**：</span><br><span class="line"></span><br><span class="line">  - 事件和 &#96;&#96; 相同。</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  &#96;&#96; 元素作为多个元素&#x2F;组件的过渡效果。&#96;&#96; 渲染一个真实的 DOM 元素。默认渲染 &#96;&#96;，可以通过 &#96;tag&#96; 属性配置哪个元素应该被渲染。</span><br><span class="line"></span><br><span class="line">  注意，每个 &#96;&#96; 的子节点必须有 **独立的 key** ，动画才能正常工作</span><br><span class="line"></span><br><span class="line">  &#96;&#96; 支持通过 CSS transform 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它将会获取应用 CSS 移动类 (通过 &#96;name&#96; 属性或配置 &#96;move-class&#96; 属性自动生成)。如果 CSS &#96;transform&#96; 属性是“可过渡”属性，当应用移动类时，将会使用 [FLIP 技术](https:&#x2F;&#x2F;aerotwist.com&#x2F;blog&#x2F;flip-your-animations&#x2F;) 使元素流畅地到达动画终点。</span><br></pre></td></tr></table></figure><p><transition-group tag="ul" name="slide"><br><li v-for="item in items" :key="item.id"></li></transition-group></p><pre><code>{{ item.text }}
</code></pre><p></p></div></li><br><p></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **参考**：[过渡：进入，离开和列表](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;transitions.html)</span><br><span class="line"></span><br><span class="line">### [keep-alive](https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#keep-alive)</span><br><span class="line"></span><br><span class="line">- **Props**：</span><br><span class="line"></span><br><span class="line">  - &#96;include&#96; - 字符串或正则表达式。只有名称匹配的组件会被缓存。</span><br><span class="line">  - &#96;exclude&#96; - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</span><br><span class="line">  - &#96;max&#96; - 数字。最多可以缓存多少组件实例。</span><br><span class="line"></span><br><span class="line">- **用法**：</span><br><span class="line"></span><br><span class="line">  &#96;&#96; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 &#96;&#96; 相似，&#96;&#96; 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</span><br><span class="line"></span><br><span class="line">  当组件在 &#96;&#96; 内被切换，它的 &#96;activated&#96; 和 &#96;deactivated&#96; 这两个生命周期钩子函数将会被对应执行。</span><br><span class="line"></span><br><span class="line">  &gt; 在 2.2.0 及其更高版本中，&#96;activated&#96; 和 &#96;deactivated&#96; 将会在 &#96;&#96; 树内的所有嵌套组件中触发。</span><br><span class="line"></span><br><span class="line">  主要用于保留组件状态或避免重新渲染。</span><br></pre></td></tr></table></figure><p><keep-alive><br><component :is="view"></component><br></keep-alive></p><p><keep-alive><br><comp-a v-if="a > 1"></comp-a><br><comp-b v-else></comp-b><br></keep-alive></p><p><transition><br><keep-alive></keep-alive></transition></p><pre><code>&lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
</code></pre><p><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  注意，&#96;&#96; 是用在其一个直属的子组件被开关的情形。如果你在其中有 &#96;v-for&#96; 则不会工作。如果有上述的多个条件性的子元素，&#96;&#96; 要求同时只有一个子元素被渲染。</span><br><span class="line"></span><br><span class="line">- **&#96;include&#96; and &#96;exclude&#96;**</span><br><span class="line"></span><br><span class="line">  &gt; 2.1.0 新增</span><br><span class="line"></span><br><span class="line">  &#96;include&#96; 和 &#96;exclude&#96; 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：</span><br></pre></td></tr></table></figure><p><keep-alive include="a,b"><br><component :is="view"></component><br></keep-alive></p><p><keep-alive :include="/a|b/"><br><component :is="view"></component><br></keep-alive></p><p><keep-alive :include="['a', 'b']"><br><component :is="view"></component><br></keep-alive></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  匹配首先检查组件自身的 &#96;name&#96; 选项，如果 &#96;name&#96; 选项不可用，则匹配它的局部注册名称 (父组件 &#96;components&#96; 选项的键值)。匿名组件不能被匹配。</span><br><span class="line"></span><br><span class="line">- **&#96;max&#96;**</span><br><span class="line"></span><br><span class="line">  &gt; 2.5.0 新增</span><br><span class="line"></span><br><span class="line">  最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。</span><br></pre></td></tr></table></figure><p><keep-alive :max="10"><br><component :is="view"></component><br></keep-alive><br><code>`</code></p><p><code></code> 不会在函数式组件中正常工作，因为它们没有缓存实例。</p><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#在动态组件上使用-keep-alive" target="_blank" rel="noopener">动态组件 - keep-alive</a></p></li></ul><h3 id="slot"><a href="#slot" class="headerlink" title="slot"></a><a href="https://cn.vuejs.org/v2/api/#slot" target="_blank" rel="noopener">slot</a></h3><ul><li><p><strong>Props</strong>：</p><ul><li><code>name</code> - string，用于命名插槽。</li></ul></li><li><p><strong>Usage</strong>：</p><p><code>元素作为组件模板之中的内容分发插槽。</code> 元素自身将被替换。</p><p>详细用法，请参考下面教程的链接。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/components.html#通过插槽分发内容" target="_blank" rel="noopener">通过插槽分发内容</a></p></li></ul><h2 id="VNode-接口"><a href="#VNode-接口" class="headerlink" title="VNode 接口"></a><a href="https://cn.vuejs.org/v2/api/#VNode-接口" target="_blank" rel="noopener">VNode 接口</a></h2><ul><li>请参考 <a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js" target="_blank" rel="noopener">VNode class declaration</a>。</li></ul><h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a><a href="https://cn.vuejs.org/v2/api/#服务端渲染" target="_blank" rel="noopener">服务端渲染</a></h2><ul><li>请参考 <a href="https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer" target="_blank" rel="noopener">vue-server-renderer package documentation</a>。</li></ul><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
