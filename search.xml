<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络安全术语]]></title>
    <url>%2F2021%2F04%2F16%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%9C%AF%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[肉鸡：所谓“肉鸡”是一种很形象的比喻，比喻那些可以随意被我们控制的电脑，对方可以是 WINDOWS 系统，也可以是 UNIX/LINUX 系统，可以是普通的个人电脑，也可以是大型的服务器，我们可以象操作自己的电脑那样来操作它们，而不被对方所发觉。2.木马：就是那些表面上伪装成了正常的程序，但是当这些被程序运行时，就会获取系统的整个控制权限。有很多黑客就是热中与使用木马程序来控制别人的电脑，比如灰鸽子，黑洞，PcShare 等等。3.网页木马：表面上伪装成普通的网页文件或是将而已的代码直接插入到正常的网页文件中，当有人访问时，网页木马就会利用对方系统或者浏览器的漏洞自动将配置好的木马的服务端下载到访问者的电脑上来自动执行。4.挂马：就是在别人的网站文件里面放入网页木马或者是将代码潜入到对方正常的网页文件里，以使浏览者中马。5.后门：这是一种形象的比喻，入侵者在利用某些方法成功的控制了目标主机后，可以在对方的系统中植入特定的程序，或者是修改某些设置。这些改动表面上是很难被察觉的，但是入侵者却可以使用相应的程序或者方法来轻易的与这台电脑建立连接，重新控制这台电脑，就好象是入侵者偷偷的配了一把主人房间的要是，可以随时进出而不被主人发现一样。 通常大多数的特洛伊木马（Trojan Horse）程序都可以被入侵者用语制作后门（BackDoor）6.rootkit：rootkit 是攻击者用来隐藏自己的行踪和保留 root（根权限，可以理解成 WINDOWS 下的 system 或者管理员权限）访问权限的工具。通常，攻击者通过远程攻击的方式获得 root 访问权限，或者是先使用密码猜解（破解）的方式获得对系统的普通访问权限，进入系统后，再通过，对方系统内存在的安全漏洞获得系统的 root 权限。然后，攻击者就会在对方的系统中安装 rootkit，以达到自己长久控制对方的目的，rootkit 与我们前边提到的木马和后门很类似，但远比它们要隐蔽，黑客守卫者就是很典型的 rootkit，还有国内的 ntroorkit 等都是不错的 rootkit 工具。7.IPC$：是共享“命名管道”的资源，它是为了让进程间通信而开放的饿命名管道，可以通过验证用户名和密码获得相应的权限，在远程管理计算机和查看计算机的共享资源时使用。8.弱口令：指那些强度不够，容易被猜解的，类似 123，abc 这样的口令（密码）9.默认共享：默认共享是 WINDOWS2000/XP/2003 系统开启共享服务时自动开启所有硬盘的共享，因为加了”$”符号，所以看不到共享的托手图表，也成为隐藏共享。10.shell：指的是一种命令指行环境，比如我们按下键盘上的“开始键+R”时出现“运行”对话框，在里面输入“cmd”会出现一个用于执行命令的黑窗口，这个就是 WINDOWS 的 Shell 执行环境。通常我们使用远程溢出程序成功溢出远程电脑后得到的那个用于执行系统命令的环境就是对方的 shell11.WebShell：WebShell 就是以 asp、php、jsp 或者 cgi 等网页文件形式存在的一种命令执行环境，也可以将其称做是一种网页后门。黑客在入侵了一个网站后，通常会将这些 asp 或 php 后门文件与网站服务器 WEB 目录下正常的网页文件混在一起，好后就可以使用浏览器来访问这些 asp 或者 php 后门，得到一个命令执行环境，以达到控制网站服务器的目的。可以上传下载文件，查看数据库，执行任意程序命令等。国内常用的 WebShell 有海阳 ASP 木马，Phpspy，c99shell 等12.溢出：确切的讲，应该是“缓冲区溢出”。简单的解释就是程序对接受的输入数据没有执行有效的检测而导致错误，后果可能是造成程序崩溃或者是执行攻击者的命令。大致可以分为两类：（1）堆溢出；（2）栈溢出。13.注入：随着 B/S 模式应用开发的发展，使用这种模式编写程序的程序员越来越来越多，但是由于程序员的水平参差不齐相当大一部分应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想要知的数据，这个就是所谓的 SQLinjection，即：SQL 注入。14.注入点：是可以实行注入的地方，通常是一个访问数据库的连接。根据注入点数据库的运行帐号的权限的不同，你所得到的权限也不同。15.内网：通俗的讲就是局域网，比如网吧，校园网，公司内部网等都属于此类。查看 IP 地址如果是在以下三个范围之内的话，就说明我们是处于内网之中的：10.0.0.0—10.255.255.255，172.16.0.0—172.31.255.255，192.168.0.0—192.168.255.25516.外网：直接连入 INTERNET（互连网），可以与互连网上的任意一台电脑互相访问，IP 地址不是保留 IP（内网）IP 地址。17.端口：（Port）相当于一种数据的传输通道。用于接受某些数据，然后传输给相应的服务，而电脑将这些数据处理后，再将相应的恢复通过开启的端口传给对方。一般每一个端口的开放的偶对应了相应的服务，要关闭这些端口只需要将对应的服务关闭就可以了。18. 3389、4899 肉鸡：3389 是 Windows 终端服务（Terminal Services）所默认使用的端口号，该服务是微软为了方便网络管理员远程管理及维护服务器而推出的，网络管理员可以使用远程桌面连接到网络上任意一台开启了终端服务的计算机上，成功登陆后就会象操作自己的电脑一样来操作主机了。这和远程控制软件甚至是木马程序实现的功能很相似，终端服务的连接非常稳定，而且任何杀毒软件都不会查杀，所以也深受黑客喜爱。黑客在入侵了一台主机后，通常都会想办法先添加一个属于自己的后门帐号，然后再开启对方的终端服务，这样，自己就随时可以使用终端服务来控制对方了，这样的主机，通常就会被叫做 3389 肉鸡。Radmin 是一款非常优秀的远程控制软件，4899 就是 Radmin 默认使用也经常被黑客当作木马来使用（正是这个原因，目前的杀毒软件也对 Radmin 查杀了）。有的人在使用的服务端口号。因为 Radmin 的控制功能非常强大，传输速度也比大多数木马快，而且又不被杀毒软件所查杀，所用 Radmin 管理远程电脑时使用的是空口令或者是弱口令，黑客就可以使用一些软件扫描网络上存在 Radmin 空口令或者弱口令的主机，然后就可以登陆上去远程控制对恶劣，这样被控制的主机通常就被成做 4899 肉鸡。19.免杀：就是通过加壳、加密、修改特征码、加花指令等等技术来修改程序，使其逃过杀毒软件的查杀。20.加壳：就是利用特殊的算法，将 EXE 可执行程序或者 DLL 动态连接库文件的编码进行改变（比如实现压缩、加密），以达到缩小文件体积或者加密程序编码，甚至是躲过杀毒软件查杀的目的。目前较常用的壳有 UPX，ASPack、PePack、PECompact、UPack、免疫 007、木马彩衣等等。21.花指令：就是几句汇编指令，让汇编语句进行一些跳转，使得杀毒软件不能正常的判断病毒文件的构造。说通俗点就是”杀毒软件是从头到脚按顺序来查找病毒。如果我们把病毒的头和脚颠倒位置，杀毒软件就找不到病毒了。什么是 TCP/IP是一种网络通信协议，他规范了网络上所有的通信设备，尤其是一个主机与另一个主机之间的数据往来格式以及传送方式.，TCP/IP 是 INTERNET 的基础协议，也是一种电脑数据打包和寻址的标准方法.在数据传诵中，可以形象地理解为两个信封，TCP 和 IP 就像是信封，要传递的信息被划为若干段，每一段塞入一个 TCP 信封，并在该信封面上记录有分段号的信息，再将 TCP 信封塞入 IP 大信封，发送上网.什么是路由器路由器应该是在网络上使用最高的设备之一了，它的主要作用就是路由选路，将 IP 数据包正确的送到目的地，因此也叫 IP 路由器.什么是蜜罐好比是情报收集系统.蜜罐好象是故意让人攻击的目标，引诱黑客来攻击，所有攻击者入侵后，你就可以知道他是如何得逞的，随时了解针对你的服务器发动的最新的攻击和漏洞.还可以通过窃听黑客之间的联系，收集黑客所用的种种工具，并且掌握他们的社交网络.什么是拒绝服务攻击DOS 是 DENIALOFSERVICE 的简称，即拒绝服务，造成 DOS 的攻击行为被称为 DOS 攻击，其目的是使计算机或网络无法正常服务，最常见的 DOS 攻击有计算机网络宽带攻击和连通性攻击，连通性攻击指用大量的连接请求冲击计算机，使得所有可用的操作系统资源被消耗，最终计算机无法再处理合法用户的请求.什么是脚本注入攻击(SQLINJECTION)所谓脚本注入攻击者把 SQL 命令插入到 WEB 表单的输入域或也面请求的查学字符串，欺骗服务器执行恶意的 SQL 命令，在某些表单中，用户输入的内容直接用来构造动态的 SQL 命令，或作为存储过程的输入参数，这类表单特别容易受到 SQL 注入式攻击.什么是防火墙?它是如何确保网络安全的使用防火墙（Firewall）是一种确保网络安全的方法。防火墙是指设置在不同网络（如可信任的企业内部网和不可信的公共网）或网络安全域之间的一系列部件的组合。它是不同网络或网络安全域之间信息的惟一出入口，能根据企业的安全政策控制（允许、拒绝、监测）出入网络的信息流，且本身具有较强的抗攻击能力。它是提供信息安全服务，实现网络和信息安全的基础设施。什么是后门?为什么会存在后门？后门（BackDoor）是指一种绕过安全性控制而获取对程序或系统访问权的方法。在软件的开发阶段，程序员常会在软件内创建后门以便可以修改程序中的缺陷。如果后门被其他人知道，或是在软件之前没有删除，那么它就成了安全隐患。什么叫入侵检测入侵检测是防火墙的合理补充，帮助系统对付网络攻击，扩展系统管理员的安全管理能力（包括安全审计、监视、进攻识别和响应），提高信息安全基础结构的完整性。它从计算机网络系统中的若干关键点收集信息，并分析这些信息，检查网络中是否有违反安全策略的行为和遭到袭击的迹象什么叫数据包监测，它有什么作用数据包监测可以被认为是一根窃听电话线在计算机网络中的等价物。当某人在“监听”网络时，他们实际上是在阅读和解释网络上传送的数据包。如果你需要在互联网上通过计算机发送一封电子邮件或请求下载一个网页，这些操作都会使数据通过你和数据目的地之间的许多计算机。这些传输信息时经过的计算机都能够看到你发送的数据，而数据包监测工具就允许某人截获数据并且查看它。在这里值得一题的是，美国的落山基级骇动力潜艇就有几艘专们用于海底电缆的数据监听。特别是太平洋。什么是 NIDSNIDS 是 NetworkIntrusionDetectionSystem 的缩写，即网络入侵检测系统，主要用于检测 Hacker 或 Cracker通过网络进行的入侵行为。NIDS 的运行方式有两种，一种是在目标主机上运行以监测其本身的通信信息，另一种是在一台单独的机器上运行以监测所有网络设备的通信信息，比如 Hub、路由器。什么叫 SYN 包TCP 连接的第一个包，非常小的一种数据包。SYN 攻击包括大量此类的包，由于这些包看上去实际不存在的站点，因此无法有效进行处理。加密技术是指什么加密技术是最常用的安全保密手段，利用技术手段把重要的数据变为乱码（加密）传送，到达目的地后再用相同或不同的手段还原（解密）。加密技术包括两个元素：算法和密钥。算法是将普通的信息或者可以理解的信息与一串数字（密钥）结合，产生不可理解的密文的步骤，密钥是用来对数据进行编码和解密的一种算法。在安全保密中，可通过适当的钥加密技术和管理机制来保证网络的信息通信安全。局域网内部的 ARP 攻击是指什么ARP 协议的基本功能就是通过目标设备的 IP 地址，查询目标设备的 MAC 地址，以保证通信的进行。基于 ARP 协议的这一工作特性，黑客向对方计算机不断发送有欺诈性质的 ARP 数据包，数据包内包含有与当前设备重复的 Mac 地址，使对方在回应报文时，由于简单的地址重复错误而导致不能进行正常的网络通信。一般情况下，受到 ARP 攻击的计算机会出现两种现象:1.不断弹出“本机的 XXX 段硬件地址与网络中的 XXX 段地址冲突”的对话框。2.计算机不能正常上网，出现网络中断的症状。因为这种攻击是利用 ARP 请求报文进行“欺骗”的，所以防火墙会误以为是正常的请求数据包，不予拦截。因此普通的防火墙很难抵挡这种攻击。什么叫欺骗攻击?它有哪些攻击方式网络欺骗的技术主要有:HONEYPOT 和分布式 HONEYPOT、欺骗空间技术等。主要方式有:IP 欺骗、ARP 欺骗、DNS 欺骗、Web 欺骗、电子邮件欺骗、源路由欺骗（通过指定路由，以假冒身份与其他主机进行合法通信或发送假报文，使受攻击主机出现错误动作）、地址欺骗（包括伪造源地址和伪造中间站点）等。嗅探计算机网络的共享通讯道的，支持每对通讯计算机独占通道的交换机/集线器仍然过于昂贵，共享意为着计算机能够接收到发送给其他计算机的信息，捕获在网络中传输的数据信息就称为嗅探.木马全称为特洛伊木马(TrojanHorse)，是根据希腊神话传说中一次战争而得名。麦尼劳斯派兵讨伐特洛伊国王，他们假装打败，然后留下一个大木马，而木马里却藏着最强悍的勇士！最后等晚上时间一到，木马里的勇士就冲出来把敌人打败了。这就是后来的”木马计”，而黑客中的木马有点后门的意思，就是把预谋的功能隐藏在公开的功能里，掩饰真正的企图。肉鸡已经被攻击了，对其具有控制权的主机。跳板一个具有辅助作用的机器，利用这个主机作为一个间接工具，来入侵其他主机，一般和肉鸡连用。弱口令所谓弱口令也就是指密码与用户名相同，密码为空的用户名与密码组合，也包括那些密码强度不够，容易被猜解的组合，一般专业认识不会犯这种错误。权限计算机用户对于文件及目录的建立，修改，删除以及对于某些服务的访问，程序的执行，是以权限的形式来严格区分的.被赋予了相应的权限，就可以进行相应的操作，否则就不可以.溢出程序在处理我们提交给它的数据时，有的时候忘了检查数据的大小与合法性，那么这些数据可能会超过属于自己的地盘，覆盖到其它数据的盘.如果这些超长数据被精心的策划构造的话，可能会被黑客去执行任意命令.打个比喻来说，windows 系统是一个人，会一杯一杯喝我们给它准备的水，其中有一个杯子太小了，我们倒入了大量的水它就会溢出到别的杯子里去，而溢出到别的杯子里的东西我们事先可以设计好，而系统并不知道，这以为这本来就是那个杯子里的东西，于是我们可以完成一定的任务.端口要网络上，知道一台电脑的 ip 地址，只是相当于知道了它的居住地址，要和它进行通信，我们还要知道它开了哪些端口，比如说我们到一家医院，挂号要到 1 号窗口，划价要到 2 号窗口，取药要到 3 号窗口.那么与计算机的通信也是一样的，要上 qq，你得登陆到腾讯服务器的 8000 端口，要浏览 x 档案的论坛，你得与其 80 端口进行联系，要 ftp 登陆空间，传输文件，我们又得服务器的 21 端口连接了.可以说，端口就是一种数据的传输通道，用于接收某些数据，然后传给相应的服务，而电脑将这些数据处理后，再将相应的回复通过端口传给对方.ip 地址inter 上的电脑有许多，为了让他们能够相互识别，inter 上的每一台主机都分配有一个唯一的 32 位地址，该地址称为 ip 地址，也称作网际地址，ip 地址由 4 个数值部分组成，每个数值部分可取值 0-255，各部分之间用一个‘.‘分开.ARP地址解析协议(AddressResolutionProtocol)此协议将网络地址映射到硬件地址。RARP反向地址解析协议(ReverseAddressResolutionProtocol)此协议将硬件地址映射到网络地址UDP用户数据报协议(UserDatagramProtocol)这是提供给用户进程的无连接协议，用于传送数据而不执行正确性检查。FTP文件传输协议(FileTransferProtocol)允许用户以文件操作的方式（文件的增、删、改、查、传送等）与另一主机相互通信。SMTP简单邮件传送协议(SimpleMailTransferProtocol)SMTP 协议为系统之间传送电子邮件。TELNET终端协议(TelTerminalProcotol)允许用户以虚终端方式访问远程主机HTTP超文本传输协议(HypertextTransferProcotol)TFTP简单文件传输协议(TrivialFileTransferProtocol)ShellShell 就是系统于用户的交换式界面。简单来说，就是系统与用户的一个沟通环境，我们平时用到的 DOS 就是一个 Shell(Win2K 或 cmd.exe)。RootUnix 里最高权限的用户，也就是超级管理员。AdminWindowsNT/2K/XP 里最高权限的用户，也就是超级管理员。Rootshell通过一个溢出程序，在主机溢出一个具有 Root 权限的 Shell。Exploit溢出程序。Exploit 里通常包含一些 Shellcode。Shellcode溢出攻击要调用的函数，溢出后要一个交换式界面进行操作。所以说就有了 Shellcode。AccesControllist(ACL)访问控制列表。AddressResolutionProtocol(ARP)地址解析协议。Administratoraccount管理员帐号。ARPANET阿帕网(Inter 的简称)。accesstoken访问令牌。adaptivespeedleveling自适应速度等级调整。algorithm算法 alias 别名。anlpasswd一种与 PASSWD+相似的代理密码检查器。applicatlons应用程序异步传递模式。accoutlockout帐号封锁。accoutpolicies记帐策略。accounts帐号。adapter适配器。上传漏洞这个漏洞在 DVBBS6.0 时代被黑客们利用的最为猖獗，利用上传漏洞可以直接得到 WEBSHELL，危害等级超级高，现在的入侵中上传漏洞也是常见的漏洞。怎样利用：在网站的地址栏中网址后加上/upfile.asp 如果显示“上传格式不正确[重新上传]”这样的字样就是有上传漏洞了，找个可以上传的工具直接可以得到 WEBSHELL。**工具介绍：上传工具，老兵的上传工具、DOMAIN3.5，这两个软件都可以达到上传的目的，用 NC 也可以提交。WEBSHELL 是什么:其实 WEBSHELL 并不什么深奥的东西，是个 WEB 的权限，可以管理 WEB，修改主页内容等权限，但是并没有什么特别高的权限，(这个看管理员的设置了)一般修改别人主页大多都需要这个权限，接触过 WEB 木马的朋友可能知道（比如老兵的站长助手就是 WEB 木马，海阳 2006 也是 WEB 木马）。我们上传漏洞最终传的就是这个东西，有时碰到权限设置不好的服务器可以通过 WEBSHELL 得到最高权限。暴库这个漏洞现在很少见了，但是还有许多站点有这个漏洞可以利用，暴库就是提交字符得到数据库文件，得到了数据库文件我们就直接有了站点的前台或者后台的权限了。暴库方法： 比如一个站的地址为http://www.xxx.com/dispbbs.asp?boardID=7&amp;ID=161，我门就可以把com/dispbbs中间的/换成\，如果有漏洞直接得到数据库的绝对路径，用寻雷什么的下载下来就可以了。** 还有种方法就是利用默认的数据库路径http://www.xxx.com/后面加上conn.asp。如果没有修改默认的数据库路径也可以得到数据库的路径（注意：这里的/也要换成\）。** 为什么换成\：因为在 ASCII 码里/等于\，有时碰到数据库名字为/#abc.mdb 的为什么下不了?这里需要把#号换成#就可以下载了，为什么我暴出的数据库文件是以.ASP 结尾的?我该怎么办?这里可以在下载时把.ASP 换成.MDB 这样就可以下载了如果还下载不了可能作了防下载。注入漏洞这个漏洞是现在应用最广泛，杀伤力也很大的漏洞，可以说微软的官方网站也存在着注入漏洞。注入漏洞是因为字符过滤不严禁所造成的，可以得到管理员的帐号密码等相关资料。怎样利用：我先介绍下怎样找漏洞比如这个网址http://www.xxx.com/dispbbs.asp?boardID=7&amp;ID=161后面是以ID=数字形式结尾的站我们可以手动在后面加上个and1=1看看**如果显示正常页面再加上个and1=2来看看如果返回正常页面说明没有漏洞如果返回错误页面说明存在注入漏洞。如果加and1=1返回错误页面说明也没有漏洞，知道了站点有没有漏洞我们就可以利用手工来猜解也可以用工具现在工具比较多（NBSI、NDSI、啊D、DOMAIN等），都可以用来猜解帐号密码，因为是菜鸟接触，我还是建议大家用工具，手工比较烦琐。旁注我们入侵某站时可能这个站坚固的无懈可击，我们可以找下和这个站同一服务器的站点，然后在利用这个站点用提权，嗅探等方法来入侵我们要入侵的站点。**打个形象的比喻，比如你和我一个楼，我家很安全，而你家呢，却漏洞百出，现在有个贼想入侵我家，他对我家做了监视（也就是扫描），发现没有什么可以利用的东西，那么这个贼发现你家和我家一个楼，你家很容易就进去了，他可以先进入你家，然后通过你家得到整个楼的钥匙（系统权限），这样就自然得到我的钥匙了，就可以进入我的家（网站）。工具介绍：还是名小子的 DOMIAN3.5 不错的东西，可以检测注入，可以旁注，还可以上传!COOKIE 诈骗许多人不知道什么是 COOKIE，COOKIE 是你上网时由网站所为你发送的值记录了你的一些资料，比如 IP，姓名什么的。怎样诈骗呢？如果我们现在已经知道了 XX 站管理员的站号和 MD5 密码了，但是破解不出来密码（MD5 是加密后的一个 16 位的密码）。我们就可以用COOKIE 诈骗来实现，把自己的 ID 修改成管理员的，MD5 密码也修改成他的，有工具可以修改 COOKIE 这样就答到了 COOKIE 诈骗的目的，系统以为你就是管理员了。防火墙系统：IDS 入侵检测——现在一般有成品软件卖时间戳 “时间戳”是个听起来有些玄乎但实际上相当通俗易懂的名词，我们查看系统中的文件属性，其中显示的创建、修改、访问时间就是该文件的时间戳。 对于大多数一般用户而言，通过修改“时间戳”也许只是为了方便管理文件等原因而掩饰文件操作记录。但对于应用数字时间戳技术的用户就并非这么“简单”了，这里的“时间戳”（time-stamp）是一个经加密后形成的凭证文档，是数字签名技术的一种变种应用。* 在电子商务交易文件中，利用数字时间戳服务（DTS：digita1timestampservice）能够对提供电子文件的日期和时间信息进行安全保护，以防止被商业对手等有不良企图的人伪造和串改的关键性内容。MySQL 数据库 我们在黑客文章中常会看到针对“MySQL 数据库”的攻击，但很多朋友却对其不大了解。“MySQL 数据库”之所以应用范围如此广泛，是由于它是一款免费的开放源代码的多用户、多线程的跨平台关系型数据库系统，也可称得上是目前运行速度最快的 SQL 语言数据库。** “MySQL 数据库”提供了面向 C、C++、Java 等编程语言的编程接口，尤其是它与 PHP 的组合更是黄金搭档。“MySQL 数据库”采用的是客户机/服务器结构的形式，它由一个服务器守护程序 Mysqld 和很多不同的客户程序和库组成。但若是配置不当，“MySQL 数据库”就可能会受到攻击，例如若是设置本地用户拥有对库文件读权限，那么入侵者只要获取“MySQL 数据库”的目录，将其复制本机数据目录下就能访问进而窃取数据库内容。MD5 验证MD5（全称是 message-digestalgorithm5）的作用是让大容量信息在用数字签名软件签署私人密匙前被“压缩”为一种保密的格式。它的典型应用是对一段信息（message）产生信息摘要（message-digest），以防止被篡改。通俗地说 MD5 码就是个验证码，就像我们的个人身份证一样，每个人的都是不一样的。MD5 码是每个文件的唯一校验码（MD5 不区分大小写，但由于 MD5 码有 128 位之多，所以任意信息之间具有相同 MD5 码的可能性非常之低，通常被认为是不可能的），凭借此特性常被用于密码的加密存储、数字签名及文件完整性验证等功能。通过 MD5 验证即可检查文件的正确性，例如可以校验出下载文件中是否被捆绑有其它第三方软件或木马、后门（若是校验结果不正确就说明原文件已被人擅自串改）。ICMP 协议ICMP（全称是 InterControlMessageProtocol，即 Inter 控制消息协议）用于在 IP 主机、路由器之间传递控制消息，包括网络通不通、主机是否可达、路由是否可用等网络本身的消息。例如，我们在检测网络通不通时常会使用 Ping 命令，Ping 执行操作的过程就是 ICMP 协议工作的过程。“ICMP 协议”对于网络安全有着极其重要的意义，其本身的特性决定了它非常容易被用于攻击网络上的路由器和主机。例如，曾经轰动一时的海信主页被黑事件就是以 ICMP 攻击为主的。由于操作系统规定 ICMP 数据包最大尺寸不超过 64KB，因而如果向目标主机发送超过 64KB 上限的数据包，该主机就会出现内存分配错误，进而导致系统耗费大量的资源处理，疲于奔命，最终瘫痪、死机。WAP 攻击黑客们在网络上疯狂肆虐之后，又将“触角”伸向了 WAP（无线应用协议的英文简写），继而 WAP 成为了他们的又一个攻击目标。“WAP 攻击”主要是指攻击 WAP 服务器，使启用了 WAP 服务的手机无法接收正常信息。由于目前 WAP 无线网络的安全机制并非相当严密，因而这一领域将受到越来越多黑客的“染指”。现在，我们使用的手机绝大部分都已支持 WAP 上网，而手机的 WAP 功能则需要专门的 WAP 服务器来支持，若是黑客们发现了 WAP 服务器的安全漏洞，就可以编制出针对该 WAP 服务器的病毒，并对其进行攻击，从而影响到 WAP 服务器的正常工作，使 WAP 手机无法接收到正常的网络信息。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F11%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构栈先进后出(Last in First out) =&gt;有序集合新添加与待删除都是在栈尾，称作栈顶，另一端为栈底队列先进先出(First in First out) =&gt;有序项尾部添加新元素，头部移除元素，最新添加的元素必须排在队列的末尾链表有序的元素集合 =&gt; 不同于数组，元素在内存中不连续放置每个元素由一个元素本身节点和一个指向下一个元素的引用(指针 / 链接)组成集合由一组无序且唯一的项组成字典以【键，值】对为数据形态的数据结构 =&gt; 键名用来查询特定元素散列根据关键码值 ( Key Value ) 直接进行访问通过把关键码值映射到表中的一个位置来访问记录，以加快查找速度映射函数叫做散列函数，存放记录的数组叫做散列数组树由 n ( n &gt; = 1 ) 个有限节点组成的一个具有层次关系的集合，呈一对多关系根节点至少有两个儿子公式第 n 层的节点数最多为$$2^n$$个节点n 层二叉树最多有$$2^0+…+2^n=2^{n+1}$$个节点第一个非叶子节点：length / 2一个节点的孩子节点：2n、2n+1基本结构插入、遍历、深度12345678910111213function Node(data,left,right)&#123; this.data = data this.left = left this.right = right&#125;Node.prototype = &#123; show: function()&#123; console.log(this.data); &#125;&#125;function Tree遍历中序遍历： 左侧子节点 =&gt; 节点本身 =&gt; 右侧子节点先序遍历： 节点本身 =&gt; 左侧子节点 =&gt; 右侧子节点后序遍历： 左侧子节点 =&gt; 节点本身 =&gt; 右侧子节点图网络结构的抽象模型图是一组由边连接的节点任何二元关系都可以用图来表示，呈多对多关系算法排序算法冒泡排序： O(n²)比较任何两个相邻的项，如果第一个比第二个大，则交换它们；元素项向上移动至正确的顺序，好似气泡上升至表面一般，因此得名选择排序每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，以此循环，直至排序完毕插入排序：O(n²)将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，此算法适用于少量数据的排序，时间复杂度为 O(n^2)归并排序将原始序列切分成较小的序列，只到每个小序列无法再切分，然后执行合并，即将小序列归并成大的序列，合并过程进行比较排序，只到最后只有一个排序完毕的大序列，时间复杂度为 O(n log n)快速排序: O(nlog^n)通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行上述递归排序，以此达到整个数据变成有序序列，时间复杂度为 O(n log n)搜索算法顺序算法让目标元素与列表中的每一个元素逐个比较，直到找出与给定元素相同的元素为止，缺点是效率低下二分搜索在一个有序列表，以中间值为基准拆分为两个子列表，拿目标元素与中间值作比较从而再在目标的子列表中递归此方法，直至找到目标元素其他斐波那契数列1和2的斐波那契数是1n(n &gt; 2) 的斐波那契数是 (n-1)的斐波那契数 + n(n-2)的斐波那契数贪心算法在对问题求解时，不考虑全局，总是做出局部最优解的方法动态规划在对问题求解时，由以求出的局部最优解来推导全局最优解复杂度概念算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述时间复杂度大O符号表示法T(n) = O(f(n))： 算法的渐进时间复杂度f(n) 表示每行代码执行次数之和O 表示正比例关系1234for(i=1;i&lt;=n;++i)&#123; j =i; j++;&#125;时间复杂度为O(n)常见的时间复杂度量级从上至下依次的时间复杂度越来越大，执行的效率越来越低常数阶O(1)对数阶O(logN)线性阶O(n)线性对数阶O(nlogN)平方阶O(n²)立方阶O(n³)K次方阶O(n^k)【n的k次方，符号不会敲】指数阶(2^n)常用的时间复杂度量级常数阶O(1)无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)12345int i = 1;int j = 2;++i;j++;int m = i + j;线性阶O(n)for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度12345for(i=1; i&lt;=n; ++i)&#123; j = i; j++;&#125;对数阶O(logN)普通应用都是10，计算机学科是2，编程语言里面是e常用编程语言中Math.log一般都是以E为底（MATLAB里面是以e为底的）ln是以e为底数，lg是以10为底数此处log底数为212345int i = 1;while(i&lt;n)&#123; i = i * 2;&#125;在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n【这里是log 2的n次方，符号不会敲】也就是说当循环 log2n【这里是log 2的n次方，符号不会敲】 次以后，这个代码就结束了线性对数阶O(nlogN)线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)12345678for(m=1; m&lt;n; m++)&#123; i = 1; while(i&lt;n) &#123; i = i * 2; &#125;&#125;平方阶O(n²)O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)12345678for(x=1; i&lt;=n; x++)&#123; for(i=1; i&lt;=n; i++) &#123; j = i; j++; &#125;&#125;O(n²)将其中一层循环的n改成m12345678for(x=1; i&lt;=m; x++)&#123; for(i=1; i&lt;=n; i++) &#123; j = i; j++; &#125;&#125;O(m*n)空间复杂度空间复杂度 O(1)12345int i = 1;int j = 2;++i;j++;int m = i + j;空间复杂度 O(n)123456int[] m = new int[n]for(i=1; i&lt;=n; ++i)&#123; j = i; j++;&#125;###]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端基础]]></title>
    <url>%2F2019%2F10%2F25%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTML 篇图片中 title 和 alt 区别？通常当鼠标滑动到元素上的时候显示alt是的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。Html5 有哪些新特性、移除了哪些元素新增元素：* 绘画`canvas` * 用于媒介回放的`video 和 audio`元素 * 本地离线存储`localStorage`长期存储数据，浏览器关闭后数据不丢失 * `sessionStorage`的数据在浏览器关闭后自动删除 * 语义化更好的内容元素，比如`article 、footer、header、nav、section` * 表单控件 ，`calendar 、 date 、 time 、 email 、 url 、 search` * 新的技术`webworker 、 websocket 、 Geolocation` 移除的元素：纯表现的元素：basefont 、 big 、 center 、 font 、 s 、 strike 、 tt 、 u对可用性产生负面影响的元素：frame 、 frameset 、 noframes支持 HTML5 新标签：IE8/IE7/IE6支持通过document.createElement方法产生的标签可以利用这一特性让这些浏览器支持HTML5新标签浏览器支持新标签后，还需要添加标签默认的样式-浏览器是怎么对 Html5 的离线储存资源进行管理和加载的呢如何使用：页面头部像下面一样加入一个manifest的属性；在cache.manifest文件的编写离线存储的资源在离线状态时，操作window.applicationCache进行需求实现在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。iframe 有那些缺点？iframe会阻塞主页面的Onload事件搜索引擎的检索程序无法解读这种页面，不利于 SEOiframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题HTML W3C 的标准标签闭合、标签小写、不乱嵌套、使用外链 css 和 js 、结构行为表现的分离Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?&lt;!DOCTYPE&gt;声明位于文档中的最前面，处于html标签之前。告知浏览器的解析器， 用什么文档类型、规范来解析这个文档严格模式的排版和JS运作模式是 以该浏览器支持的最高标准运行在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现HTML 全局属性(global attribute)有哪些class:为元素设置类标识data-*: 为元素增加自定义属性draggable: 设置元素是否可拖拽id: 元素 id ，文档内唯一lang: 元素内容的的语言style: 行内 css 样式title: 元素相关的建议信息viewport 的 content 属性作用123456789101112131415&lt;meta name=&quot;viewport&quot; content=&quot;&quot; /&gt; width viewport的宽度[device-width | pixel_value]width如果直接设置pixel_value数值，大部分的安卓手机不支持，但是ios支持； height – viewport 的高度 （范围从 223 到 10,000 ） user-scalable [yes | no]是否允许缩放 initial-scale [数值] 初始化比例（范围从 &gt; 0 到 10） minimum-scale [数值] 允许缩放的最小比例 maximum-scale [数值] 允许缩放的最大比例 target-densitydpi 值有以下（一般推荐设置中等响度密度或者低像素密度，后者设置具体的值dpi_value，另外webkit内核已不准备再支持此属性） -- dpi_value 一般是70-400//没英寸像素点的个数 -- device-dpi设备默认像素密度 -- high-dpi 高像素密度 -- medium-dpi 中等像素密度 -- low-dpi 低像素密度复制代码附带问题：怎样处理 移动端 1px 被 渲染成 2px 问题?局部处理：mate标签中的viewport属性 ，initial-scale设置为 1rem按照设计稿标准走，外加利用transfrome 的 scale(0.5)缩小一倍即可；全局处理：mate标签中的viewport属性 ，initial-scale设置为 0.5rem按照设计稿标准走即可meta 相关123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt; &lt;!--H5标准声明，使用 HTML5 doctype，不区分大小写--&gt;&lt;head lang=”en”&gt; &lt;!--标准的 lang 属性写法--&gt;&lt;meta charset=’utf-8′&gt; &lt;!--声明文档使用的字符编码--&gt;&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt; &lt;!--优先使用指定浏览器使用特定的文档模式--&gt;&lt;meta name=”description” content=”不超过150个字符”/&gt; &lt;!--页面描述--&gt;&lt;meta name=”keywords” content=””/&gt; &lt;!-- 页面关键词--&gt;&lt;meta name=”author” content=”name, email@gmail.com”/&gt; &lt;!--网页作者--&gt;&lt;meta name=”robots” content=”index,follow”/&gt; &lt;!--搜索引擎抓取--&gt;&lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-sc&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt; &lt;!--iOS 设备 begin--&gt;&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt; &lt;!--添加到主屏后的标是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏--&gt;&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;&lt;meta name=”renderer” content=”webkit”&gt; &lt;!-- 启用360浏览器的极速模式(webkit)--&gt;&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt; &lt;!--避免IE使用兼容模式--&gt;&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt; &lt;!--不让百度转码--&gt;&lt;meta name=”HandheldFriendly” content=”true”&gt; &lt;!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器--&gt;&lt;meta name=”MobileOptimized” content=”320″&gt; &lt;!--微软的老式浏览器--&gt;&lt;meta name=”screen-orientation” content=”portrait”&gt; &lt;!--uc强制竖屏--&gt;&lt;meta name=”x5-orientation” content=”portrait”&gt; &lt;!--QQ强制竖屏--&gt;&lt;meta name=”full-screen” content=”yes”&gt; &lt;!--UC强制全屏--&gt;&lt;meta name=”x5-fullscreen” content=”true”&gt; &lt;!--QQ强制全屏--&gt;&lt;meta name=”browsermode” content=”application”&gt; &lt;!--UC应用模式--&gt;&lt;meta name=”x5-page-mode” content=”app”&gt; &lt;!-- QQ应用模式--&gt;&lt;meta name=”msapplication-tap-highlight” content=”no”&gt; &lt;!--windows phone设置页面不缓存--&gt;&lt;meta http-equiv=”pragma” content=”no-cache”&gt;&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;&lt;meta http-equiv=”expires” content=”0″&gt;复制代码了解更多参考：https://blog.csdn.net/kongjiea/article/details/17092413div+css 的布局较 table 布局有什么优点改版的时候更方便 只要改css文件。页面加载速度更快、结构化清晰、页面显示简洁。表现与结构相分离。易于优化（ seo ）搜索引擎更友好，排名更容易靠前。src 与 href 的区别src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部-href 是 Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加 -link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式CSS 篇link 与 @import 的区别link是HTML方式，@import是CSS方式link最大限度支持并行下载，@import过多嵌套导致串行下载，出现 FOUC (文档样式短暂失效)link可以通过rel=&quot;alternate stylesheet&quot;指定候选样式浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式@import必须在样式规则之前，可以在css文件中引用其他文件总体来说：link优于@import，link优先级也更高BFC 有什么用创建规则：* 根元素 * 浮动元素（`float`不取值为`none`） * 绝对定位元素（`position`取值为`absolute`或`fixed`） * `display`取值为`inline-block 、 table-cell 、 table-caption 、 flex 、inline-flex`之一的元素 * `overflow`不取值为`visible`的元素 作用可以包含浮动元素不被浮动元素覆盖阻止父子元素的margin折叠-清除浮动的几种方式父级div定义height结尾处加空div标签clear:both父级div定义伪类:after和zoom父级div定义overflow:hidden父级div也浮动，需要定义宽度结尾处加br标签clear:bothCss3 新增伪类 - 伪元素p:first-of-type选择属于其父元素的首个元素的每个元素。p:last-of-type选择属于其父元素的最后元素的每个元素。p:only-of-type选择属于其父元素唯一的元素的每个元素。p:only-child选择属于其父元素的唯一子元素的每个元素。p:nth-child(2)选择属于其父元素的第二个子元素的每个元素。:enabled已启用的表单元素。:disabled已禁用的表单元素。:checked单选框或复选框被选中。::before在元素之前添加内容。::after在元素之后添加内容,也可以用来做清除浮动。::first-line添加一个特殊的样式到文本的首字母。::first-letter添加一行特殊样式到首行。相信大家也看出来他们的不同，伪类语法一个：，它是为了弥补 css 常规类选择器的不足伪元素语法两个：，它是凭空创建的一个虚拟容器生成的元素IE 盒子模型 、W3C 盒子模型W3C 盒模型： 内容(content)、填充( padding )、边界( margin )、 边框( border )；* `box-sizing: content-box` * width = content width; IE 盒子模型： IE 的 content 部分把 border 和 padding 计算了进去;box-sizing: border-boxwidth = border + padding + content width-display:inline-block 什么时候不会显示间隙？移除空格使用margin负值使用font-size:0letter-spacingword-spacing行内元素 float:left 后是否变为块级元素？行内元素设置成浮动之后变得更加像是inline-block（行内块级元素，设置 成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是 100% ），这时候给行内元素设置padding-top和padding-bottom或者width 、 height都是有效果的如果需要手动写动画，你认为最小时间间隔是多久，为什么？多数显示器默认频率是 60Hz ，即 1 秒刷新 60 次，所以理论上最小间隔为 1/60*1000ms ＝ 16.7msCSS 不同选择器的权重(CSS 层叠的规则)！important规则最重要，大于其它规则行内样式规则，加 1000对于选择器中给定的各个 ID 属性值，加 100对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加 10对于选择其中给定的各个元素标签选择器，加 1如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则stylus/sass/less 区别均具有“变量”、“混合”、“嵌套”、“继承”、“颜色混合”五大基本特性Sass和LESS语法较为严谨，LESS要求一定要使用大括号“{}”，Sass和Stylus可以通过缩进表示层次与嵌套关系Sass无全局变量的概念，LESS和Stylus有类似于其它语言的作用域概念Sass是基于Ruby语言的，而LESS和Stylus可以基于NodeJS NPM下载相应库后进行编译；这也是为什么安装 Sass 的时候有时候会报错，需要安装 python 脚本优点：就不用我多说了，谁用谁知道，真香。rgba()和 opacity 的透明效果有什么不同？rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，而rgba()只作用于元素的颜色或其背景色。（设置 rgba 透明的元素的子元素不会继承透明效果！）水平居中的方法元素为行内元素，设置父元素text-align:center如果元素宽度固定，可以设置左右margin 为 auto;如果元素为绝对定位，设置父元素position 为 relative，元素设left:0;right:0;margin:auto;使用flex-box布局，指定justify-content属性为centerdisplay设置为tabel-ceil垂直居中的方法将显示方式设置为表格，display:table-cell,同时设置vertial-align：middle使用flex布局，设置为align-item：center绝对定位中设置bottom:0,top:0,并设置margin:auto绝对定位中固定高度时设置top:50%，margin-top值为高度一半的负值文本垂直居中设置line-height为height值浏览器 篇浏览器内核的理解主要分两个部分：渲染引擎、js引擎渲染引擎：负责取得网页的内容（html css img …），以及计算网页的显示方式，然后会输出至显示器或者打印机。浏览器的内核不同对于网页的语法解释也不同，所以渲染的效果也不一样js引擎：解析和执行 javascript 来实现网页的动态效果最开始渲染引擎和 js 引擎并没有区分的很明确，后来 js 引擎越来越独立，内核就倾向于只值渲染引擎IE : trident内核Firefox ： gecko内核Safari : webkit内核Opera:以前是presto内核，Opera现已改用Google - Chrome的Blink内核Chrome:Blink(基于webkit，Google与Opera Software共同开发)HTTP 请求+作用？Get方法：发送一个请求来获取服务器资源POST方法：向服务器提交数据PUT方法：与POST方法很像，也是提交数据，但PUT制定了资源在服务器上的位置，常用在修改数据HEAD方法：只请求页面的首部信息DELETE方法：删除服务器上的资源OPTIONS方法：用于获取当前URL支持的请求方式TRACE方法：用于激活一个远程的应用层请求消息回路CONNECT方法：把请求链接转换到透明的TCP/IP的通道HTTP 状态码1XX：信息状态码* `100 continue`继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息 2XX：成功状态码200 ok正常返回信息201 created请求成功并且服务器创建了新资源202 accepted服务器已经接收请求，但尚未处理3XX：重定向301 move per请求的网页已经永久重定向302 found临时重定向303 see other临时冲重定向，且总是使用 get 请求新的 url304 not modified自从上次请求后，请求的网页未修改过4XX：客户端错误400 bad request服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求401 unauthorized请求未授权403 forbidden禁止访问404 not found找不到如何与 url 匹配的资源5XX：服务器错误* `500 internal server error`最常见的服务器端的错误 * `503 service unacailable`服务器端暂时无法处理请求（可能是过载活维护） -从浏览器地址栏输入 URL 后发生了什么？基础版本1.的浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；2.服务器交给后台处理完成后返回数据，浏览器接收文件（ HTML、JS、CSS 、图象等）；3.浏览器对加载到的资源（ HTML、JS、CSS 等）进行语法解析，建立相应的内部数据结构（如 HTML 的 DOM ）；4.载入解析到的资源文件，渲染页面，完成。详细版1.从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）2.开启网络线程到发出一个完整的HTTP请求（这一部分涉及到 dns 查询，TCP/IP请求，五层因特网协议栈等知识）3.从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）4.后台和前台的HTTP交互（这一部分包括HTTP头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）5.单独拎出来的缓存问题，HTTP的缓存（这部分包括http缓存头部，ETag ， catchcontrol等）6.浏览器接收到HTTP数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout 、 painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded 和 DOMContentLoaded等）7.CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC， IFC 等概念）8.JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）9.其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）详细升级版1.在浏览器地址栏输入URL2.浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤* 2.1 如果资源未缓存，发起新请求 * 2.2 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 2.3 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control： * 2.3.1`HTTP1.0`提供`Expires`，值为一个绝对时间表示缓存新鲜日期 * 2.3.2`HTTP1.1`增加了`Cache-Control: max-age=`,值为以秒为单位的最大新鲜时间 * * 3.浏览器解析URL获取协议，主机，端口，path4.浏览器组装一个HTTP（GET）请求报文5.浏览器获取主机ip地址，过程如下：* 5.1 浏览器缓存 * 5.2 本机缓存 * 5.3 hosts文件 * 5.4 路由器缓存 * 5.5 ISP DNS缓存 * 5.6 DNS递归查询（可能存在负载均衡导致每次IP不一致） 6.打开一个socket与目标IP地址，端口建立 TCP 链接，三次握手如下：6.1 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口6.2 服务器发回SYN=1，ACK=x+1,Seq=Y的相应包6.3 客户端发送ACK=Y+1，Seq=z7.TCP链接建立后发送HTTP请求8.服务器接收请求后解析，将请求转发到服务器程序，如虚拟主机使用HTTP Host头部判断请求的服务程序9.服务器检测HTTP请求头是否包含缓存验证信息，如果验证缓存新鲜，返回 304 等对应状态10.出合理程序读取完整请求并准备HTTP相应，可能需要查询数据库等操作11.服务器将相应报文通过TCP链接发送回浏览器12.浏览器接收HTTP相应，然后根据情况选择关闭TCP链接或者保留重用，关闭 TCP 链接的四次握手如下：* 12.1 主动方发送`Fin=1,ACK=z,Seq=x`报文 * 12.2 被动方发送`ACK=X+1,Seq=Y`报文 * 12.3 被动方发送`Fin=1,ACK=X,Seq=Y`报文 * 12.4 主动方发送`ACK=Y,Seq=x`报文 13.浏览器检查相应状态码14.如果资源可缓存，进行缓存15.对相应进行解码16.根据资源类型决定如何处理17.解析HTML文档，构建DOM树，下载资源，构建CSSOM树，执行 js 脚本，这些操作每月严格的先后顺序18.构建 DOM 树：* 18.1 Tokenizing：根据HTML规范将字符流解析为标记 * 18.2 Lexing：词法分析将标记转换为对象并定义属性和规则 * 18.3 DOM construction：根据HTML标记关系将对象组成DOM树 19.解析过程中遇到图片、样式表、js 文件，启动下载20.构建CSSOM树：* 20.1`Tokenizing`：字符流转换为标记流 * 20.2`Node`：根据标记创建节点 * 20.3`CSSOM`：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树21.1 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script , meta这样本身不可见的标签。2)被 css 隐藏的节点，如 display: none21.2 对每一个可见节点，找到恰当的CSSOM规则并应用21.3 发布可视节点的内容和计算样式22.js 解析如下22.1 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading22.2 HTML 解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容22.3 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己 script 和之前的文档元素22.4 当文档完成解析，document.readState变成interactive22.5 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()22.6 浏览器在Document对象上触发DOMContentLoaded事件22.7 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete，window触发load事件23.显示页面（HTML 解析过程中会逐步显示页面）cookies ， sessionStorage 和 localStorage 的区别cookie是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）cookie数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递（优化点）sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存存储大小：* `cookie`数据大小不能超过4k * `sessionStorage 和 localStorage`虽然也有存储大小的限制，但比 cookie 大得多，可以达到5M或更大 有期时间：localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据sessionStorage数据在当前浏览器窗口关闭后自动删除cookie 设置的 cookie过期时间之前一直有效，即使窗口或浏览器关闭浏览器缓存浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下先根据这个资源的一些http header判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。当协商缓存也没命中时，服务器就会将资源发送回客户端。当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；当f5刷新网页时，跳过强缓存，但是会检查协商缓存；强缓存-协商缓存：这篇文章介绍挺细的：https://juejin.cn/post/6844903763665240072#heading-5JS 篇说几条写 JavaScript 的基本规范不要在同一行声明多个变量请是用 ===/!== 来比较true/false或者数值使用对象字面量替代new Array这种形式不要使用全局函数Switch语句必须带有default分支If语句必须使用大括号for-in循环中的变量 应该使用let关键字明确限定作用域，从而避免作用域污染绕不过去的闭包闭包就是能够读取其他函数内部变量的函数闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域闭包的特性：* 函数内再嵌套函数 * 内部函数可以引用外层的参数和变量 * 参数和变量不会被垃圾回收机制回收 优点：能够实现封装和缓存等缺点：消耗内存、使用不当会内存溢出，解决方法：在退出函数之前，将不使用的局部变量全部删除说说你对作用域链的理解作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期JavaScript 原型，原型链 ? 有什么特点？每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时,如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念关系：instance.constructor.prototype = instance._proto_特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的,就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到Object内建对象请解释什么是事件委托/事件代理事件代理（ Event Delegation ），又称之为事件委托。是JavaScript中常用的绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能可以大量节省内存占用，减少事件注册，比如在table上代理所有td 的 click事件就非常棒可以实现当新增子对象时无需再次对其绑定Javascript 如何实现继承？构造继承原型继承实例继承拷贝继承原型prototype机制或apply 和 call方法去实现较简单，建议使用构造函数与原型混合方式1234567891011function Parent()&#123;this.name = &apos;wang&apos;;&#125;function Child()&#123; this.age = 28;&#125;Child.prototype = new Parent();//继承了Parent，通过原型var demo = new Child();alert(demo.age);alert(demo.name);//得到被继承的属性复制代码谈谈 This 对象的理解this总是指向函数的直接调用者（而非间接调用者）如果有new关键字，this指向new出来的那个对象在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent 中的this总是指向全局对象Window事件模型W3C中定义事件的发生经历三个阶段：捕获阶段（capturing）、目标阶段 （targetin）、冒泡阶段（bubbling）冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件阻止冒泡：在W3c中，使用stopPropagation()方法；在 IE 下设置cancelBubble =true阻止捕获：阻止事件的默认行为，例如click - a后的跳转。在W3c中，使用preventDefault()方法，在 IE 下设置window.event.returnValue = falsenew 操作符具体干了什么呢?创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型属性和方法被加入到this引用的对象中新创建的对象由this所引用，并且最后隐式的返回thisAjax 原理Ajax的原理简单来说是在用户和服务器之间加了—个中间层( AJAX 引擎)，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据Ajax的过程只涉及JavaScript 、 XMLHttpRequest 和 DOM 。 XMLHttpRequest是ajax的核心机制如何解决跨域问题?首先了解下浏览器的同源策略 同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS 、 CSFR等攻击。所谓同源是指&quot;协议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源通过jsonp跨域12345678910var script = document.createElement(&apos;script&apos;);script.type = &apos;text/javascript&apos;;// 传参并指定回调执行函数为onBackscript.src = &apos;http://www.....:8080/login?user=admin&amp;callback=onBack&apos;;document.head.appendChild(script);// 回调执行函数function onBack(res) &#123; alert(JSON.stringify(res));&#125;复制代码document.domain + iframe跨域1234567891011//父窗口：(http://www.domain.com/a.html)&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = &apos;domain.com&apos;; var user = &apos;admin&apos;;&lt;/script&gt;//子窗口：(http://child.domain.com/b.html)document.domain = &apos;domain.com&apos;;// 获取父窗口中变量alert(&apos;get js data from parent ---&gt; &apos; + window.parent.user);复制代码nginx代理跨域nodejs中间件代理跨域后端在头部信息里面设置安全域名说说你对 AMD 和 Commonjs 的理解CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载 模块，允许指定回调函数AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports 或 exports的属性赋值来达到暴露模块对象的目的js 的 7 种基本数据类型Undefined 、 Null 、Boolean 、Number 、String 、Bigint 、Symbol感谢：字符搬运工 同学纠正介绍 js 有哪些内置对象Object是JavaScript中所有对象的父对象数据封装类对象：Object 、 Array 、 Boolean 、 Number 和 String其他对象：Function 、 Arguments 、 Math 、 Date 、 RegExp 、 ErrorJS 有哪些方法定义对象对象字面量：var obj = {};构造函数：var obj = new Object();Object.create():var obj = Object.create(Object.prototype);你觉得 jQuery 源码有哪些写的好的地方jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率null，undefined 的区别undefined表示不存在这个值。undefined:是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。尝试读取时会返回undefined例如变量被声明了，但没有赋值时，就等于undefinednull表示一个对象被定义了，值为“空值”null: 是一个对象(空对象, 没有任何属性和方法)例如作为函数的参数，表示该函数的参数不是对象；在验证null时，一定要使用 === ，因为 == 无法分别null 和 undefined谈谈你对 ES6 的理解新增模板字符串（为JavaScript提供了简单的字符串插值功能）箭头函数for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let 和 const命令，用来声明变量。还有就是引入module模块的概念更多 ES 新语法：阮一峰的 ES 入门：https://es6.ruanyifeng.com/#docs/style面向对象编程思想基本思想是使用对象，类，继承，封装等基本概念来进行程序设计易维护易扩展开发工作的重用性、继承性高，降低重复工作量。缩短了开发周期如何通过 JS 判断一个数组instanceof运算符是用来测试一个对象是否在其原型链原型构造函数的属性123var arr = [];arr instanceof Array; // true复制代码isArray123Array.isArray([]) //trueArray.isArray(1) //false复制代码constructor属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数123var arr = [];arr.constructor == Array; //true复制代码Object.prototype12345678Object.prototype.toString.call([]) == &apos;[object Array]&apos;// 写个方法var isType = function (obj) &#123; return Object.prototype.toString.call(obj).slice(8,-1); //return Object.prototype.toString.apply([obj]).slice(8,-1);&#125;isType([]) //Array复制代码异步编程的实现方式回调函数* 优点：简单、容易理解 * 缺点：不利于维护，代码耦合高 事件监听(采用时间驱动模式，取决于某个事件是否发生)优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数缺点：事件驱动型，流程不够清晰发布/订阅(观察者模式)类似于事件监听，但是可以通过‘消息中心‘，了解现在有多少发布者，多少订阅者Promise对象优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数；缺点：编写和理解，相对比较难Generator函数优点：函数体内外的数据交换、错误处理机制缺点：流程管理不方便async函数优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。缺点：错误处理机制-对原生 Javascript 了解方向数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScriptsort 快速打乱数组12345var arr = [1,2,3,4,5,6,7,8,9,10];arr.sort(()=&gt; Math.random() - 0.5)//利用sort return 大于等于0不交换位置，小于0交换位置// [5, 8, 4, 3, 2, 9, 10, 6, 1, 7]复制代码数组去重操作ES6 Setfor循环indexOffor循环includessort详细操作前往：https://juejin.cn/post/6844904035619700750JS 原生拖拽节点给需要拖拽的节点绑定mousedown , mousemove , mouseup事件mousedown事件触发后，开始拖拽mousemove时，需要通过event.clientX 和 clientY获取拖拽位置，并实时更新位置mouseup时，拖拽结束需要注意浏览器边界值，设置拖拽范围深拷贝、浅拷贝所有的基础数据类型的赋值操作都是深拷贝通常利用上面这点，来对引用数据类型做递归深拷贝浅拷贝：Object.assign或者 扩展运算符深拷贝：JSON.parse(JSON.stringify(object))深层递归* 局限性：会忽略 undefined，不能序列化函数，不能解决循环引用的对象 -详细信息更多：https://juejin.cn/post/6906369563793817607**节流防抖节流：每隔一段时间执行一次，通常用在高频率触发的地方，降低频率。–如：鼠标滑动 拖拽防抖：一段时间内连续触发，不执行，直到超出限定时间执行最后一次。–如：input模糊搜索更多节流、防抖，细节介绍：https://juejin.cn/post/6844903592898330638变量提升当执行JS代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境js b() // call b console.log(a) // undefined var a = &#39;Hello world&#39; function b() { console.log(&#39;call b&#39;) }变量提升 这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用123456789b() // call b secondfunction b() &#123; console.log(&apos;call b fist&apos;)&#125;function b() &#123; console.log(&apos;call b second&apos;)&#125;var b = &apos;Hello world&apos;复制代码js 单线程单线程 - 只有一个线程，只能做一件事原因 - 避免DOM渲染的冲突* 浏览器需要渲染`DOM` * `JS`可以修改`DOM`结构 * `JS`执行的时候，浏览器`DOM`渲染会暂停 * 两段`JS`也不能同时执行（都修改`DOM`就冲突了） * `webworker`支持多线程，但是不能访问`DOM` 解决方案 - 异步说说 event loop首先，js是单线程的，主要的任务是处理用户的交互，而用户的交互无非就 是响应DOM的增删改，使用事件队列的形式，一次事件循环只处理一个事件 响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件， 那么事件队列的事件从哪里被push进来的呢。那就是另外一个线程叫事件触 发线程做的事情了，他的作用主要是在定时触发器线程、异步HTTP请求线程 满足特定条件下的回调函数push到事件队列中，等待js引擎空闲的时候去 执行，当然js引擎执行过程中有优先级之分，首先js引擎在一次事件循环中， 会先执行 js 线程的主任务，然后会去查找是否有微任务microtask（promise），如果有那就优先执行微任务，如果没有，在去查找 宏任务macrotask（setTimeout、setInterval）进行执行更详细的介绍前往：https://juejin.cn/post/6844903598573240327描述下 thisthis，函数执行的上下文，可以通过apply ， call ， bind改变this的指向。对于匿名函数或者直接调用的函数来说，this 指向全局上下文（浏览 器为window，NodeJS为 global），剩下的函数调用，那就是谁调用它，this就指向谁。当然还有es6的箭头函数，箭头函数的指向取决于该箭头函 数声明的位置，在哪里声明，this就指向哪里ajax、axios、fetch 区别ajax：本身是针对MVC的编程,不符合现在前端MVVM的浪潮基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）axios：从浏览器中创建XMLHttpRequest从node.js发出http请求支持Promise API拦截请求和响应转换请求和响应数据取消请求自动转换JSON数据客户端支持防止CSRF/XSRFfetch：只对网络请求报错，对 400 ， 500 都当做成功的请求，需要封装去处理默认不会带cookie，需要添加配置项（尴尬）本身无自带abort，无法超时控制，可以使用 AbortController 解决取消请求问题。没有办法原生监测请求的进度，而XHR可以更多 fetch 知识前往：阮一峰 fetch优化 篇SEO 优化合理的title 、 description 、 keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可语义化的HTML代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取重要内容不要用js输出：爬虫不会执行 js 获取内容少用iframe：搜索引擎不会抓取iframe中的内容非装饰性图片必须加alt提高网站速度：网站速度是搜索引擎排序的一个重要指标server 优化减少HTTP请求，合并文件、雪碧图减少DNS查询，使用缓存减少Dom元素的数量使用CDN配置ETag,http 缓存的手段对组件使用Gzip压缩减少cookie的大小css 优化将样式表放在页面顶部使用less scss表达式使用link不适用@import引入样式压缩css禁止使用gif图片实现loading效果（降低 CPU 消耗，提升渲染性能）使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流）对于一些小图标，可以使用base64位编码，以减少网络请求。页面头部的&lt;style&gt; &lt;script&gt;会阻塞页面；（因为 Renderer 进程中 JS 线程和渲染线程是互斥的）当需要设置的样式很多时设置className而不是直接操作stylejs 方面将脚本放到页面底部将js外部引入压缩js使用Eslint语法检测减少Dom的操作熟练使用设计模式禁止使用iframe（阻塞父文档onload事件）页面中空的href 和 src会阻塞页面其他资源的加载网页gzip ， CDN托管，data缓存 ，图片服务器webpack 优化点代码压缩插件UglifyJsPlugin服务器启用gzip压缩按需加载资源文件require.ensure优化devtool中的source-map剥离css文件，单独打包去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致开发环境不做无意义的工作如提取css计算文件 hash 等配置devtool优化构建时的搜索路径 指明需要构建目录及不需要构建目录其他优化点为什么利用多个域名来存储网站资源会更有效？CDN缓存更方便突破浏览器并发限制节约cookie带宽节约主域名的连接数，优化页面响应速度防止不必要的安全问题Other 篇从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？dns缓存cdn缓存浏览器缓存服务器缓存常见 web 安全及防护原理sql注入原理：就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令* 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双 &quot;-&quot; 进行转换等 * 永远不要使用动态拼装SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取 * 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接 * 不要把机密信息明文存放，请加密或者 hash 掉密码和敏感的信息 XSS防范方法：Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点首先代码里对用户输入的地方和变量都需要仔细检查长度和对 ”&lt;”,”&gt;”,”;”,”’” 等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag弄出来。这一个层面做好，至少可以堵住超过一半的XSS攻击XSS与CSRF有什么区别：XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤，1.登录受信任网站 A ，并在本地生成Cookie。2.在不登出 A 的情况下，访问危险网站 B服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数通过验证码的方法-用过哪些设计模式单例模式策略模式代理模式迭代器模式发布—订阅模式更多设计模式 15 种：https://www.cnblogs.com/imwtr/p/9451129.htmlNode 的应用场景特点* 它是一个`javascript`运行环境 * 依赖于`chrome V8`引擎进行代码解释 * 事件驱动 * 非阻塞 I/o * 单进程，单线程 优点对于文件的读写处理效率极高高并发（node最重要的优点）缺点只支持单核CPU，不能充分利用CPU可靠性低，一旦代码某个环节崩溃，整个系统都崩溃-那些操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在setTimeout的第一个参数使用字符串而非函数的话，会引发内存泄漏闭包使用不当简单介绍下 webpackWebPack是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML 、 Javascript 、 CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。谈谈你对 gulp 的了解gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成gulp的核心概念：流流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作Gulp的特点：* 易于使用：通过代码优于配置的策略，`gulp`让简单的任务简单，复杂的任务可管理 * 构建快速 利用`Node.js`流的威力，你可以快速构建项目并减少频繁的 IO 操作 * 易于学习 通过最少的`API`，掌握`gulp`毫不费力，构建工作尽在掌握：如同一系列流管道 -渐进增强和优雅降级渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容谈一谈你理解的函数式编程简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是”第一等公民”、只用”表达式”想了解更多，移步这里：https://zhuanlan.zhihu.com/p/57708956Vue 的双向绑定数据的原理vue.js则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter ， getter，在数据变动时发布消息给订阅者，触发相应的监听回调写个简单 Loaderloader就是一个node模块，它输出了一个函数。当某种资源需要用这个loader转换时，这个函数会被调用。并且，这个函数可以通过提供给它的this上下文访问Loader API 。 reverse-txt-loader1234567891011121314// 定义module.exports = function(src) &#123; //src是原文件内容（abcde），下面对内容进行处理，这里是反转 var result = src.split(&apos;&apos;).reverse().join(&apos;&apos;); //返回JavaScript源码，必须是String或者Buffer return `module.exports = &apos;$&#123;result&#125;&apos;`;&#125;//使用&#123;test: /\.txt$/,use: [&#123;&apos;./path/reverse-txt-loader&apos;&#125;]&#125;,20210203转载补充JS基础1. 如何在ES5环境下实现let这个问题实质上是在回答let和var有什么区别，对于这个问题，我们可以直接查看babel转换前后的结果，看一下在循环中通过let定义的变量是如何解决变量提升的问题babel在let定义的变量前加了道下划线，避免在块级作用域外访问到该变量，除了对变量名的转换，我们也可以通过自执行函数来模拟块级作用域12345678(function()&#123; for(var i = 0; i &lt; 5; i ++)&#123; console.log(i) // 0 1 2 3 4 &#125;&#125;)();console.log(i) // Uncaught ReferenceError: i is not defined复制代码不过这个问题并没有结束，我们回到var和let/const的区别上：var声明的变量会挂到window上，而let和const不会var声明的变量存在变量提升，而let和const不会let和const声明形成块作用域，只能在块作用域里访问，不能跨块访问，也不能跨函数访问同一作用域下let和const不能声明同名变量，而var可以暂时性死区，let和const声明的变量不能在声明前被使用babel的转化，其实只实现了第2、3、5点2. 如何在ES5环境下实现const实现const的关键在于Object.defineProperty()这个API，这个API用于在一个对象上增加或修改属性。通过配置属性描述符，可以精确地控制属性行为。Object.defineProperty() 接收三个参数：Object.defineProperty(obj, prop, desc)参数说明obj要在其上定义属性的对象prop要定义或修改的属性的名称descriptor将被定义或修改的属性描述符属性描述符说明默认值value该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefinedundefinedget一个给属性提供 getter 的方法，如果没有 getter 则为 undefinedundefinedset一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法undefinedwritable当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 falsefalseenumerableenumerable定义了对象的属性是否可以在 for…in 循环和 Object.keys() 中被枚举falseConfigurableconfigurable特性表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性是否可以被修改false对于const不可修改的特性，我们通过设置writable属性来实现123456789101112function _const(key, value) &#123; const desc = &#123; value, writable: false &#125; Object.defineProperty(window, key, desc)&#125; _const(&apos;obj&apos;, &#123;a: 1&#125;) //定义objobj.b = 2 //可以正常给obj的属性赋值obj = &#123;&#125; //无法赋值新对象复制代码参考资料：如何在 ES5 环境下实现一个const ？3. 手写call()123&gt; call() 方法`使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数&gt; 语法：`function.call(thisArg, arg1, arg2, ...)&gt;call()的原理比较简单，由于函数的this指向它的直接调用者，我们变更调用者即完成this指向的变更：123456789101112//变更函数调用者示例function foo() &#123; console.log(this.name)&#125;// 测试const obj = &#123; name: &apos;写代码像蔡徐抻&apos;&#125;obj.foo = foo // 变更foo的调用者obj.foo() // &apos;写代码像蔡徐抻&apos;复制代码基于以上原理, 我们两句代码就能实现call()12345Function.prototype.myCall = function(thisArg, ...args) &#123; thisArg.fn = this // this指向调用call的对象,即我们要改变this指向的函数 return thisArg.fn(...args) // 执行函数并return其执行结果&#125;复制代码但是我们有一些细节需要处理：123456789101112Function.prototype.myCall = function(thisArg, ...args) &#123; const fn = Symbol(&apos;fn&apos;) // 声明一个独有的Symbol属性, 防止fn覆盖已有属性 thisArg = thisArg || window // 若没有传入this, 默认绑定window对象 thisArg[fn] = this // this指向调用call的对象,即我们要改变this指向的函数 const result = thisArg[fn](...args) // 执行当前函数 delete thisArg[fn] // 删除我们声明的fn属性 return result // 返回函数执行结果&#125;//测试foo.myCall(obj) // 输出&apos;写代码像蔡徐抻&apos;复制代码4. 手写apply()apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。语法：func.apply(thisArg, [argsArray])apply()和call()类似，区别在于call()接收参数列表，而apply()接收一个参数数组，所以我们在call()的实现上简单改一下入参形式即可123456789101112Function.prototype.myApply = function(thisArg, args) &#123; const fn = Symbol(&apos;fn&apos;) // 声明一个独有的Symbol属性, 防止fn覆盖已有属性 thisArg = thisArg || window // 若没有传入this, 默认绑定window对象 thisArg[fn] = this // this指向调用call的对象,即我们要改变this指向的函数 const result = thisArg[fn](...args) // 执行当前函数（此处说明一下：虽然apply()接收的是一个数组，但在调用原函数时，依然要展开参数数组。可以对照原生apply()，原函数接收到展开的参数数组） delete thisArg[fn] // 删除我们声明的fn属性 return result // 返回函数执行结果&#125;//测试foo.myApply(obj, []) // 输出&apos;写代码像蔡徐抻&apos;复制代码5. 手写bind()bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。语法: function.bind(thisArg, arg1, arg2, …)从用法上看，似乎给call/apply包一层function就实现了bind()：123456Function.prototype.myBind = function(thisArg, ...args) &#123; return () =&gt; &#123; this.apply(thisArg, args) &#125;&#125;复制代码但我们忽略了三点：bind()除了this还接收其他参数，bind()返回的函数也接收参数，这两部分的参数都要传给返回的函数new会改变this指向：如果bind绑定后的函数被new了，那么this指向会发生改变，指向当前函数的实例没有保留原函数在原型链上的属性和方法123456789101112131415161718192021Function.prototype.myBind = function (thisArg, ...args) &#123; var self = this // new优先级 var fbound = function () &#123; self.apply(this instanceof self ? this : thisArg, args.concat(Array.prototype.slice.call(arguments))) &#125; // 继承原型上的属性和方法 fbound.prototype = Object.create(self.prototype); return fbound;&#125;//测试const obj = &#123; name: &apos;写代码像蔡徐抻&apos; &#125;function foo() &#123; console.log(this.name) console.log(arguments)&#125;foo.myBind(obj, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;)() //输出写代码像蔡徐抻 [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]复制代码6. 手写一个防抖函数防抖和节流的概念都比较简单，所以我们就不在“防抖节流是什么”这个问题上浪费过多篇幅了，简单点一下：防抖，即短时间内大量触发同一事件，只会执行一次函数，实现原理为设置一个定时器，约定在xx毫秒后再触发事件处理，每次触发事件都会重新设置计时器，直到xx毫秒内无第二次操作，防抖常用于搜索框/滚动条的监听事件处理，如果不做防抖，每输入一个字/滚动屏幕，都会触发事件处理，造成性能浪费。123456789101112function debounce(func, wait) &#123; let timeout = null return function() &#123; let context = this let args = arguments if (timeout) clearTimeout(timeout) timeout = setTimeout(() =&gt; &#123; func.apply(context, args) &#125;, wait) &#125;&#125;复制代码7. 手写一个节流函数防抖是延迟执行，而节流是间隔执行，函数节流即每隔一段时间就执行一次，实现原理为设置一个定时器，约定xx毫秒后执行事件，如果时间到了，那么执行函数并重置定时器，和防抖的区别在于，防抖每次触发事件都重置定时器，而节流在定时器到时间后再清空定时器123456789101112131415function throttle(func, wait) &#123; let timeout = null return function() &#123; let context = this let args = arguments if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; timeout = null func.apply(context, args) &#125;, wait) &#125; &#125;&#125;复制代码实现方式2：使用两个时间戳prev旧时间戳和now新时间戳，每次触发事件都判断二者的时间差，如果到达规定时间，执行函数并重置旧时间戳12345678910111213function throttle(func, wait) &#123; var prev = 0; return function() &#123; let now = Date.now(); let context = this; let args = arguments; if (now - prev &gt; wait) &#123; func.apply(context, args); prev = now; &#125; &#125;&#125;复制代码8. 数组扁平化对于[1, [1,2], [1,2,3]]这样多层嵌套的数组，我们如何将其扁平化为[1, 1, 2, 1, 2, 3]这样的一维数组呢：1.ES6的flat()123const arr = [1, [1,2], [1,2,3]]arr.flat(Infinity) // [1, 1, 2, 1, 2, 3]复制代码2.序列化后正则1234const arr = [1, [1,2], [1,2,3]]const str = `[$&#123;JSON.stringify(arr).replace(/(\[|\])/g, &apos;&apos;)&#125;]`JSON.parse(str) // [1, 1, 2, 1, 2, 3]复制代码3.递归对于树状结构的数据，最直接的处理方式就是递归1234567891011const arr = [1, [1,2], [1,2,3]]function flat(arr) &#123; let result = [] for (const item of arr) &#123; item instanceof Array ? result = result.concat(flat(item)) : result.push(item) &#125; return result&#125;flat(arr) // [1, 1, 2, 1, 2, 3]复制代码4.reduce()递归123456789const arr = [1, [1,2], [1,2,3]]function flat(arr) &#123; return arr.reduce((prev, cur) =&gt; &#123; return prev.concat(cur instanceof Array ? flat(cur) : cur) &#125;, [])&#125;flat(arr) // [1, 1, 2, 1, 2, 3]复制代码5.迭代+展开运算符123456789// 每次while都会合并一层的元素，这里第一次合并结果为[1, 1, 2, 1, 2, 3, [4,4,4]]// 然后arr.some判定数组中是否存在数组，因为存在[4,4,4]，继续进入第二次循环进行合并let arr = [1, [1,2], [1,2,3,[4,4,4]]]while (arr.some(Array.isArray)) &#123; arr = [].concat(...arr);&#125;console.log(arr) // [1, 1, 2, 1, 2, 3, 4, 4, 4]复制代码9. 手写一个Promise实现一个符合规范的Promise篇幅比较长，建议阅读笔者上一篇文章：异步编程二三事 | Promise/async/Generator实现原理解析 | 9k字JS面向对象在JS中一切皆对象，但JS并不是一种真正的面向对象(OOP)的语言，因为它缺少类(class)的概念。虽然ES6引入了class和extends，使我们能够轻易地实现类和继承。但JS并不存在真实的类，JS的类是通过函数以及原型链机制模拟的，本小节的就来探究如何在ES5环境下利用函数和原型链实现JS面向对象的特性在开始之前，我们先回顾一下原型链的知识，后续new和继承等实现都是基于原型链机制。很多介绍原型链的资料都能写上洋洋洒洒几千字，但我觉得读者们不需要把原型链想太复杂，容易把自己绕进去，其实在我看来，原型链的核心只需要记住三点：每个对象都有__proto__属性，该属性指向其原型对象，在调用实例的方法和属性时，如果在实例对象上找不到，就会往原型对象上找构造函数的prototype属性也指向实例的原型对象原型对象的constructor属性指向构造函数1. 模拟实现new首先我们要知道new做了什么创建一个新对象，并继承其构造函数的prototype，这一步是为了继承构造函数原型上的属性和方法执行构造函数，方法内的this被指定为该新实例，这一步是为了执行构造函数内的赋值操作返回新实例（规范规定，如果构造方法返回了一个对象，那么返回该对象，否则返回第一步创建的新对象）1234567891011121314151617181920// new是关键字,这里我们用函数来模拟,new Foo(args) &lt;=&gt; myNew(Foo, args)function myNew(foo, ...args) &#123; // 创建新对象,并继承构造方法的prototype属性, 这一步是为了把obj挂原型链上, 相当于obj.__proto__ = Foo.prototype let obj = Object.create(foo.prototype) // 执行构造方法, 并为其绑定新this, 这一步是为了让构造方法能进行this.name = name之类的操作, args是构造方法的入参, 因为这里用myNew模拟, 所以入参从myNew传入 let result = foo.apply(obj, args) // 如果构造方法已经return了一个对象，那么就返回该对象，否则返回myNew创建的新对象（一般情况下，构造方法不会返回新实例，但使用者可以选择返回新实例来覆盖new创建的对象） return Object.prototype.toString.call(result) === &apos;[object Object]&apos; ? result : obj&#125;// 测试：function Foo(name) &#123; this.name = name&#125;const newObj = myNew(Foo, &apos;zhangsan&apos;)console.log(newObj) // Foo &#123;name: &quot;zhangsan&quot;&#125;console.log(newObj instanceof Foo) // true复制代码2. ES5如何实现继承说到继承，最容易想到的是ES6的extends，当然如果只回答这个肯定不合格，我们要从函数和原型链的角度上实现继承，下面我们一步步地、递进地实现一个合格的继承一. 原型链继承原型链继承的原理很简单，直接让子类的原型对象指向父类实例，当子类实例找不到对应的属性和方法时，就会往它的原型对象，也就是父类实例上找，从而实现对父类的属性和方法的继承1234567891011121314151617181920// 父类function Parent() &#123; this.name = &apos;写代码像蔡徐抻&apos;&#125;// 父类的原型方法Parent.prototype.getName = function() &#123; return this.name&#125;// 子类function Child() &#123;&#125;// 让子类的原型对象指向父类实例, 这样一来在Child实例中找不到的属性和方法就会到原型对象(父类实例)上寻找Child.prototype = new Parent()Child.prototype.constructor = Child // 根据原型链的规则,顺便绑定一下constructor, 这一步不影响继承, 只是在用到constructor时会需要// 然后Child实例就能访问到父类及其原型上的name属性和getName()方法const child = new Child()child.name // &apos;写代码像蔡徐抻&apos;child.getName() // &apos;写代码像蔡徐抻&apos;复制代码原型继承的缺点:由于所有Child实例原型都指向同一个Parent实例, 因此对某个Child实例的父类引用类型变量修改会影响所有的Child实例在创建子类实例时无法向父类构造传参, 即没有实现super()的功能12345678910111213141516171819// 示例:function Parent() &#123; this.name = [&apos;写代码像蔡徐抻&apos;] &#125;Parent.prototype.getName = function() &#123; return this.name&#125;function Child() &#123;&#125;Child.prototype = new Parent()Child.prototype.constructor = Child // 测试const child1 = new Child()const child2 = new Child()child1.name[0] = &apos;foo&apos;console.log(child1.name) // [&apos;foo&apos;]console.log(child2.name) // [&apos;foo&apos;] (预期是[&apos;写代码像蔡徐抻&apos;], 对child1.name的修改引起了所有child实例的变化)复制代码二. 构造函数继承构造函数继承，即在子类的构造函数中执行父类的构造函数，并为其绑定子类的this，让父类的构造函数把成员属性和方法都挂到子类的this上去，这样既能避免实例之间共享一个原型实例，又能向父类构造方法传参123456789101112131415161718function Parent(name) &#123; this.name = [name]&#125;Parent.prototype.getName = function() &#123; return this.name&#125;function Child() &#123; Parent.call(this, &apos;zhangsan&apos;) // 执行父类构造方法并绑定子类的this, 使得父类中的属性能够赋到子类的this上&#125;//测试const child1 = new Child()const child2 = new Child()child1.name[0] = &apos;foo&apos;console.log(child1.name) // [&apos;foo&apos;]console.log(child2.name) // [&apos;zhangsan&apos;]child2.getName() // 报错,找不到getName(), 构造函数继承的方式继承不到父类原型上的属性和方法复制代码构造函数继承的缺点:继承不到父类原型上的属性和方法三. 组合式继承既然原型链继承和构造函数继承各有互补的优缺点, 那么我们为什么不组合起来使用呢, 所以就有了综合二者的组合式继承12345678910111213141516171819202122function Parent(name) &#123; this.name = [name]&#125;Parent.prototype.getName = function() &#123; return this.name&#125;function Child() &#123; // 构造函数继承 Parent.call(this, &apos;zhangsan&apos;) &#125;//原型链继承Child.prototype = new Parent()Child.prototype.constructor = Child//测试const child1 = new Child()const child2 = new Child()child1.name[0] = &apos;foo&apos;console.log(child1.name) // [&apos;foo&apos;]console.log(child2.name) // [&apos;zhangsan&apos;]child2.getName() // [&apos;zhangsan&apos;]复制代码组合式继承的缺点:每次创建子类实例都执行了两次构造函数(Parent.call()和new Parent())，虽然这并不影响对父类的继承，但子类创建实例时，原型中会存在两份相同的属性和方法，这并不优雅四. 寄生式组合继承为了解决构造函数被执行两次的问题, 我们将指向父类实例改为指向父类原型, 减去一次构造函数的执行1234567891011121314151617181920212223function Parent(name) &#123; this.name = [name]&#125;Parent.prototype.getName = function() &#123; return this.name&#125;function Child() &#123; // 构造函数继承 Parent.call(this, &apos;zhangsan&apos;) &#125;//原型链继承// Child.prototype = new Parent()Child.prototype = Parent.prototype //将`指向父类实例`改为`指向父类原型`Child.prototype.constructor = Child//测试const child1 = new Child()const child2 = new Child()child1.name[0] = &apos;foo&apos;console.log(child1.name) // [&apos;foo&apos;]console.log(child2.name) // [&apos;zhangsan&apos;]child2.getName() // [&apos;zhangsan&apos;]复制代码但这种方式存在一个问题，由于子类原型和父类原型指向同一个对象，我们对子类原型的操作会影响到父类原型，例如给Child.prototype增加一个getName()方法，那么会导致Parent.prototype也增加或被覆盖一个getName()方法，为了解决这个问题，我们给Parent.prototype做一个浅拷贝123456789101112131415161718192021function Parent(name) &#123; this.name = [name]&#125;Parent.prototype.getName = function() &#123; return this.name&#125;function Child() &#123; // 构造函数继承 Parent.call(this, &apos;zhangsan&apos;) &#125;//原型链继承// Child.prototype = new Parent()Child.prototype = Object.create(Parent.prototype) //将`指向父类实例`改为`指向父类原型`Child.prototype.constructor = Child//测试const child = new Child()const parent = new Parent()child.getName() // [&apos;zhangsan&apos;]parent.getName() // 报错, 找不到getName()复制代码到这里我们就完成了ES5环境下的继承的实现，这种继承方式称为寄生组合式继承，是目前最成熟的继承方式，babel对ES6继承的转化也是使用了寄生组合式继承我们回顾一下实现过程：一开始最容易想到的是原型链继承，通过把子类实例的原型指向父类实例来继承父类的属性和方法，但原型链继承的缺陷在于对子类实例继承的引用类型的修改会影响到所有的实例对象以及无法向父类的构造方法传参。因此我们引入了构造函数继承, 通过在子类构造函数中调用父类构造函数并传入子类this来获取父类的属性和方法，但构造函数继承也存在缺陷，构造函数继承不能继承到父类原型链上的属性和方法。所以我们综合了两种继承的优点，提出了组合式继承，但组合式继承也引入了新的问题，它每次创建子类实例都执行了两次父类构造方法，我们通过将子类原型指向父类实例改为子类原型指向父类原型的浅拷贝来解决这一问题，也就是最终实现 —— 寄生组合式继承V8引擎机制1. V8如何执行一段JS代码预解析：检查语法错误但不生成AST生成AST：经过词法/语法分析，生成抽象语法树生成字节码：基线编译器(Ignition)将AST转换成字节码生成机器码：优化编译器(Turbofan)将字节码转换成优化过的机器码，此外在逐行执行字节码的过程中，如果一段代码经常被执行，那么V8会将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码，优化了执行速度上面几点只是V8执行机制的极简总结，建议阅读参考资料：1.V8 是怎么跑起来的 —— V8 的 JavaScript 执行管道2.JavaScript 引擎 V8 执行流程概述2. 介绍一下引用计数和标记清除引用计数：给一个变量赋值引用类型，则该对象的引用次数+1，如果这个变量变成了其他值，那么该对象的引用次数-1，垃圾回收器会回收引用次数为0的对象。但是当对象循环引用时，会导致引用次数永远无法归零，造成内存无法释放。标记清除：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的等待回收的对象。3. V8如何进行垃圾回收JS引擎中对变量的存储主要有两种位置，栈内存和堆内存，栈内存存储基本类型数据以及引用类型数据的内存地址，堆内存储存引用类型的数据栈内存的回收：栈内存调用栈上下文切换后就被回收，比较简单堆内存的回收：V8的堆内存分为新生代内存和老生代内存，新生代内存是临时分配的内存，存在时间短，老生代内存存在时间长新生代内存回收机制：新生代内存容量小，64位系统下仅有32M。新生代内存分为From、To两部分，进行垃圾回收时，先扫描From，将非存活对象回收，将存活对象顺序复制到To中，之后调换From/To，等待下一次回收老生代内存回收机制晋升：如果新生代的变量经过多次回收依然存在，那么就会被放入老生代内存中标记清除：老生代内存会先遍历所有对象并打上标记，然后对正在使用或被强引用的对象取消标记，回收被标记的对象整理内存碎片：把对象挪到内存的一端参考资料：聊聊V8引擎的垃圾回收4. JS相较于C++等语言为什么慢，V8做了哪些优化JS的问题：动态类型：导致每次存取属性/寻求方法时候，都需要先检查类型；此外动态类型也很难在编译阶段进行优化属性存取：C++/Java等语言中方法、属性是存储在数组中的，仅需数组位移就可以获取，而JS存储在对象中，每次获取都要进行哈希查询V8的优化：优化JIT(即时编译)：相较于C++/Java这类编译型语言，JS一边解释一边执行，效率低。V8对这个过程进行了优化：如果一段代码被执行多次，那么V8会把这段代码转化为机器码缓存下来，下次运行时直接使用机器码。隐藏类：对于C++这类语言来说，仅需几个指令就能通过偏移量获取变量信息，而JS需要进行字符串匹配，效率低，V8借用了类和偏移位置的思想，将对象划分成不同的组，即隐藏类内嵌缓存：即缓存对象查询的结果。常规查询过程是：获取隐藏类地址 -&gt; 根据属性名查找偏移值 -&gt; 计算该属性地址，内嵌缓存就是对这一过程结果的缓存垃圾回收管理：上文已介绍参考资料：为什么V8引擎这么快？浏览器渲染机制1. 浏览器的渲染过程是怎样的大体流程如下：HTML和CSS经过各自解析，生成DOM树和CSSOM树合并成为渲染树根据渲染树进行布局最后调用GPU进行绘制，显示在屏幕上2. 如何根据浏览器渲染机制加快首屏速度优化文件大小：HTML和CSS的加载和解析都会阻塞渲染树的生成，从而影响首屏展示速度，因此我们可以通过优化文件大小、减少CSS文件层级的方法来加快首屏速度避免资源下载阻塞文档解析：浏览器解析到标签时，会阻塞文档解析，直到脚本执行完成，因此我们通常把标签放在底部，或者加上defer、async来进行异步下载 3. 什么是回流(重排)，什么情况下会触发回流 当元素的尺寸或者位置发生了变化，就需要重新计算渲染树，这就是回流 DOM元素的几何属性(width/height/padding/margin/border)发生变化时会触发回流 DOM元素移动或增加会触发回流 读写offset/scroll/client等属性时会触发回流 调用window.getComputedStyle会触发回流 4. 什么是重绘，什么情况下会触发重绘 DOM样式发生了变化，但没有影响DOM的几何属性时，会触发重绘，而不会触发回流。重绘由于DOM位置信息不需要更新，省去了布局过程，因而性能上优于回流 5. 什么是GPU加速，如何使用GPU加速，GPU加速的缺点 优点：使用transform、opacity、filters等属性时，会直接在GPU中完成处理，这些属性的变化不会引起回流重绘 缺点：GPU渲染字体会导致字体模糊，过多的GPU处理会导致内存问题 6. 如何减少回流 使用class替代style，减少style的使用 使用resize、scroll时进行防抖和节流处理，这两者会直接导致回流 使用visibility替换display: none，因为前者只会引起重绘，后者会引发回流 批量修改元素时，可以先让元素脱离文档流，等修改完毕后，再放入文档流 避免触发同步布局事件，我们在获取offsetWidth这类属性的值时，可以使用变量将查询结果存起来，避免多次查询，每次对offset/scroll/client等属性进行查询时都会触发回流 对于复杂动画效果,使用绝对定位让其脱离文档流，复杂的动画效果会频繁地触发回流重绘，我们可以将动画元素设置绝对定位从而脱离文档流避免反复回流重绘。 参考资料：必须明白的浏览器渲染机制 浏览器缓存策略1. 介绍一下浏览器缓存位置和优先级 Service Worker Memory Cache（内存缓存） Disk Cache（硬盘缓存） Push Cache（推送缓存） 以上缓存都没命中就会进行网络请求 2. 说说不同缓存间的差别 Service Worker 和Web Worker类似，是独立的线程，我们可以在这个线程中缓存文件，在主线程需要的时候读取这里的文件，Service Worker使我们可以自由选择缓存哪些文件以及文件的匹配、读取规则，并且缓存是持续性的 Memory Cache 即内存缓存，内存缓存不是持续性的，缓存会随着进程释放而释放 Disk Cache 即硬盘缓存，相较于内存缓存，硬盘缓存的持续性和容量更优，它会根据HTTP header的字段判断哪些资源需要缓存 Push Cache 即推送缓存，是HTTP/2的内容，目前应用较少 3. 介绍一下浏览器缓存策略 强缓存(不要向服务器询问的缓存) 设置Expires 即过期时间，例如「Expires: Thu, 26 Dec 2019 10:30:42 GMT」表示缓存会在这个时间后失效，这个过期日期是绝对日期，如果修改了本地日期，或者本地日期与服务器日期不一致，那么将导致缓存过期时间错误。 设置Cache-Control HTTP/1.1新增字段，Cache-Control可以通过max-age字段来设置过期时间，例如「Cache-Control:max-age=3600」除此之外Cache-Control还能设置private/no-cache等多种字段 协商缓存(需要向服务器询问缓存是否已经过期) Last-Modified 即最后修改时间，浏览器第一次请求资源时，服务器会在响应头上加上Last-Modified ，当浏览器再次请求该资源时，浏览器会在请求头中带上If-Modified-Since 字段，字段的值就是之前服务器返回的最后修改时间，服务器对比这两个时间，若相同则返回304，否则返回新资源，并更新Last-Modified ETag HTTP/1.1新增字段，表示文件唯一标识，只要文件内容改动，ETag就会重新计算。缓存流程和 Last-Modified 一样：服务器发送 ETag 字段 -&gt; 浏览器再次请求时发送 If-None-Match -&gt; 如果ETag值不匹配，说明文件已经改变，返回新资源并更新ETag，若匹配则返回304 两者对比 ETag 比 Last-Modified 更准确：如果我们打开文件但并没有修改，Last-Modified 也会改变，并且 Last-Modified 的单位时间为一秒，如果一秒内修改完了文件，那么还是会命中缓存 如果什么缓存策略都没有设置，那么浏览器会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间 参考资料：浏览器缓存机制剖析 网络相关1. 讲讲网络OSI七层模型，TCP/IP和HTTP分别位于哪一层 模型 概述 单位 物理层 网络连接介质，如网线、光缆，数据在其中以比特为单位传输 bit 数据链路层 数据链路层将比特封装成数据帧并传递 帧 网络层 定义IP地址，定义路由功能，建立主机到主机的通信 数据包 传输层 负责将数据进行可靠或者不可靠传递，建立端口到端口的通信 数据段 会话层 控制应用程序之间会话能力，区分不同的进程 表示层 数据格式标识，基本压缩加密功能 应用层 各种应用软件 2. 常见HTTP状态码有哪些 2xx 开头（请求成功） 200 OK：客户端发送给服务器的请求被正常处理并返回 3xx 开头（重定向） 301 Moved Permanently：永久重定向，请求的网页已永久移动到新位置。 服务器返回此响应时，会自动将请求者转到新位置 302 Moved Permanently：临时重定向，请求的网页已临时移动到新位置。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求 304 Not Modified：未修改，自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容 4xx 开头（客户端错误） 400 Bad Request：错误请求，服务器不理解请求的语法，常见于客户端传参错误 401 Unauthorized：未授权，表示发送的请求需要有通过 HTTP 认证的认证信息，常见于客户端未登录 403 Forbidden：禁止，服务器拒绝请求，常见于客户端权限不足 404 Not Found：未找到，服务器找不到对应资源 5xx 开头（服务端错误） 500 Inter Server Error：服务器内部错误，服务器遇到错误，无法完成请求 501 Not Implemented：尚未实施，服务器不具备完成请求的功能 502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503 service unavailable：服务不可用，服务器目前无法使用（处于超载或停机维护状态）。通常是暂时状态。 3. GET请求和POST请求有何区别 标准答案： GET请求参数放在URL上，POST请求参数放在请求体里 GET请求参数长度有限制，POST请求参数长度可以非常大 POST请求相较于GET请求安全一点点，因为GET请求的参数在URL上，且有历史记录 GET请求能缓存，POST不能 更进一步： 其实HTTP协议并没有要求GET/POST请求参数必须放在URL上或请求体里，也没有规定GET请求的长度，目前对URL的长度限制，是各家浏览器设置的限制。GET和POST的根本区别在于：GET请求是幂等性的，而POST请求不是 幂等性，指的是对某一资源进行一次或多次请求都具有相同的副作用。例如搜索就是一个幂等的操作，而删除、新增则不是一个幂等操作。 由于GET请求是幂等的，在网络不好的环境中，GET请求可能会重复尝试，造成重复操作数据的风险，因此，GET请求用于无副作用的操作(如搜索)，新增/删除等操作适合用POST 参考资料：HTTP｜GET 和 POST 区别？网上多数答案都是错的 4. HTTP的请求报文由哪几部分组成 一个HTTP请求报文由请求行（request line）、请求头（header）、空行和请求数据4个部分组成 响应报文和请求报文结构类似，不再赘述 5. HTTP常见请求/响应头及其含义 通用头（请求头和响应头都有的首部） 字段 作用 值 Cache-Control 控制缓存 public：表示响应可以被任何对象缓存(包括客户端/代理服务器) private(默认值)：响应只能被单个客户缓存,不能被代理服务器缓存 no-cache：缓存要经过服务器验证，在浏览器使用缓存前，会对比ETag，若没变则返回304，使用缓存 no-store：禁止任何缓存 Connection 是否需要持久连接(HTTP 1.1默认持久连接) keep-alive / close Transfer-Encoding 报文主体的传输编码格式 chunked(分块) / identity(未压缩和修改) / gzip(LZ77压缩) / compress(LZW压缩,弃用) / deflate(zlib结构压缩) 请求头 字段 作用 语法 Accept 告知（服务器）客户端可以处理的内容类型 text/html、image/、/* If-Modified-Since 将Last-Modified的值发送给服务器，询问资源是否已经过期(被修改)，过期则返回新资源，否则返回304 示例：If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT If-Unmodified-Since 将Last-Modified的值发送给服务器，询问文件是否被修改，若没有则返回200，否则返回412预处理错误，可用于断点续传。通俗点说If-Unmodified-Since是文件没有修改时下载，If-Modified-Since是文件修改时下载 示例：If-Unmodified-Since: Wed, 21 Oct 2015 07:28:00 GMT If-None-Match 将ETag的值发送给服务器，询问资源是否已经过期(被修改)，过期则返回新资源，否则返回304 示例：If-None-Match: “bfc13a6472992d82d” If-Match 将ETag的值发送给服务器，询问文件是否被修改，若没有则返回200，否则返回412预处理错误，可用于断点续传 示例：If-Match: “bfc129c88ca92d82d” Range 告知服务器返回文件的哪一部分, 用于断点续传 示例：Range: bytes=200-1000, 2000-6576, 19000- Host 指明了服务器的域名（对于虚拟主机来说），以及（可选的）服务器监听的TCP端口号 示例：Host:www.baidu.com User-Agent 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本 User-Agent: Mozilla/ () () 响应头 字段 作用 语法 Location 需要将页面重新定向至的地址。一般在响应码为3xx的响应中才会有意义 Location: ETag 资源的特定版本的标识符，如果内容没有改变，Web服务器不需要发送完整的响应 ETag: “&lt;etag_value&gt;” Server 处理请求的源头服务器所用到的软件相关信息 Server: 实体头（针对请求报文和响应报文的实体部分使用首部） 字段 作用 语法 Allow 资源可支持http请求的方法 Allow: ，示例：Allow: GET, POST, HEAD Last-Modified 资源最后的修改时间，用作一个验证器来判断接收到的或者存储的资源是否彼此一致，精度不如ETag 示例：Last-Modified: Wed, 21 Oct 2020 07:28:00 GMT Expires 响应过期时间 Expires: ，示例：Expires: Wed, 21 Oct 2020 07:28:00 GMT HTTP首部当然不止这么几个，但为了避免写太多大家记不住(主要是别的我也没去看)，这里只介绍了一些常用的，详细的可以看MDN的文档 6. HTTP/1.0和HTTP/1.1有什么区别 长连接： HTTP/1.1支持长连接和请求的流水线，在一个TCP连接上可以传送多个HTTP请求，避免了因为多次建立TCP连接的时间消耗和延时 缓存处理： HTTP/1.1引入Entity tag，If-Unmodified-Since, If-Match, If-None-Match等新的请求头来控制缓存，详见浏览器缓存小节 带宽优化及网络连接的使用： HTTP1.1则在请求头引入了range头域，支持断点续传功能 Host头处理： 在HTTP/1.0中认为每台服务器都有唯一的IP地址，但随着虚拟主机技术的发展，多个主机共享一个IP地址愈发普遍，HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会400错误 7. 介绍一下HTTP/2.0新特性 多路复用： 即多个请求都通过一个TCP连接并发地完成 服务端推送： 服务端能够主动把资源推送给客户端 新的二进制格式： HTTP/2采用二进制格式传输数据，相比于HTTP/1.1的文本格式，二进制格式具有更好的解析性和拓展性 header压缩： HTTP/2压缩消息头，减少了传输数据的大小 8. 说说HTTP/2.0多路复用基本原理以及解决的问题 HTTP/2解决的问题，就是HTTP/1.1存在的问题： TCP慢启动： TCP连接建立后，会经历一个先慢后快的发送过程，就像汽车启动一般，如果我们的网页文件(HTML/JS/CSS/icon)都经过一次慢启动，对性能是不小的损耗。另外慢启动是TCP为了减少网络拥塞的一种策略，我们是没有办法改变的。 多条TCP连接竞争带宽： 如果同时建立多条TCP连接，当带宽不足时就会竞争带宽，影响关键资源的下载。 HTTP/1.1队头阻塞： 尽管HTTP/1.1长链接可以通过一个TCP连接传输多个请求，但同一时刻只能处理一个请求，当前请求未结束前，其他请求只能处于阻塞状态。 为了解决以上几个问题，HTTP/2一个域名只使用一个TCP⻓连接来传输数据，而且请求直接是并行的、非阻塞的，这就是多路复用 实现原理： HTTP/2引入了一个二进制分帧层，客户端和服务端进行传输时，数据会先经过二进制分帧层处理，转化为一个个带有请求ID的帧，这些帧在传输完成后根据ID组合成对应的数据。 9. 说说HTTP/3.0尽管HTTP/2解决了很多1.1的问题，但HTTP/2仍然存在一些缺陷，这些缺陷并不是来自于HTTP/2协议本身，而是来源于底层的TCP协议，我们知道TCP链接是可靠的连接，如果出现了丢包，那么整个连接都要等待重传，HTTP/1.1可以同时使用6个TCP连接，一个阻塞另外五个还能工作，但HTTP/2只有一个TCP连接，阻塞的问题便被放大了。 由于TCP协议已经被广泛使用，我们很难直接修改TCP协议，基于此，HTTP/3选择了一个折衷的方法——UDP协议，HTTP/2在UDP的基础上实现多路复用、0-RTT、TLS加密、流量控制、丢包重传等功能。 参考资料：http发展史(http0.9、http1.0、http1.1、http2、http3)梳理笔记 (推荐阅读) 10. HTTP和HTTPS有何区别 HTTPS使用443端口，而HTTP使用80 HTTPS需要申请证书 HTTP是超文本传输协议，是明文传输；HTTPS是经过SSL加密的协议，传输更安全 HTTPS比HTTP慢，因为HTTPS除了TCP握手的三个包，还要加上SSL握手的九个包 11. HTTPS是如何进行加密的我们通过分析几种加密方式，层层递进，理解HTTPS的加密方式以及为什么使用这种加密方式： 对称加密 客户端和服务器公用一个密匙用来对消息加解密，这种方式称为对称加密。客户端和服务器约定好一个加密的密匙。客户端在发消息前用该密匙对消息加密，发送给服务器后，服务器再用该密匙进行解密拿到消息。 这种方式一定程度上保证了数据的安全性，但密钥一旦泄露(密钥在传输过程中被截获)，传输内容就会暴露，因此我们要寻找一种安全传递密钥的方法。 非对称加密 采用非对称加密时，客户端和服务端均拥有一个公钥和私钥，公钥加密的内容只有对应的私钥能解密。私钥自己留着，公钥发给对方。这样在发送消息前，先用对方的公钥对消息进行加密，收到后再用自己的私钥进行解密。这样攻击者只拿到传输过程中的公钥也无法破解传输的内容 尽管非对称加密解决了由于密钥被获取而导致传输内容泄露的问题，但中间人仍然可以用篡改公钥的方式来获取或篡改传输内容，而且非对称加密的性能比对称加密的性能差了不少 第三方认证 上面这种方法的弱点在于，客户端不知道公钥是由服务端返回，还是中间人返回的，因此我们再引入一个第三方认证的环节：即第三方使用私钥加密我们自己的公钥，浏览器已经内置一些权威第三方认证机构的公钥，浏览器会使用第三方的公钥来解开第三方私钥加密过的我们自己的公钥，从而获取公钥，如果能成功解密，就说明获取到的自己的公钥是正确的 但第三方认证也未能完全解决问题，第三方认证是面向所有人的，中间人也能申请证书，如果中间人使用自己的证书掉包原证书，客户端还是无法确认公钥的真伪 数字签名 为了让客户端能够验证公钥的来源，我们给公钥加上一个数字签名，这个数字签名是由企业、网站等各种信息和公钥经过单向hash而来，一旦构成数字签名的信息发生变化，hash值就会改变，这就构成了公钥来源的唯一标识。 具体来说，服务端本地生成一对密钥，然后拿着公钥以及企业、网站等各种信息到CA(第三方认证中心)去申请数字证书，CA会通过一种单向hash算法(比如MD5)，生成一串摘要，这串摘要就是这堆信息的唯一标识，然后CA还会使用自己的私钥对摘要进行加密，连同我们自己服务器的公钥一同发送给我我们。 浏览器拿到数字签名后，会使用浏览器本地内置的CA公钥解开数字证书并验证，从而拿到正确的公钥。由于非对称加密性能低下，拿到公钥以后，客户端会随机生成一个对称密钥，使用这个公钥加密并发送给服务端，服务端用自己的私钥解开对称密钥，此后的加密连接就通过这个对称密钥进行对称加密。 综上所述，HTTPS在验证阶段使用非对称加密+第三方认证+数字签名获取正确的公钥，获取到正确的公钥后以对称加密的方式通信 参考资料：看图学HTTPS 前端安全什么是CSRF攻击 CSRF即Cross-site request forgery(跨站请求伪造)，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 假如黑客在自己的站点上放置了其他网站的外链，例如&quot;www.weibo.com/api，默认情况下，浏览器会带着weibo.com的cookie访问这个网址，如果用户已登录过该网站且网站没有对CSRF攻击进行防御，那么服务器就会认为是用户本人在调用此接口并执行相关操作，致使账号被劫持。 如何防御CSRF攻击 验证Token：浏览器请求服务器时，服务器返回一个token，每个请求都需要同时带上token和cookie才会被认为是合法请求 验证Referer：通过验证请求头的Referer来验证来源站点，但请求头很容易伪造 设置SameSite：设置cookie的SameSite，可以让cookie不随跨域请求发出，但浏览器兼容不一 什么是XSS攻击 XSS即Cross Site Scripting（跨站脚本），指的是通过利用网页开发时留下的漏洞，注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。常见的例如在评论区植入JS代码，用户进入评论页时代码被执行，造成页面被植入广告、账号信息被窃取 XSS攻击有哪些类型 存储型：即攻击被存储在服务端，常见的是在评论区插入攻击脚本，如果脚本被储存到服务端，那么所有看见对应评论的用户都会受到攻击。 反射型：攻击者将脚本混在URL里，服务端接收到URL将恶意代码当做参数取出并拼接在HTML里返回，浏览器解析此HTML后即执行恶意代码 DOM型：将攻击脚本写在URL中，诱导用户点击该URL，如果URL被解析，那么攻击脚本就会被运行。和前两者的差别主要在于DOM型攻击不经过服务端 如何防御XSS攻击 输入检查：对输入内容中的&lt;script&gt;&lt;iframe&gt;等标签进行转义或者过滤 设置httpOnly：很多XSS攻击目标都是窃取用户cookie伪造身份认证，设置此属性可防止JS获取cookie 开启CSP，即开启白名单，可阻止白名单以外的资源加载和运行 排序算法1. 手写冒泡排序 冒泡排序应该是很多人第一个接触的排序，比较简单，不展开讲解了 12345678910111213function bubbleSort(arr)&#123; for(let i = 0; i &lt; arr.length; i++) &#123; for(let j = 0; j &lt; arr.length - i - 1; j++) &#123; if(arr[j] &gt; arr[j+1]) &#123; let temp = arr[j] arr[j] = arr[j+1] arr[j+1] = temp &#125; &#125; &#125; return arr&#125;复制代码 2. 如何优化一个冒泡排序 冒泡排序总会执行(N-1)+(N-2)+(N-3)+..+2+1趟，但如果运行到当中某一趟时排序已经完成，或者输入的是一个有序数组，那么后边的比较就都是多余的，为了避免这种情况，我们增加一个flag，判断排序是否在中途就已经完成（也就是判断有无发生元素交换） 1234567891011121314151617function bubbleSort(arr)&#123; for(let i = 0; i &lt; arr.length; i++) &#123; let flag = true for(let j = 0; j &lt; arr.length - i - 1; j++) &#123; if(arr[j] &gt; arr[j+1]) &#123; flag = false let temp = arr[j] arr[j] = arr[j+1] arr[j+1] = temp &#125; &#125; // 这个flag的含义是：如果`某次循环`中没有交换过元素，那么意味着排序已经完成 if(flag)break; &#125; return arr&#125;复制代码 3. 手写快速排序 快排基本步骤： 选取基准元素 比基准元素小的元素放到左边，大的放右边 在左右子数组中重复步骤一二，直到数组只剩下一个元素 向上逐级合并数组 123456789101112function quickSort(arr) &#123; if(arr.length &lt;= 1) return arr //递归终止条件 const pivot = arr.length / 2 | 0 //基准点 const pivotValue = arr.splice(pivot, 1)[0] const leftArr = [] const rightArr = [] arr.forEach(val =&gt; &#123; val &gt; pivotValue ? rightArr.push(val) : leftArr.push(val) &#125;) return [ ...quickSort(leftArr), pivotValue, ...quickSort(rightArr)]&#125;复制代码 4. 如何优化一个快速排序 原地排序 上边这个快排只是让读者找找感觉，我们不能这样写快排，如果每次都开两个数组，会消耗很多内存空间，数据量大时可能造成内存溢出，我们要避免开新的内存空间，即原地完成排序 我们可以用元素交换来取代开新数组，在每一次分区的时候直接在原数组上交换元素，将小于基准数的元素挪到数组开头，以[5,1,4,2,3]为例： 我们定义一个pos指针, 标识等待置换的元素的位置, 然后逐一遍历数组元素, 遇到比基准数小的就和arr[pos]交换位置, 然后pos++ 代码实现： 12345678910111213141516171819202122232425function quickSort(arr, left, right) &#123; //这个left和right代表分区后“新数组”的区间下标，因为这里没有新开数组，所以需要left/right来确认新数组的位置 if (left &lt; right) &#123; let pos = left - 1 //pos即“被置换的位置”，第一趟为-1 for(let i = left; i &lt;= right; i++) &#123; //循环遍历数组，置换元素 let pivot = arr[right] //选取数组最后一位作为基准数， if(arr[i] &lt;= pivot) &#123; //若小于等于基准数，pos++，并置换元素, 这里使用小于等于而不是小于, 其实是为了避免因为重复数据而进入死循环 pos++ let temp = arr[pos] arr[pos] = arr[i] arr[i] = temp &#125; &#125; //一趟排序完成后，pos位置即基准数的位置，以pos的位置分割数组 quickSort(arr, left, pos - 1) quickSort(arr, pos + 1, right) &#125; return arr //数组只包含1或0个元素时(即left&gt;=right)，递归终止&#125;//使用var arr = [5,1,4,2,3]var start = 0;var end = arr.length - 1;quickSort(arr, start, end)复制代码 这个交换的过程还是需要一些时间理解消化的，详细分析可以看这篇：js算法-快速排序(Quicksort) 三路快排 上边这个快排还谈不上优化，应当说是快排的纠正写法，其实有两个问题我们还能优化一下： 有序数组的情况：如果输入的数组是有序的，而取基准点时也顺序取，就可能导致基准点一侧的子数组一直为空, 使时间复杂度退化到O(n2) 大量重复数据的情况：例如输入的数据是[1,2,2,2,2,3], 无论基准点取1、2还是3, 都会导致基准点两侧数组大小不平衡, 影响快排效率 对于第一个问题, 我们可以通过在取基准点的时候随机化来解决，对于第二个问题，我们可以使用三路快排的方式来优化，比方说对于上面的[1,2,2,2,2,3]，我们基准点取2，在分区的时候，将数组元素分为小于2|等于2|大于2三个区域，其中等于基准点的部分不再进入下一次排序, 这样就大大提高了快排效率 5. 手写归并排序 归并排序和快排的思路类似，都是递归分治，区别在于快排边分区边排序，而归并在分区完成后才会排序 12345678910111213141516171819function mergeSort(arr) &#123; if(arr.length &lt;= 1) return arr //数组元素被划分到剩1个时，递归终止 const midIndex = arr.length/2 | 0 const leftArr = arr.slice(0, midIndex) const rightArr = arr.slice(midIndex, arr.length) return merge(mergeSort(leftArr), mergeSort(rightArr)) //先划分，后合并&#125;//合并function merge(leftArr, rightArr) &#123; const result = [] while(leftArr.length &amp;&amp; rightArr.length) &#123; leftArr[0] &lt;= rightArr[0] ? result.push(leftArr.shift()) : result.push(rightArr.shift()) &#125; while(leftArr.length) result.push(leftArr.shift()) while(rightArr.length) result.push(rightArr.shift()) return result&#125;复制代码 6. 手写堆排序 堆是一棵特殊的树, 只要满足这棵树是完全二叉树和堆中每一个节点的值都大于或小于其左右孩子节点这两个条件, 那么就是一个堆, 根据堆中每一个节点的值都大于或小于其左右孩子节点, 又分为大根堆和小根堆 堆排序的流程： 初始化大(小)根堆，此时根节点为最大(小)值，将根节点与最后一个节点(数组最后一个元素)交换 除开最后一个节点，重新调整大(小)根堆，使根节点为最大(小)值 重复步骤二，直到堆中元素剩一个，排序完成 以[1,5,4,2,3]为例构筑大根堆： 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 堆排序const heapSort = array =&gt; &#123; // 我们用数组来储存这个大根堆,数组就是堆本身 // 初始化大顶堆，从第一个非叶子结点开始 for (let i = Math.floor(array.length / 2 - 1); i &gt;= 0; i--) &#123; heapify(array, i, array.length); &#125; // 排序，每一次 for 循环找出一个当前最大值，数组长度减一 for (let i = Math.floor(array.length - 1); i &gt; 0; i--) &#123; // 根节点与最后一个节点交换 swap(array, 0, i); // 从根节点开始调整，并且最后一个结点已经为当前最大值，不需要再参与比较，所以第三个参数为 i，即比较到最后一个结点前一个即可 heapify(array, 0, i); &#125; return array;&#125;;// 交换两个节点const swap = (array, i, j) =&gt; &#123; let temp = array[i]; array[i] = array[j]; array[j] = temp;&#125;;// 将 i 结点以下的堆整理为大顶堆，注意这一步实现的基础实际上是：// 假设结点 i 以下的子堆已经是一个大顶堆，heapify 函数实现的// 功能是实际上是：找到 结点 i 在包括结点 i 的堆中的正确位置。// 后面将写一个 for 循环，从第一个非叶子结点开始，对每一个非叶子结点// 都执行 heapify 操作，所以就满足了结点 i 以下的子堆已经是一大顶堆const heapify = (array, i, length) =&gt; &#123; let temp = array[i]; // 当前父节点 // j &lt; length 的目的是对结点 i 以下的结点全部做顺序调整 for (let j = 2 * i + 1; j &lt; length; j = 2 * j + 1) &#123; temp = array[i]; // 将 array[i] 取出，整个过程相当于找到 array[i] 应处于的位置 if (j + 1 &lt; length &amp;&amp; array[j] &lt; array[j + 1]) &#123; j++; // 找到两个孩子中较大的一个，再与父节点比较 &#125; if (temp &lt; array[j]) &#123; swap(array, i, j); // 如果父节点小于子节点:交换；否则跳出 i = j; // 交换后，temp 的下标变为 j &#125; else &#123; break; &#125; &#125;&#125;复制代码 参考资料: JS实现堆排序 7. 归并、快排、堆排有何区别 排序 时间复杂度(最好情况) 时间复杂度(最坏情况) 空间复杂度 稳定性 快速排序 O(nlogn) O(n^2) O(logn)~O(n) 不稳定 归并排序 O(nlogn) O(nlogn) O(n) 稳定 堆排序 O(nlogn) O(nlogn) O(1) 不稳定 其实从表格中我们可以看到，就时间复杂度而言，快排并没有很大优势，然而为什么快排会成为最常用的排序手段，这是因为时间复杂度只能说明随着数据量的增加，算法时间代价增长的趋势，并不直接代表实际执行时间，实际运行时间还包括了很多常数参数的差别，此外在面对不同类型数据(比如有序数据、大量重复数据)时，表现也不同，综合来说，快排的时间效率是最高的 在实际运用中, 并不只使用一种排序手段, 例如V8的Array.sort()就采取了当 n&lt;=10 时, 采用插入排序, 当 n&gt;10 时，采用三路快排的排序策略 设计模式设计模式有许多种，这里挑出几个常用的： 设计模式 描述 例子 单例模式 一个类只能构造出唯一实例 Redux/Vuex的store 工厂模式 对创建对象逻辑的封装 jQuery的$(selector) 观察者模式 当一个对象被修改时，会自动通知它的依赖对象 Redux的subscribe、Vue的双向绑定 装饰器模式 对类的包装，动态地拓展类的功能 React高阶组件、ES7 装饰器 适配器模式 兼容新旧接口，对类的包装 封装旧API 代理模式 控制对象的访问 事件代理、ES6的Proxy 1. 介绍一下单一职责原则和开放封闭原则 单一职责原则：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 开放封闭原则：核心的思想是软件实体（类、模块、函数等）是可扩展的、但不可修改的。也就是说,对扩展是开放的,而对修改是封闭的。 2. 单例模式单例模式即一个类只能构造出唯一实例，单例模式的意义在于共享、唯一，Redux/Vuex中的store、JQ的$或者业务场景中的购物车、登录框都是单例模式的应用 12345678910111213141516171819class SingletonLogin &#123; constructor(name,password)&#123; this.name = name this.password = password &#125; static getInstance(name,password)&#123; //判断对象是否已经被创建,若创建则返回旧对象 if(!this.instance)this.instance = new SingletonLogin(name,password) return this.instance &#125;&#125; let obj1 = SingletonLogin.getInstance(&apos;CXK&apos;,&apos;123&apos;)let obj2 = SingletonLogin.getInstance(&apos;CXK&apos;,&apos;321&apos;) console.log(obj1===obj2) // trueconsole.log(obj1) // &#123;name:CXK,password:123&#125;console.log(obj2) // 输出的依然是&#123;name:CXK,password:123&#125;复制代码 3. 工厂模式工厂模式即对创建对象逻辑的封装，或者可以简单理解为对new的封装，这种封装就像创建对象的工厂，故名工厂模式。工厂模式常见于大型项目，比如JQ的$对象，我们创建选择器对象时之所以没有new selector就是因为$()已经是一个工厂方法，其他例子例如React.createElement()、Vue.component()都是工厂模式的实现。工厂模式有多种：简单工厂模式、工厂方法模式、抽象工厂模式，这里只以简单工厂模式为例： 1234567891011121314151617181920class User &#123; constructor(name, auth) &#123; this.name = name this.auth = auth &#125;&#125;class UserFactory &#123; static createUser(name, auth) &#123; //工厂内部封装了创建对象的逻辑: //权限为admin时,auth=1, 权限为user时, auth为2 //使用者在外部创建对象时,不需要知道各个权限对应哪个字段, 不需要知道赋权的逻辑，只需要知道创建了一个管理员和用户 if(auth === &apos;admin&apos;) new User(name, 1) if(auth === &apos;user&apos;) new User(name, 2) &#125;&#125;const admin = UserFactory.createUser(&apos;cxk&apos;, &apos;admin&apos;);const user = UserFactory.createUser(&apos;cxk&apos;, &apos;user&apos;);复制代码 4. 观察者模式观察者模式算是前端最常用的设计模式了，观察者模式概念很简单：观察者监听被观察者的变化，被观察者发生改变时，通知所有的观察者。观察者模式被广泛用于监听事件的实现，有关观察者模式的详细应用，可以看我另一篇讲解Redux实现的文章 1234567891011121314151617181920212223242526272829//观察者class Observer &#123; constructor (fn) &#123; this.update = fn &#125;&#125;//被观察者class Subject &#123; constructor() &#123; this.observers = [] //观察者队列 &#125; addObserver(observer) &#123; this.observers.push(observer)//往观察者队列添加观察者 &#125; notify() &#123; //通知所有观察者,实际上是把观察者的update()都执行了一遍 this.observers.forEach(observer =&gt; &#123; observer.update() //依次取出观察者,并执行观察者的update方法 &#125;) &#125;&#125;var subject = new Subject() //被观察者const update = () =&gt; &#123;console.log(&apos;被观察者发出通知&apos;)&#125; //收到广播时要执行的方法var ob1 = new Observer(update) //观察者1var ob2 = new Observer(update) //观察者2subject.addObserver(ob1) //观察者1订阅subject的通知subject.addObserver(ob2) //观察者2订阅subject的通知subject.notify() //发出广播,执行所有观察者的update方法复制代码 有些文章也把观察者模式称为发布订阅模式，其实二者是有所区别的，发布订阅相较于观察者模式多一个调度中心。 5. 装饰器模式装饰器模式，可以理解为对类的一个包装，动态地拓展类的功能，ES7的装饰器语法以及React中的高阶组件（HoC）都是这一模式的实现。react-redux的connect()也运用了装饰器模式，这里以ES7的装饰器为例： 1234567891011function info(target) &#123; target.prototype.name = &apos;张三&apos; target.prototype.age = 10&#125;@infoclass Man &#123;&#125;let man = new Man()man.name // 张三复制代码 6. 适配器模式适配器模式，将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。我们在生活中就常常有使用适配器的场景，例如出境旅游插头插座不匹配，这时我们就需要使用转换插头，也就是适配器来帮我们解决问题。 12345678910111213141516171819class Adaptee &#123; test() &#123; return &apos;旧接口&apos; &#125;&#125; class Target &#123; constructor() &#123; this.adaptee = new Adaptee() &#125; test() &#123; let info = this.adaptee.test() return `适配$&#123;info&#125;` &#125;&#125; let target = new Target()console.log(target.test())复制代码 7. 代理模式代理模式，为一个对象找一个替代对象，以便对原对象进行访问。即在访问者与目标对象之间加一层代理，通过代理做授权和控制。最常见的例子是经纪人代理明星业务，假设你作为一个投资者，想联系明星打广告，那么你就需要先经过代理经纪人，经纪人对你的资质进行考察，并通知你明星排期，替明星本人过滤不必要的信息。事件代理、JQuery的$.proxy、ES6的proxy都是这一模式的实现，下面以ES6的proxy为例： 123456789101112131415161718192021222324const idol = &#123; name: &apos;蔡x抻&apos;, phone: 10086, price: 1000000 //报价&#125;const agent = new Proxy(idol, &#123; get: function(target) &#123; //拦截明星电话的请求,只提供经纪人电话 return &apos;经纪人电话:10010&apos; &#125;, set: function(target, key, value) &#123; if(key === &apos;price&apos; ) &#123; //经纪人过滤资质 if(value &lt; target.price) throw new Error(&apos;报价过低&apos;) target.price = value &#125; &#125;&#125;)agent.phone //经纪人电话:10010agent.price = 100 //Uncaught Error: 报价过低复制代码 HTML相关1. 说说HTML5在标签、属性、存储、API上的新特性 标签：新增语义化标签（aside / figure / section / header / footer / nav等），增加多媒体标签video和audio，使得样式和结构更加分离 属性：增强表单，主要是增强了input的type属性；meta增加charset以设置字符集；script增加async以异步加载脚本 存储：增加localStorage、sessionStorage和indexedDB，引入了application cache对web和应用进行缓存 API：增加拖放API、地理定位、SVG绘图、canvas绘图、Web Worker、WebSocket 2. doctype的作用是什么？声明文档类型，告知浏览器用什么文档标准解析这个文档： 怪异模式：浏览器使用自己的模式解析文档，不加doctype时默认为怪异模式 标准模式：浏览器以W3C的标准解析文档 3. 几种前端储存以及它们之间的区别 cookies： HTML5之前本地储存的主要方式，大小只有4k，HTTP请求头会自动带上cookie，兼容性好 localStorage：HTML5新特性，持久性存储，即使页面关闭也不会被清除，以键值对的方式存储，大小为5M sessionStorage：HTML5新特性，操作及大小同localStorage，和localStorage的区别在于sessionStorage在选项卡(页面)被关闭时即清除，且不同选项卡之间的sessionStorage不互通 IndexedDB： NoSQL型数据库，类比MongoDB，使用键值对进行储存，异步操作数据库，支持事务，储存空间可以在250MB以上，但是IndexedDB受同源策略限制 Web SQL：是在浏览器上模拟的关系型数据库，开发者可以通过SQL语句来操作Web SQL，是HTML5以外一套独立的规范，兼容性差 4. href和src有什么区别123href（hyperReference）`即超文本引用：当浏览器遇到href时，会并行的地下载资源，不会阻塞页面解析，例如我们使用`&lt;link&gt;`引入CSS，浏览器会并行地下载CSS而不阻塞页面解析. 因此我们在引入CSS时建议使用`&lt;link&gt;`而不是`@import&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;复制代码 src（resource）即资源，当浏览器遇到src时，会暂停页面解析，直到该资源下载或执行完毕，这也是script标签之所以放底部的原因 12&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;复制代码 5. meta有哪些属性，作用是什么meta标签用于描述网页的元信息，如网站作者、描述、关键词，meta通过name=xxx和content=xxx的形式来定义信息，常用设置如下： charset：定义HTML文档的字符集 12 &lt;meta charset=&quot;UTF-8&quot; &gt;复制代码 http-equiv：可用于模拟http请求头，可设置过期时间、缓存、刷新 12＜meta http-equiv=&quot;expires&quot; content=&quot;Wed, 20 Jun 2019 22:33:00 GMT&quot;＞复制代码 viewport：视口，用于控制页面宽高及缩放比例 12345&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;复制代码 6. viewport有哪些参数，作用是什么 width/height，宽高，默认宽度980px initial-scale，初始缩放比例，1~10 maximum-scale/minimum-scale，允许用户缩放的最大/小比例 user-scalable，用户是否可以缩放 (yes/no) 7. http-equive属性的作用和参数 expires，指定过期时间 progma，设置no-cache可以禁止缓存 refresh，定时刷新 set-cookie，可以设置cookie X-UA-Compatible，使用浏览器版本 apple-mobile-web-app-status-bar-style，针对WebApp全屏模式，隐藏状态栏/设置状态栏颜色 CSS相关清除浮动的方法 为什么要清除浮动：清除浮动是为了解决子元素浮动而导致父元素高度塌陷的问题 1.添加新元素 123456&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;!-- 添加一个空元素，利用css提供的clear:both清除浮动 --&gt; &lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;&lt;/div&gt; 复制代码 2.使用伪元素 12345678/* 对父元素添加伪元素 */.parent::after&#123; content: &quot;&quot;; display: block; height: 0; clear:both;&#125;复制代码 3.触发父元素BFC 123456789/* 触发父元素BFC */.parent &#123; overflow: hidden; /* float: left; */ /* position: absolute; */ /* display: inline-block */ /* 以上属性均可触发BFC */&#125;复制代码 介绍一下flex布局其实我本来还写了一节水平/垂直居中相关的，不过感觉内容过于基础还占长篇幅，所以删去了，作为一篇总结性的文章，这一小节也不应该从“flex是什么”开始讲，主轴、侧轴这些概念相信用过flex布局都知道，所以我们直接flex的几个属性讲起： 容器属性（使用在flex布局容器上的属性） justify-content 定义了子元素在主轴(横轴)上的对齐方式 12345.container &#123; justify-content: center | flex-start | flex-end | space-between | space-around; /* 主轴对齐方式：居中 | 左对齐(默认值) | 右对齐 | 两端对齐(子元素间边距相等) | 周围对齐(每个子元素两侧margin相等） */&#125;复制代码 align-items 定义了定义项目在交叉轴(竖轴)上对齐方式 12345.container &#123; align-items: center | flex-start | flex-end | baseline | stretch; /* 侧轴对齐方式：居中 | 上对齐 | 下对齐 | 项目的第一行文字的基线对齐 | 如果子元素未设置高度，将占满整个容器的高度（默认值） */&#125;复制代码 flex-direction 主轴(横轴)方向 12345.container &#123; flex-direction: row | row-reverse | column | column-reverse; /* 主轴方向：水平由左至右排列（默认值） | 水平由右向左 | 垂直由上至下 | 垂直由下至上 */&#125;复制代码 flex-wrap 换行方式 12345.container &#123; flex-wrap: nowrap | wrap | wrap-reverse; /* 换行方式：不换行（默认值） | 换行 | 反向换行 */&#125;复制代码 flex-flow flex-flow属性是flex-direction属性和flex-wrap的简写 12345.container &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; /* 默认值：row nowrap */&#125;复制代码 align-content 定义多根轴线的对齐方式 12345.container &#123; align-content: center | flex-start | flex-end | space-between | space-around | stretch; /* 默认值：与交叉轴的中点对齐 | 与交叉轴的起点对齐 | 与交叉轴的终点对齐 | 与交叉轴两端对齐 | 每根轴线两侧的间隔都相等 | （默认值）：轴线占满整个交叉轴 */&#125;复制代码 项目属性（使用在容器内子元素上的属性） flex-grow 定义项目的放大比例，默认为0，即使有剩余空间也不放大。如果所有子元素flex-grow为1，那么将等分剩余空间，如果某个子元素flex-grow为2，那么这个子元素将占据2倍的剩余空间 1234.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125;复制代码 flex-shrink 定义项目的缩小比例，默认为1，即如果空间不足，子元素将缩小。如果所有子元素flex-shrink都为1，某个子元素flex-shrink为0，那么该子元素将不缩小 1234.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125;复制代码 flex-basis 定义在分配多余空间之前，项目占据的主轴空间，默认auto，即子元素本来的大小，如果设定为一个固定的值，那么子元素将占据固定空间 1234.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125;复制代码 flex flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，即有剩余空间不放大，剩余空间不够将缩小，子元素占据自身大小 1234.item &#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125;复制代码 flex有两个快捷值：auto和none，分别代表1 1 auto（有剩余空间则平均分配，空间不够将等比缩小，子元素占据空间等于自身大小）和0 0 auto（有剩余空间也不分配，空间不够也不缩小，子元素占据空间等于自身大小） order 定义项目的排列顺序。数值越小，排列越靠前，默认为0 1234.item &#123; order: &lt;integer&gt;;&#125;复制代码 align-self 定义单个子元素的排列方式，例如align-items设置了center，使得所有子元素居中对齐，那么可以通过给某个子元素设置align-self来单独设置子元素的排序方式 1234.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125;复制代码 参考资料：阮一峰Flex布局 常见布局 编辑中，请稍等-_-|| 什么是BFCBFC全称 Block Formatting Context 即块级格式上下文，简单的说，BFC是页面上的一个隔离的独立容器，不受外界干扰或干扰外界 如何触发BFC float不为 none overflow的值不为 visible position 为 absolute 或 fixed display的值为 inline-block 或 table-cell 或 table-caption 或 grid BFC的渲染规则是什么 BFC是页面上的一个隔离的独立容器，不受外界干扰或干扰外界 计算BFC的高度时，浮动子元素也参与计算（即内部有浮动元素时也不会发生高度塌陷） BFC的区域不会与float的元素区域重叠 BFC内部的元素会在垂直方向上放置 BFC内部两个相邻元素的margin会发生重叠 BFC的应用场景 清除浮动：BFC内部的浮动元素会参与高度计算，因此可用于清除浮动，防止高度塌陷 避免某元素被浮动元素覆盖：BFC的区域不会与浮动元素的区域重叠 阻止外边距重叠：属于同一个BFC的两个相邻Box的margin会发生折叠，不同BFC不会发生折叠]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络基础知识]]></title>
    <url>%2F2019%2F10%2F24%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1）什么是链接？链接是指两个设备之间的连接。它包括用于一个设备能够与另一个设备通信的电缆类型和协议。2）OSI 参考模型的层次是什么？有 7 个 OSI 层：物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。3）什么是骨干网？骨干网络是集中的基础设施，旨在将不同的路由和数据分发到各种网络。它还处理带宽管理和各种通道。4）什么是 LAN？LAN 是局域网的缩写。它是指计算机与位于小物理位置的其他网络设备之间的连接。5）什么是节点？节点是指连接发生的点。它可以是作为网络一部分的计算机或设备。为了形成网络连接，需要两个或更多个节点。6）什么是路由器？路由器可以连接两个或更多网段。这些是在其路由表中存储信息的智能网络设备，例如路径，跳数等。有了这个信息，他们就可以确定数据传输的最佳路径。路由器在 OSI 网络层运行。7）什么是点对点链接？它是指网络上两台计算机之间的直接连接。除了将电缆连接到两台计算机的 NIC卡之外，点对点连接不需要任何其他网络设备。8）什么是匿名 FTP？匿名 FTP 是授予用户访问公共服务器中的文件的一种方式。允许访问这些服务器中的数据的用户不需要识别自己，而是以匿名访客身份登录。9）什么是子网掩码？子网掩码与 IP 地址组合，以识别两个部分：扩展网络地址和主机地址。像 IP 地址一样，子网掩码由 32 位组成。10）UTP 电缆允许的最大长度是多少？UTP 电缆的单段具有 90 到 100 米的允许长度。这种限制可以通过使用中继器和开关来克服11）什么是数据封装？数据封装是在通过网络传输信息之前将信息分解成更小的可管理块的过程。在这个过程中，源和目标地址与奇偶校验一起附加到标题中。12）描述网络拓扑网络拓扑是指计算机网络的布局。它显示了设备和电缆的物理布局，以及它们如何连接到彼此。13）什么是 VPN？VPN 意味着虚拟专用网络，这种技术允许通过网络（如 Internet）创建安全通道。例如，VPN 允许您建立到远程服务器的安全拨号连接。14）简要描述 NAT。NAT 是网络地址转换。这是一种协议，为公共网络上的多台计算机提供一种方式来共享到 Internet 的单一连接。15）OSI 参考模型下网络层的工作是什么？网络层负责数据路由，分组交换和网络拥塞控制。路由器在此层下运行。16）网络拓扑如何影响您在建立网络时的决策？网络拓扑决定了互连设备必须使用什么媒介。它还作为适用于设置的材料，连接器和终端的基础。17）什么是 RIP？RIP，路由信息协议的简称由路由器用于将数据从一个网络发送到另一个网络。它通过将其路由表广播到网络中的所有其他路由器来有效地管理路由数据。它以跳数为单位确定网络距离。18）什么是不同的方式来保护计算机网络？有几种方法可以做到这一点。在所有计算机上安装可靠和更新的防病毒程序。确保防火墙的设置和配置正确。用户认证也将有很大的帮助。所有这些组合将构成一个高度安全的网络。19）什么是 NIC？NIC 是网络接口卡（网卡）的缩写。这是连接到 PC 以连接到网络沈北。每个 NIC都有自己的 MAC 地址，用于标识网络上的 PC。20）什么是 WAN？WAN 代表广域网。它是地理上分散的计算机和设备的互连。它连接位于不同地区和国家/地区的网络。21）OSI 物理层的重要性是什么？物理层进行从数据位到电信号的转换，反之亦然。这是网络设备和电缆类型的考虑和设置。22）TCP/IP 下有多少层？有四层：网络层，互联网层，传输层和应用层。23）什么是代理服务器，它们如何保护计算机网络？代理服务器主要防止外部用户识别内部网络的 IP 地址。不知道正确的 IP 地址，甚至无法识别网络的物理位置。代理服务器可以使外部用户几乎看不到网络。24）OSI 会话层的功能是什么？该层为网络上的两个设备提供协议和方法，通过举行会话来相互通信。这包括设置会话，管理会话期间的信息交换以及终止会话时的解除过程。25）实施容错系统的重要性是什么？有限吗？容错系统确保持续的数据可用性。这是通过消除单点故障来实现的。但是，在某些情况下，这种类型的系统将无法保护数据，例如意外删除。26）10Base-T 是什么意思？10 是指数据传输速率，在这种情况下是 10Mbps。“Base”是指基带。T 表示双绞线，这是用于该网络的电缆。27）什么是私有 IP 地址？专用 IP 地址被分配用于内部网。这些地址用于内部网络，不能在外部公共网络上路由。这些确保内部网络之间不存在任何冲突，同时私有 IP 地址的范围同样可重复使用于多个内部网络，因为它们不会“看到”彼此。28）什么是 NOS？NOS 或网络操作系统是专门的软件，其主要任务是向计算机提供网络连接，以便能够与其他计算机和连接的设备进行通信。29）什么是 DoS？DoS 或拒绝服务攻击是试图阻止用户访问互联网或任何其他网络服务。这种攻击可能有不同的形式，由一群永久者组成。这样做的一个常见方法是使系统服务器过载，使其无法再处理合法流量，并将被强制重置。30）什么是 OSI，它在电脑网络中扮演什么角色？OSI（开放系统互连）作为数据通信的参考模型。它由 7 层组成，每层定义了网络设备如何相互连接和通信的特定方面。一层可以处理所使用的物理介质，而另一层则指示如何通过网络实际传输数据。31）电缆被屏蔽并具有双绞线的目的是什么？其主要目的是防止串扰。串扰是电磁干扰或噪声，可能影响通过电缆传输的数据。32）地址共享的优点是什么？通过使用地址转换而不是路由，地址共享提供了固有的安全性优势。这是因为互联网上的主机只能看到提供地址转换的计算机上的外部接口的公共 IP 地址，而不是内部网络上的私有 IP 地址。33）什么是 MAC 地址？MAC 或媒介访问控制，可以唯一地标识网络上的设备。它也被称为物理地址或以太网地址。MAC 地址由 6 个字节组成。34）在 OSI 参考模型方面，TCP/IP 应用层的等同层或多层是什么？TCP/IP 应用层实际上在 OSI 模型上具有三个对等体：会话层，表示层和应用层。35）如何识别给定 IP 地址的 IP 类？通过查看任何给定 IP 地址的第一个八位字节，您可以识别它是 A 类，B 类还是 C类。如果第一个八位字节以 0 位开头，则该地址为 Class A.如果以位 10 开头，则该地址为 B 类地址。如果从 110 开始，那么它是 C 类网络。36）OSPF 的主要目的是什么？OSPF 或开放最短路径优先，是使用路由表确定数据交换的最佳路径的链路状态路由协议。37）什么是防火墙？防火墙用于保护内部网络免受外部攻击。这些外部威胁可能是黑客谁想要窃取数据或计算机病毒，可以立即消除数据。它还可以防止来自外部网络的其他用户访问专用网络。38）描述星形拓扑星形拓扑由连接到节点的中央集线器组成。这是最简单的设置和维护之一。39）什么是网关？网关提供两个或多个网段之间的连接。它通常是运行网关软件并提供翻译服务的计算机。该翻译是允许不同系统在网络上通信的关键。40）星型拓扑的缺点是什么？星形拓扑的一个主要缺点是，一旦中央集线器或交换机被损坏，整个网络就变得不可用了。41）什么是 SLIP？SLIP 或串行线路接口协议实际上是在 UNIX 早期开发的旧协议。这是用于远程访问的协议之一。42）给出一些私有网络地址的例子。10.0.0.0，子网掩码为 255.0.0.0172.16.0.0，子网掩码为 255.240.0.0千人ccie认证交流群463904693领取最新CCIE考试题库CCIE 认证经验分享千人群：463904693192.168.0.0，子网掩码为 255.255.0.043）什么是 tracert？Tracert 是一个 Windows 实用程序，可用于跟踪从路由器到目标网络的数据采集的路由。它还显示了在整个传输路由期间采用的跳数。44）网络管理员的功能是什么？网络管理员有许多责任，可以总结为 3 个关键功能：安装网络，配置网络设置以及网络的维护/故障排除。45）描述对等网络的一个缺点。当您正在访问由网络上的某个工作站共享的资源时，该工作站的性能会降低。46）什么是混合网络？混合网络是利用客户端 - 服务器和对等体系结构的网络设置。47）什么是 DHCP？DHCP 是动态主机配置协议的缩写。其主要任务是自动为网络上的设备分配 IP 地址。它首先检查任何设备尚未占用的下一个可用地址，然后将其分配给网络设备。48）ARP 的主要工作是什么？ARP 或地址解析协议的主要任务是将已知的 IP 地址映射到 MAC 层地址。49）什么是 TCP/IP？TCP/IP 是传输控制协议/互联网协议的缩写。这是一组协议层，旨在在不同类型的计算机网络（也称为异构网络）上进行数据交换。50）如何使用路由器管理网络？路由器内置了控制台，可让您配置不同的设置，如安全和数据记录。您可以为计算机分配限制，例如允许访问的资源，或者可以浏览互联网的某一天的特定时间。您甚至可以对整个网络中看不到的网站施加限制。51）当您希望在不同平台（如 UNIX 系统和 Windows 服务器之间）传输文件时，可以应用什么协议？使用 FTP（文件传输协议）在这些不同的服务器之间进行文件传输。这是可能的，因为 FTP 是平台无关的。52）默认网关的使用是什么？默认网关提供了本地网络连接到外部网络的方法。用于连接外部网络的默认网关通常是外部路由器端口的地址。53）保护网络的一种方法是使用密码。什么可以被认为是好的密码？良好的密码不仅由字母组成，还包括字母和数字的组合。结合大小写字母的密码比使用所有大写字母或全部小写字母的密码有利。密码必须不能被黑客很容易猜到，比如日期，姓名，收藏夹等等。54）UTP 电缆的正确终止率是多少？非屏蔽双绞线网线的正常终止是 100 欧姆。55）什么是 netstat？Netstat 是一个命令行实用程序。它提供有关连接当前 TCP/IP 设置的有用信息。56）C 类网络中的网络 ID 数量是多少？对于 C 类网络，可用的网络 ID 位数为 21。可能的网络 ID 数目为 2，提高到 21或 2,097,152。每个网络 ID 的主机 ID 数量为 2，增加到 8 减去 2，或 254。57）使用长于规定长度的电缆时会发生什么？电缆太长会导致信号丢失。这意味着数据传输和接收将受到影响，因为信号长度下降。58）什么常见的软件问题可能导致网络缺陷？软件相关问题可以是以下任何一种或其组合：- 客户端服务器问题- 应用程序冲突- 配置错误- 协议不匹配- 安全问题- 用户政策和权利问题59）什么是 ICMP？ICMP 是 Internet 控制消息协议。它为 TCP/IP 协议栈内的协议提供消息传递和通信。这也是管理由 PING 等网络工具使用的错误信息的协议。60）什么是 Ping？Ping 是一个实用程序，允许您检查网络上的网络设备之间的连接。您可以使用其IP 地址或设备名称（如计算机名称）ping 设备。61）什么是点对点（P2P）？对等是不在服务器上回复的网络。该网络上的所有 PC 都是单独的工作站。62）什么是 DNS？DNS 是域名系统。该网络服务的主要功能是为 TCP/IP 地址解析提供主机名。63）光纤与其他介质有什么优势？光纤的一个主要优点是不太容易受到电气干扰。它还支持更高的带宽，意味着可以发送和接收更多的数据。长距离信号降级也非常小。64）集线器和交换机有什么区别？集线器充当多端口中继器。然而，随着越来越多的设备连接到它，它将无法有效地管理通过它的流量。交换机提供了一个更好的替代方案，可以提高性能，特别是在所有端口上预期有高流量时。65）Windows RRAS 服务支持的不同网络协议是什么？支持三种主要的网络协议：NetBEUI，TCP/IP 和 IPX。66）A，B 和 C 类网络中的最大网络和主机是什么？对于 A 类，有 126 个可能的网络和 16,777,214 个主机对于 B 类，有 16,384 个可能的网络和 65,534 个主机对于 C 类，有 2,097,152 个可能的网络和 254 个主机67）直通电缆的标准颜色顺序是什么？橙色/白色，橙色，绿色/白色，蓝色，蓝色/白色，绿色，棕色/白色，棕色。68）什么协议落在 TCP/IP 协议栈的应用层之下？以下是 TCP/IP 应用层协议：FTP，TFTP，Telnet 和 SMTP。69）您需要连接两台电脑进行文件共享。是否可以这样做，而不使用集线器或路由器？是的，您可以使用一根电缆将两台计算机连接在一起。在这种情况下可以使用交叉型电缆。在这种设置中，一条电缆的数据传输引脚连接到另一条电缆的数据接收引脚，反之亦然。70）什么是 ipconfig？Ipconfig 是一个常用于识别网络上计算机的地址信息的实用程序。它可以显示物理地址以及 IP 地址。71）直通和交叉电缆有什么区别？直通电缆用于将计算机连接到交换机，集线器或路由器。交叉电缆用于将两个类似设备连接在一起，如 PC 到 PC 或集线器到集线器。72）什么是客户端/服务器？客户端/服务器是一种类型的网络，其中一个或多个计算机充当服务器。服务器提供集中的资源库，如打印机和文件。客户端是指访问服务器的工作站。73）描述网络。网络是指用于数据通信的计算机和外围设备之间的互连。可以使用有线电缆或通过无线链路进行网络连接。74）将 NIC 卡从一台 PC 移动到另一台 PC 时，MAC 地址是否也被转移？是的，那是因为 MAC 地址是硬连线到 NIC 电路，而不是 PC。这也意味着当 NIC卡被另一个替换时，PC 可以具有不同的 MAC 地址。75）解释聚类支持群集支持是指网络操作系统在容错组中连接多台服务器的能力。这样做的主要目的是在一台服务器发生故障的情况下，集群中的下一个服务器将继续进行所有处理。76）在包含两个服务器和二十个工作站的网络中，安装防病毒程序的最佳位置是哪里？必须在所有服务器和工作站上安装防病毒程序，以确保保护。这是因为个人用户可以访问任何工作站，并在插入可移动硬盘驱动器或闪存驱动器时引入计算机病毒。77）描述以太网。以太网是当今使用的流行网络技术之一。它是在 20 世纪 70 年代初开发的，并且基于 IEEE 中规定的规范。以太网在局域网中使用。78）实现环形拓扑有什么缺点？如果网络上的一个工作站发生故障，可能会导致整个网络丢失。另一个缺点是，当需要在网络的特定部分进行调整和重新配置时，整个网络也必须被暂时关闭。79）CSMA/CD 和 CSMA/CA 有什么区别？CSMA/CD 或碰撞检测，每当碰撞发生时重新发送数据帧。CSMA/CA 或碰撞避免，将首先在数据传输之前广播意图发送。80）什么是 SMTP？SMTP 是简单邮件传输协议的缩写。该协议处理所有内部邮件，并在 TCP/IP 协议栈上提供必要的邮件传递服务。81）什么是组播路由？组播路由是一种有针对性的广播形式，将消息发送到所选择的用户组，而不是将其发送到子网上的所有用户。82）加密在网络上的重要性是什么？加密是将信息转换成用户不可读的代码的过程。然后使用秘密密钥或密码将其翻译或解密回其正常可读格式。加密有助于确保中途截获的信息仍然不可读，因为用户必须具有正确的密码或密钥。83）如何安排和显示 IP 地址？IP 地址显示为一系列由周期或点分隔的四位十进制数字。这种安排的另一个术语是点分十进制格式。一个例子是 192.168.101.284）解释认证的重要性。认证是在用户登录网络之前验证用户凭据的过程。它通常使用用户名和密码进行。这提供了限制来自网络上的有害入侵者的访问的安全手段。85）隧道模式是什么意思？这是一种数据交换模式，其中两个通信计算机本身不使用 IPSec。相反，将 LAN连接到中转网络的网关创建了一个使用 IPSec 协议来保护通过它的所有通信的虚拟隧道。86）建立 WAN 链路涉及的不同技术有哪些？模拟连接 - 使用常规电话线；数字连接 - 使用数字电话线；交换连接 - 使用发送方和接收方之间的多组链接来移动数据。87）网格拓扑的一个优点是什么？在一个链接失败的情况下，总会有另一个链接可用。网状拓扑实际上是最容错的网络拓扑之一。88）在排除计算机网络问题时，可能会发生什么常见的硬件相关问题？大部分网络由硬件组成。这些领域的问题可能包括硬盘故障，NIC 损坏甚至硬件启动。不正确的硬件配置也是其中一个疑难问题。89）可以做什么来修复信号衰减问题？处理这种问题的常见方法是使用中继器和集线器，因为它将有助于重新生成信号，从而防止信号丢失。检查电缆是否正确终止也是必须的。90）动态主机配置协议如何协助网络管理？网络管理员不必访问每台客户端计算机来配置静态 IP 地址，而是可以应用动态主机配置协议来创建称为可以动态分配给客户端的范围的 IP 地址池。91）解释网络概念的概况？配置文件是为每个用户设置的配置设置。例如，可以创建将用户置于组中的配置文件。92）什么是 Sneakernet？Sneakernet 被认为是最早的联网形式，其中使用可移动介质（如磁盘，磁带）物理传输数据。93）IEEE 在计算机网络中的作用是什么？IEEE 或电气和电子工程师学会是由电气和电子设备标准发布和管理的工程师组成的组织。这包括网络设备，网络接口，cablings 和连接器。94）TCP/IP Internet 层下有哪些协议？该层管理的协议有 4 种。这些是 ICMP，IGMP，IP 和 ARP。95）谈到网络，什么是权限？权限是指在网络上执行特定操作的授权许可。网络上的每个用户可以分配个人权限，具体取决于该用户必须允许的内容。96）建立 VLAN 的一个基本要求是什么？需要一个 VLAN，因为在交换机级别只有一个广播域，这意味着每当新用户连接时，该信息都会传播到整个网络。交换机上的 VLAN 有助于在交换机级别创建单独的广播域。它用于安全目的。97）什么是 IPv6？IPv6 或 Internet 协议版本 6 被开发以替代 IPv4。目前，IPv4 正在用于控制互联网流量，但 IPv4 已经饱和。IPv6 能够克服这个限制。98）什么是 RSA 算法？RSA 是 Rivest-Shamir-Adleman 算法的缩写。它是目前最常用的公钥加密算法。99）什么是网格拓扑？网格拓扑是一种设置，其中每个设备都直接连接到网络上的每个其他设备。因此，它要求每个设备具有至少两个网络连接。100）100Base-FX 网络的最大段长度是多少？使用 100Base-FX 的网段的最大允许长度为 412 米。整个网络的最大长度为 5 公里。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git命令]]></title>
    <url>%2F2019%2F10%2F17%2FGit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[命令大全reset–mixed：回退到某个版本，只保留源码，回退commit和stage信息–soft：回退到某个版本，只回退了commit的信息，不会恢复stage(如果还要提交，直接commit即可)–hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容HEAD^^：回退到前N次的提交，是上述的快捷表示branch[-v]：查看本地分支-D[本地分支名]：删除本地的分支–remote/-r：查看本地分支追踪的是哪一个远程分支-a：查看所有远程分支–track newLocalBranch remoteName/remoteBranch：取回远程主机的更新后，可以在它的基础上，使用gitcheckout命令创建一个新的分支，并使新建的本地分支，追踪指定的远程分支–set-upstream master origin/next：手动建立起追踪关系logdiffadd.添加当前”git status”下显示的除删除文件外的所有修改–all：添加所有修改，包括删除文件clonegit clone &lt;版本库的网址&gt; [本地目录名]：该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数-o克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定$git clone -o jQuery https://github.com/jquery/jquery.git$git remotejQueryremote不带选项的时候，git remote命令列出所有远程主机$git remoteorigin-v参看远程主机的网址$git remote -vorigin git@github.com:jquery/jquery.git(fetch)origin git@github.com:jquery/jquery.git(push)git remote show &lt;主机名&gt;查看该远程主机的详细信息，一般远程主机名默认命名为origingit remote add &lt;主机名&gt; &lt;网址&gt;用于添加远程主机git remote rm &lt;主机名&gt;用于删除远程主机git remote rename &lt;原主机名&gt; &lt;新主机名&gt;用于重命名远程主机名fetchgerritgit fetch &lt;远程主机名&gt;一旦远程主机的版本库有了更新(Git属于叫做commit)，需要将这些更新取回本地，这时就要用到git fetch命令，通常用来查看其他人的进程，对本地的代码没有影响。默认取回所有分支的更新git fetch &lt;远程主机名&gt; &lt;分支名&gt;指定分支名，取回特定分支的更新$git fetch origin master：取回oringin主机的master分支pullgit pull &lt;远程主机名&gt; &lt;远程分支名&gt;：&lt;本地分支名&gt;取回远程主机某个分支的更新，再与本地的指定分支合并git pull &lt;远程主机名&gt; &lt;远程分支名&gt;如果远程分支是与当前分支合并，则冒号后面的部分可以省略命令表示取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。$git fetch origin$git merge origin/nextgit pull origin如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名git pull如果当前分支只有一个追踪分支，连远程分支名都可以省略git pull -p如果远程主机删除了某个分支，默认情况下，git pull不会在拉取远程分支的时候，删除对应的本地分支。加上参数-p就会在本地删除远程已经删除的分支–rebase &lt;远程主机名&gt; &lt;远程分支名&gt; : &lt;本地分支名&gt;pushgit push &lt;远程主机名&gt; &lt;远程分支名&gt;：&lt;本地分支名&gt;*]]></content>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript6]]></title>
    <url>%2F2019%2F10%2F16%2FES6%2F</url>
    <content type="text"><![CDATA[Babel转码器Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。即，你可以用ES6的方式编写程序，又不用担心现有环境是否支持。下面是一个例子1234567//转码前input.map(item =&gt; item + 1);//转码后input.map(function(item)&#123; return item + 1;&#125;);上面的原始代码用了箭头函数，这个特性还没有得到广泛支持，Babel将其转为普通函数，就能在现有的JavaScript环境执行配置文件.babelrcBabel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。该文件用来设置转码规则和插件，基本格式如下1234&#123; "presets":[], "plugins":[]&#125;presets字段let和const命令let命令基本用法ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效1234567&#123; let a = 10; var b = 1;&#125;a //ReferenceError: a is not defined.b //1上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。for循环的计数器，就很合适使用let命令。1234for (let i = 0; i &lt; arr.length; i++) &#123;&#125;console.log(i);//ReferenceError: i is not defined上面代码的计数器i，只在for循环体内有效。下面的代码如果使用var，最后输出的是10。1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。不存在变量提升let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。12345console.log(foo); // 输出undefinedconsole.log(bar); // 报错ReferenceErrorvar foo = 2;let bar = 2;上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125;上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125;上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。12typeof x; // ReferenceErrorlet x;上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。1typeof undeclared_variable // "undefined"上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。有些“死区”比较隐蔽，不太容易发现。12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。1234function bar(x = 2, y = x) &#123; return [x, y];&#125;bar(); // [2, 2]ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。不允许重复声明let不允许在相同作用域内，重复声明同一个变量。1234567891011// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125;因此，不能在函数内部重新声明参数。123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125;块级作用域为什么需要块级作用域?ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景，内层变量可能会覆盖外层变量。12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = "hello world"; &#125;&#125;f(); // undefined上面代码中，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。第二种场景，用来计数的循环变量泄露为全局变量。1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。ES6的块级作用域let实际上为JavaScript新增了块级作用域。1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125;上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用var定义变量n，最后输出的值就是10。ES6允许块级作用域的任意嵌套。1&#123;&#123;&#123;&#123;&#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;;上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;;内层作用域可以定义外层作用域的同名变量。1234&#123;&#123;&#123;&#123; let insane = 'Hello World'; &#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;;块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。1234567891011// IIFE写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125;块级作用域与函数声明函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。12345678910// 情况一if (true) &#123; function f() &#123;&#125;&#125;// 情况二try &#123; function f() &#123;&#125;&#125; catch(e) &#123;&#125;上面代码的两种函数声明，根据ES5的规定都是非法的。但是，浏览器没有遵守这个规定，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。123456// ES5严格模式'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 报错ES6引入了块级作用域，明确允许在块级作用域之中声明函数。123456// ES6严格模式'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 不报错并且ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。123456789function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());上面代码在ES5中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。12345678// ES5版本function f() &#123; console.log('I am outside!'); &#125;(function () &#123; function f() &#123; console.log('I am inside!'); &#125; if (false) &#123; &#125; f();&#125;());ES6的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响，实际运行的代码如下。12345// ES6版本function f() &#123; console.log('I am outside!'); &#125;(function () &#123; f();&#125;());很显然，这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。允许在块级作用域内声明函数。函数声明类似于var，即会提升到全局作用域或函数作用域的头部。同时，函数声明还会提升到所在的块级作用域的头部。注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。前面那段代码，在Chrome环境下运行会报错。1234567891011// ES6的浏览器环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function上面的代码报错，是因为实际运行的是下面的代码。1234567891011// ES6的浏览器环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; var f = undefined; if (false) &#123; function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。123456789101112131415// 函数声明语句&#123; let a = 'secret'; function f() &#123; return a; &#125;&#125;// 函数表达式&#123; let a = 'secret'; let f = function () &#123; return a; &#125;;&#125;另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。12345678910// 不报错'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 报错'use strict';if (true) function f() &#123;&#125;const命令const声明一个只读的常量。一旦声明，常量的值就不能改变。12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable.上面代码表明改变常量的值会报错。const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。12const foo;// SyntaxError: Missing initializer in const declaration上面代码表示，对于const来说，只声明不赋值，就会报错。const的作用域与let命令相同：只在声明所在的块级作用域内有效。12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not definedconst命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。1234if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125;上面代码在常量MAX声明之前就调用，结果报错。const声明的常量，也与let一样不可重复声明。123456var message = "Hello!";let age = 25;// 以下两行都会报错const message = "Goodbye!";const age = 30;对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。1234567const foo = &#123;&#125;;foo.prop = 123;foo.prop// 123foo = &#123;&#125;; // TypeError: "foo" is read-only上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。下面是另一个例子。1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。如果真的想将对象冻结，应该使用Object.freeze方法。12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123;上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, value) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;;ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。全局对象的属性全局对象是最顶层的对象，在浏览器环境指的是window对象，在Node.js指的是global对象。ES5之中，全局对象的属性与全局变量是等价的。12345window.a = 1;a // 1a = 2;window.a // 2上面代码中，全局对象的属性赋值与全局变量的赋值，是同一件事。（对于Node来说，这一条只对REPL环境适用，模块环境之中，全局变量必须显式声明成global对象的属性。）未声明的全局变量，自动成为全局对象window的属性，这被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了两个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道，其次程序员很容易不知不觉地就创建了全局变量（比如打字出错）。另一方面，从语义上讲，语言的顶层对象是一个有实体含义的对象，也是不合适的。ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是全局对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与全局对象的属性脱钩。1234567var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined上面代码中，全局变量a由var命令声明，所以它是全局对象的属性；全局变量b由let命令声明，所以它不是全局对象的属性，返回undefined。变量的解构赋值数组的解构赋值基本用法ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。以前，为变量赋值，只能直接指定值。123var a = 1;var b = 2;var c = 3;ES6允许写成下面这样。1var [a, b, c] = [1, 2, 3];上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // []如果解构不成功，变量的值就等于undefined。12var [foo] = [];var [bar, foo] = [1];以上两种情况都属于解构不成功，foo的值都会等于undefined。另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4上面两个例子，都属于不完全解构，但是可以成功。如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;;上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。解构赋值不仅适用于var命令，也适用于let和const命令。123var [v1, v2, ..., vN ] = array;let [v1, v2, ..., vN ] = array;const [v1, v2, ..., vN ] = array;对于Set结构，也可以使用数组的解构赋值。12let [x, y, z] = new Set(["a", "b", "c"]);x // "a"事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。1234567891011function* fibs() &#123; var a = 0; var b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;var [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5上面代码中，fibs是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。注：Iterator：迭代器function*（构造器函数）： ES6中定义了一种新的函数.用function定义生成器函数,这种函数会返回一个generator对象.生成器函数在执行时可以暂停，然后又可以在暂停处接着执行。默认值解构赋值允许指定默认值。12345var [foo = true] = [];foo // true[x, y = 'b'] = ['a']; // x='a', y='b'[x, y = 'b'] = ['a', undefined]; // x='a', y='b'注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。12345var [x = 1] = [undefined];x // 1var [x = 1] = [null];x // null上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。12345function f() &#123; console.log('aaa');&#125;let [x = f()] = [1];上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。123456let x;if ([1][0] === undefined) &#123; x = f();&#125; else &#123; x = [1][0];&#125;默认值可以引用解构赋值的其他变量，但该变量必须已经声明。1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。对象的解构赋值解构不仅可以用于数组，还可以用于对象。123var &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。123456var &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"var &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。如果变量名与属性名不一致，必须写成下面这样。1234567var &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world'这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。1var &#123; foo: foo, bar: bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。123var &#123; foo: baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // "aaa"foo // error: foo is not defined上面代码中，真正被赋值的是变量baz，而不是模式foo。注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。12345let foo;let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration "foo"let baz;let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration "baz"上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。12345let foo;(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功上面代码中，let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。和数组一样，解构也可以用于嵌套结构的对象。12345678910var obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;var &#123; p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"注意，这时p是模式，不是变量，因此不会被赋值。12345678910111213var node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // error: loc is undefinedstart // error: start is undefined上面代码中，只有line是变量，loc和start都是模式，不会被赋值。下面是嵌套赋值的例子。1234567let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true]对象的解构也可以指定默认值。123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x:y = 3&#125; = &#123;&#125;;y // 3var &#123;x:y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong"默认值生效的条件是，对象的属性值严格等于undefined。12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null上面代码中，如果x属性等于null，就不严格相等于undefined，导致默认值不会生效。如果解构失败，变量的值等于undefined。12var &#123;foo&#125; = &#123;bar: 'baz'&#125;;foo // undefined如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。12// 报错var &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;;上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。12var _tmp = &#123;baz: 'baz'&#125;;_tmp.foo.bar // 报错如果要将一个已经声明的变量用于解构赋值，必须非常小心。1234// 错误的写法var x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。12// 正确的写法(&#123;x&#125; = &#123;x: 1&#125;);上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。123(&#123;&#125; = [true, false]);(&#123;&#125; = 'abc');(&#123;&#125; = []);上面的表达式虽然毫无意义，但是语法是合法的，可以执行。对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。1let &#123; log, sin, cos &#125; = Math;上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。1234var arr = [1, 2, 3];var &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3上面代码对数组进行对象结构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》一章。字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o"类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。12let &#123;length : len&#125; = 'hello';len // 5数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError函数参数的解构赋值函数的参数也可以使用解构赋值。12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。下面是另一个例子。12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ]函数参数的解构也可以使用默认值。12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0]上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。注意，下面的写法会得到不一样的结果。12345678function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0]上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。undefined就会触发函数参数的默认值。12[1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ]圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。不能使用原括号的情况以下三种解构赋值不得使用圆括号。（1）变量声明语句中，不能带有圆括号。123456789// 全部报错var [(a)] = [1];var &#123;x: (c)&#125; = &#123;&#125;;var (&#123;x: c&#125;) = &#123;&#125;;var &#123;(x: c)&#125; = &#123;&#125;;var &#123;(x): c&#125; = &#123;&#125;;var &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。（2）函数参数中，模式不能带有圆括号。函数参数也属于变量声明，因此不能带有圆括号。12// 报错function f([(z)]) &#123; return z; &#125;（3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。123// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5];上面代码将整个模式放在圆括号之中，导致报错。12// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;];上面代码将嵌套模式的一层，放在圆括号之中，导致报错。可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。用途变量的解构赋值用途很多。（1）交换变量的值1[x, y] = [y, x];上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。（2）从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;var [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;var &#123; foo, bar &#125; = example();（3）函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来。1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;);（4）提取JSON数据解构赋值对提取JSON对象中的数据，尤其有用。12345678910var jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309]上面代码可以快速提取JSON数据的值。（5）函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;;指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。（6）遍历Map结构任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。123456789var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world如果只想获取键名，或者只想获取键值，可以写成下面这样。123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125;（7）输入模块的指定方法加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map");字符串的扩展ES6加强了对Unicode的支持，并且扩展了字符串对象字符的Unicode表示法JavaScript允许采用\uxxxx形式表示一个字符，其中“xxxx”表示字符的码点。12"\u0061"// "a"但是，这种表示法只限于\u0000——\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。12345"\uD842\uDFB7"// "𠮷""\u20BB7"// " 7"上面代码表示，如果直接在“\u”后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript会理解成“\u20BB+7”。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。1234567891011"\u&#123;20BB7&#125;"// "𠮷""\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"// "ABC"let hello = 123;hell\u&#123;6F&#125; // 123'\u&#123;1F680&#125;' === '\uD83D\uDE80'// true上面代码中，最后一个例子表明，大括号表示法与四字节的UTF-16编码是等价的。有了这种表示法之后，JavaScript共有6种方法可以表示一个字符。12345'\z' === 'z' // true'\172' === 'z' // true'\x7A' === 'z' // true'\u007A' === 'z' // true'\u&#123;7A&#125;' === 'z' // trueProxy和ReflectProxy概述Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。12345678910var obj = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;!`); return Reflect.set(target, key, value, receiver); &#125;&#125;);上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。123456obj.count = 1// setting count!++obj.count// getting count!// setting count!// 2上面代码说明，Proxy实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。ES6原生提供Proxy构造函数，用来生成Proxy实例。1var proxy = new Proxy(target, handler);Proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。下面是另一个拦截读取属性行为的例子。123456789var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。如果handler没有设置任何拦截，那就等同于直接通向原对象。12345var target = &#123;&#125;;var handler = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.a = 'b';target.a // "b"上面代码中，handler是一个空对象，没有任何拦截效果，访问handeler就等同于访问target。一个技巧是将Proxy对象，设置到object.proxy属性，从而可以在object对象上调用。1var object = &#123; proxy: new Proxy(target, handler) &#125;;Proxy实例也可以作为其他对象的原型对象。12345678var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);let obj = Object.create(proxy);obj.time // 35上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。同一个拦截器函数，可以设置拦截多个操作。12345678910111213141516171819202122232425var handler = &#123; get: function(target, name) &#123; if (name === 'prototype') &#123; return Object.prototype; &#125; return 'Hello, ' + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123;value: args[1]&#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2) // 1new fproxy(1,2) // &#123;value: 2&#125;fproxy.prototype === Object.prototype // truefproxy.foo // "Hello, foo"下面是Proxy支持的拦截操作一览。对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。（1）get(target, propKey, receiver)拦截对象属性的读取，比如proxy.foo和proxy[&#39;foo&#39;]。最后一个参数receiver是一个对象，可选，参见下面Reflect.get的部分。（2）set(target, propKey, value, receiver)拦截对象属性的设置，比如proxy.foo = v或proxy[&#39;foo&#39;] = v，返回一个布尔值。（3）has(target, propKey)拦截propKey in proxy的操作，以及对象的hasOwnProperty方法，返回一个布尔值。（4）deleteProperty(target, propKey)拦截delete proxy[propKey]的操作，返回一个布尔值。（5）ownKeys(target)拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回对象所有自身的属性，而Object.keys()仅返回对象可遍历的属性。（6）getOwnPropertyDescriptor(target, propKey)拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。（7）defineProperty(target, propKey, propDesc)拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。（8）preventExtensions(target)拦截Object.preventExtensions(proxy)，返回一个布尔值。（9）getPrototypeOf(target)拦截Object.getPrototypeOf(proxy)，返回一个对象。（10）isExtensible(target)拦截Object.isExtensible(proxy)，返回一个布尔值。（11）setPrototypeOf(target, proto)拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。（12）apply(target, object, args)拦截Proxy实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。（13）construct(target, args)拦截Proxy实例作为构造函数调用的操作，比如new proxy(...args)。Promise了解 Promise 吗？JS异步编程的一种解决方案，比传统的解决方案————回调函数和事件————更合理更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果从语法上讲，promise是一个对象，从它可以获取异步操作的消息从本意上讲，它是承诺，承诺过一段时间会给一个结果promise有三种状态pending（等待态）fulfiled（成功态）rejected（失败态）状态一旦改变，就不会再变。创造promise实例后，会立即执行Promise的两个特点对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，英文意思就是“承诺”，表示其他手段无法改变一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。这与事件Event完全不同，事件的特点就是，如果你错过了它，再去监听，是得不到结果的。Promise的缺点无法取消Promise，一旦新建就会立即执行，无法中途取消如果不设置回调函数，Promise内部抛出的错误，不会反应到外部当处于Pending状态时，无法得知目前进展到哪一个阶段如果某些事件不断反复发生，一般来说，使用stream模式是比部署Promise更好的选择promise的写法new Promise(请求1)​ .then(请求2,(请求结果1))​ .then(请求3,(请求结果2))​ .then(请求4,(请求结果3))​ .then(请求5,(请求结果4))​ .then(请求6,(请求结果5))​ .catch(处理异常(异常信息))Promise的API123456789101112131415//根据传入的value不同而返回不同的值，如果传入的是对象的话则会返回一个状态为成功的promise对象promise.resolve(value)//根据传入的value不同而返回不同的值，如果传入的是对象的话则会返回一个状态为失败的promise对象promise.reject(value)Promise.prototype.then()Promise.prototype.catch()Promise.race()Promise.all()Promise 解决的痛点是什么？回调地狱，代码难以维护，常常第一个的函数的输出是第二个函数的输入这种现象promise可以支持多个并发的请求，获取并发请求中的数据promise可以解决可读性的问题，异步的嵌套带来的可读性的问题promise可以解决信任问题Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。setTimeout、事件监听、回调函数、Generator函数、async/awaitPromise 如何使用？创造一个Promise实例Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数可用Promise的try和catch方法预防异常12345678910111213let p = new Promise((resolve,reject) =&gt; &#123; //做异步操作 setTimeout(() =&gt;&#123; console.log(' 执行完成 '); resolve(' 成功 '); &#125;,2000);&#125;);Promise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：resolve：异步操作执行成功后的回调函数reject：异步操作执行失败后的回调函数Promise 常用的方法有哪些？它们的作用是什么？Promise.resolve(value)类方法，该方法返回一个以value值解析后的Promise对象如果这个值是个thenable（即带有then方法），返回Promise 在事件循环中的执行过程是怎样的？promise是事件循环中的微任务（micotask），在每次事情循环中会先清空了微任务的队列Promise 的业界实现都有哪些？Qbluebird能不能手写一个 Promise 的 polyfill123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112const PENDING = "pending";const RESOLVED = "resolved";const REJECTED = "rejected";function MyPromise(fn)&#123; const that = this; that.state = PENDING; that.value = null; that.resolvedCallbacks = []; that.rejectedCallbacks = []; function resolve(value)&#123; //判断传入的值是否为Promise类型 if( value instanceof MyPromise)&#123; return value.then(resolve,reject) &#125; //为了保证函数的执行顺序，需要将两个函数体代码使用setTimeout包裹起来 setTimeout(()=&gt;&#123; //只有等待状态才可以改变状态 if(that.state == PENDING)&#123; //将当前状态更改为对应状态，并且将传入的值赋值给value that.state = RESOLVED; that.value = value; //遍历回调函数组并执行 that.resolvedCallbacks.map(cb =&gt; cb(that.value)); &#125; &#125;,0) &#125; function reject(value)&#123; setTimeout(()=&gt;&#123; if(that.state == PENDING)&#123; that.state == REJECTED; that.value == value; that.rejectedCallbacks.map( cb =&gt; cb(that.value)); &#125; &#125;) &#125; try&#123; fn(resolve,reject) &#125;catch(e)&#123; reject(e) &#125;&#125;MyPromise.prototype.then = function(onFulfilled,onRejected)&#123; const that = this; //判断两个参数是否为函数类型，这两个参数是可选参数 //当参数不是函数类型时，需要创建一个函数赋值给对应的参数，同时也实现了透传 onFulfilled = typeof onFulfilled === 'function' ? onFulfilled:v =&gt; v; onRejected = typeof onRejected === 'function' ? onRejected:r =&gt; &#123;throw r&#125;; if(that.state === PENDING)&#123; //返回了一个新的Promise对象，并在Promise中传入一个函数 //规范规定，执行onFulfilled 或者 onRejected 函数会返回一个x，并且执行Promise解决过程，这是为了不同的Promise都可以兼容使用，比如JQuery的 Promise 能兼容 ES6 的Promise return(promise2 = new MyPromise((resolve,reject)=&gt;&#123; that.rejectedCallbacks.push(()=&gt;&#123; try&#123; const x = onFulfilled(that.value) resolutionProcedure(promise2,x,resolve,reject) &#125;catch(r)&#123; reject(r) &#125; &#125;); that.rejectedCallbacks.push(()=&gt;&#123; try &#123; const x = onRejected(that.value) resolutionProcedure(promise2, x, resolve, reject) &#125; catch (r) &#123; reject(r) &#125; &#125;); &#125;)) &#125; if(that.state === RESOLVED)&#123; return (promise2 = new MyPromise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; try &#123; const x = onFulfilled(that.value) resolutionProcedure(promise2, x, resolve, reject) &#125; catch (reason) &#123; reject(r) &#125; &#125;) &#125;)) &#125; if(that.state === REJECTED)&#123; return (promise2 = new MyPromise((resolve, reject)=&gt;&#123; try &#123; const x = onRejected(that.value); resolutionProcedure(promise2, x, resolve, reject) &#125;catch(r)&#123; reject(r) &#125; &#125;)) &#125; function resolutionProcedure(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; return reject(new TypeError('Error')) &#125; if (x instanceof MyPromise) &#123; x.then(function(value) &#123; resolutionProcedure(promise2, value, resolve, reject) &#125;, reject) &#125; &#125; &#125; // 创建一个实例 new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1) &#125;, 0) &#125;).then(value =&gt; &#123; console.log(value) &#125;)axios什么是axiosaxios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端执行GET请求123456789101112131415161718192021// 向具有指定ID的用户发出请求axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); // 也可以通过 params 对象传递参数axios.get('/user', &#123;params: &#123; ID: 12345&#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;);执行POST请求12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone'&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;);执行多个并发请求123456789101112function getUserAccount() &#123;return axios.get('/user/12345');&#125; function getUserPermissions() &#123;return axios.get('/user/12345/permissions');&#125; axios.all([getUserAccount(), getUserPermissions()]).then(axios.spread(function (acct, perms) &#123;//两个请求现已完成&#125;));axios API可以通过相关配置传递给axios来进行请求axios(config)123456789// 发送一个 POST 请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone'&#125;&#125;);axios(url[,config])12// 发送一个 GET 请求 (GET请求是默认请求模式)axios('/user/12345');请求方法别名为了方便起见,已经为所有支持的请求方法提供了别名axios.request (config)axios.get（url [，config]）axios.delete（url [，config]）axios.head（url [，config]）axios.post（url [，data [，config]]）axios.put（url [，data [，config]]）axios.patch（url [，data [，config]]）注意:当使用别名方法时,不需要在config中指定url,method和data属性并发帮助函数处理并发请求axios.all（iterable）axios.spread（callback）创建实例使用自定义配置创建axios的新实例axios.create（[config]）12345var instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;);实例方法axios＃request（config）axios＃get（url [，config]）axios＃delete（url [，config]）axios＃head（url [，config]）axios＃post（url [，data [，config]]）axios＃put（url [，data [，config]]）axios＃patch（url [，data [，config]]）请求拦截TIPSErrorReferenceError(引用错误)：代表当一个不存在变量被引用时发生的错误，在作用域中找不到TypeError(类型错误)：在作用域中找到了但是做了它不可能做的事情]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端知识点]]></title>
    <url>%2F2019%2F09%2F28%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1、CSS禁用鼠标点击12345.disabled &#123; pointer-events: none; cursor: default; opacity: 0.6;&#125;2、get/post的理解和他们之间的区别http超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。HTTP的工作方式是客户机与服务器之间的请求-应答协议。web浏览器可能是客户端也可能作为服务器端。HTTP方法：HEAD：与GET相同，但只返回HTTP报头，不返回文档主体PUT：上传指定的URI表示DELETE：删除指定的资源OPTIONS：返回服务器的支持的HTTP方法CONNECT：把请求连接转换到透明的TCP/IP通道POST：向指定的资源提交要被处理的数据1234// 查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2GET：从指定的资源请求数据https://juejin.im/post/5d8989296fb9a06b1f147070?utm_source=gold_browser_extension]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端面试题]]></title>
    <url>%2F2019%2F09%2F28%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前端综合http从输入地址开始到浏览器渲染做了什么？浏览器进行地址解析浏览器得到url地址后开始解析，获取该地址的端口号、域名、协议、路径等信息有些信息不是必须的，浏览器会默认补齐将解析的域名进行dns解析将第一步的解析信息转换成对应的IP地址，这就是DNS解析，分为以下步骤首先查看浏览器中是否有对应的DNS缓存，如果有则直接使用如果没有查看操作系统DNS是否有对应的值（ｈｏｓｔ文件）如果还是没有则向本地DNS服务商发送查询请求如果仍然没有则直接Root Server域名服务器请求解析通过IP地址寻找服务器地址获取到IP地址后寻找IP地址对应的服务器与服务器进行三次握手建立连接浏览器请求报文到达服务器之后，服务器接口会对请求报文进行处理，执行接口对应的代码，处理完成响应客户端。由于ｈｔｔｐ是无状态的，正常情况下，客户端收到响应后就会直接断开连接，然后一次HTTP事务就完成了。但是ｈｔｔｐ １.０有一个ｋｅｅｐ－ａｌｉｖｅ的请求字段，可以在一定时间内不断开（有时时间甚至很长）。HTTP １.１直接就默认开启了ｋｅｅｐ－ａｌｉｖｅ选项。这导致了一个严重的后果是服务器已经处理完请求，但是客户端不会主动断开连接，这就导致服务器资源一直被占用。这时服务器就不得不自己主动断开连接，而主动断开连接，而主动断开连接的一方会出现TIME_WAIT,占用连接池，这就是产生SYN Flood攻击的原因浏览器发送数据，等待服务器的响应服务器响应并返回数据浏览器接受到数据浏览器开始渲染页面JavascriptJavaScript基本数据类型有哪些NumberBooleanStringNullUnderfinedSymbol＝＝与＝＝＝的区别＝＝会自动转换数据类型再进行比较＝＝＝不会转换数据类型，数据类型不一致时直接false，一致再比较事件委托代理在构建应用程序时，有时需要将事件绑定到页面上的按钮、文本或图像，以便在用户与元素交互时执行某些操作。如果我们以一个简单的代办事项列表为例，面试官可能会告诉你，当用户点击列表中的一个列表项时执行某些操作。他们希望你用JavaScript实现这个功能，假设设有如下HTML代码：123456&lt;ul id="todo-app"&gt; &lt;li class="item"&gt;Walk the dog&lt;/li&gt; &lt;li class="item"&gt;Pay bills&lt;/li&gt; &lt;li class="item"&gt;Make dinner&lt;/li&gt; &lt;li class="item"&gt;Code for one hour&lt;/li&gt;&lt;/ul&gt;ＮｏｄｅＪＳnodejs导出导入原理？]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js]]></title>
    <url>%2F2019%2F08%2F13%2FNode-js%2F</url>
    <content type="text"><![CDATA[基础知识TIPSNodeJS访问数据库mysqljs12345678910var mysql = require('mysql');var connection = mysql.createConnection(mysqlConfig);connection.connect();connection.query('SELECT 1 + 1 AS solution',function(error,results,fields)&#123; if(error)throw error; console.log('The solution is:',results[0].solution);&#125;);connection.end();egg-mysql123456const results = yield app.mysql.select('posts',&#123; where:&#123;status:'draft'&#125;, orders:[['create_at','desc'],['id','desc']], limit:10, offset:0&#125;);写SQL实现一个服务端分页123456789101112131415161718192021222324// 拼接各种条件let whereSql = 'where online_version is not null and state &lt;&gt; 1';if (scope == 'only') &#123; whereSql += ' and use_scope like "%' + query.use_scope + '%"';&#125;whereSql += handleIn(query) + handleEqual(query) + handleLike(query);// 取得全部数据条数const sqlTotal = 'select count(*) as total from component' + whereSql;const resultTotal = yield this.app.mysql.query(sqlTotal, values);// 取得当前页数据let sqlSelect = 'select * from component'sqlSelect += whereSql;sqlSelect += ' order by modified_time desc, id desc limit ';sqlSelect += (pageIndex - 1) * pageSize + ',' + pageSize;const resultList = yield this.app.mysql.query(sqlSelect, values);// 返回分页结果const result = &#123; list: resultList, total: resultTotal[0].total,&#125;;return result;那有没有更简洁的方法去操作数据库呢，答案是肯定的社区有很多优秀的orm或sql builder的类库比如objection、sequelize、knexjs、squel等。同步太多容易造成异步回调黑洞面试题nodejs导出导入原理？？]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery]]></title>
    <url>%2F2019%2F08%2F12%2FJQuery%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS]]></title>
    <url>%2F2019%2F08%2F12%2FAngularJS%2F</url>
    <content type="text"><![CDATA[概述AngularJS是什么AngularJs（后面就简称ng了）是一个用于设计动态web应用的结构框架核心是对HTML标签的增强使你能够用标签完成一部分页面逻辑AngularJS是一个 MV* 框架，最适于开发客户端的单页面应用重要功能与特性双向的数据绑定模板MVCMVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发MVC是一个设计模式，它强制性的使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务优点：可以为一个模型在运行时同时建立和使用多个视图。变化-传播机制可以确保所有相关的视图及时得到模型数据变化，从而使所有关联的视图和控制器做到行为同步视图与控制器的可接插性，允许更换视图和控制器对象，而且可以根据需求动态的打开或关闭、甚至在运行期间进行对象替换模型的可移植性。因为模型是独立于视图的，所以可以把一个模型独立地移植到新的平台工作。需要做的只是在新平台上对视图和控制器进行新的修改潜在的框架结构。可以基于此模型建立应用程序框架，不仅仅是用在设计界面的设计中缺点：增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能目前，一般高级的界面工具或构造器不支持模式。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成MVC使用的困难服务与依赖注入AngularJS服务其作用就是对外提供某个特定的功能AngularJS拥有内建的依赖注入（DI）子系统，可以帮助开发人员更容易的开发，理解和测试应用指令scopes module controllerscopes$scope是一个把view（一个DOM元素）连结到controller上的对象每一个Angular应用都会有一个 $rootScope。这个 $rootScope 是最顶级的scope，它对应着含有 ng-app 指令属性的那个DOM元素。TIPSfactory service provider之间的关系factory把 service 的方法和数据放在一个对象里，并返回这个对象service通过构造函数方式创建 service，返回一个实例化对象provider创建一个可通过 config 配置的 service，$get 中返回的，就是用 factory 创建 service 的内容]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql]]></title>
    <url>%2F2019%2F07%2F24%2FMySql%2F</url>
    <content type="text"><![CDATA[概念数据库数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。RDBMS 即关系数据库管理系统(Relational Database Management System)的特点：1.数据以表格的形式出现2.每行为各种记录名称3.每列为记录名称所对应的数据域4.许多的行和列组成一张表单5.若干的表单组成databaseRDBMS术语数据库: 数据库是一些关联表的集合。数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。列: 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。外键：外键用于关联两个表。复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。MySql常用命令行连接数据库格式：mysql -h主机地址 -u用户名 －p用户密码查看数据库：show databases;选择并进入数据库use databasename;查看表show tables;查看表结构desc tablename;查看表数据select * from tablename;where条件语句select student_age from pre_student where student_age &gt; 14 and student_age &lt; 18;in枚举查询SELECT * FROM pre_article WHERE aid IN (1, 3, 5)%模糊查询SELECT FROM pre_user WHERE username like “%张%”; // 所有SELECT FROM pre_user WHERE username like “%张”; // 小张张SELECT * FROM pre_user WHERE username like “_张%”; // 小张张 大张伟%：代替一个或多个字符_：代替一个字符limit限制SELECT * FROM table LIMIT 5; // 直接查条数SELECT * FROM table LIMIT （index, length）; // 以哪个下标开始，共多少条数据。order by排序降序：desc升序：ascselect * from pre_student order by student_age desc插入数据INSERT INTO user (username,password) VALUES (‘admin’,’123456’);修改数据(必须指定条件 where，不然全部都会被修改到！)UPDATE user SET username = ‘admin1’, passwd =’12345678’ WHERE uid = 10删除数据DELETE FROM user WHERE uid = 10配置my.ini1234567891011121314151617[client]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\web\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\web\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP]]></title>
    <url>%2F2019%2F07%2F24%2FPHP%2F</url>
    <content type="text"><![CDATA[mysql_connect()连接数据库mysql_select_db选择数据库mysql_fetch_assoc()获取结果集mysql_query()执行sql语句phpintval() 函数用于获取变量的整数值。intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2F2019%2F07%2F07%2FJavaScript%2F</url>
    <content type="text"><![CDATA[基础知识TIPSjs实现继承的几种方式(https://www.cnblogs.com/chaixiaozhi/p/8515087.html)1、原型链继承核心：将父类的实例作为子类的原型缺点：父类新增原型方法/原型属性，子类都能访问到，父类一变其他的都变了123456789101112131415161718192021222324252627function Person(name)&#123; this name = name;&#125;;Person prototype.getName = function()&#123;//对原型进行扩展 return this.name;&#125;;function Parent(age)&#123; this.age = age;&#125;;Parent.prototype = new Person('老明');//关键//通过构造器函数创建出一个新对象，把老对象的东西拿过来Parent.prototype.getAge = function()&#123; return this.age;&#125;;//Parent.prototype.getName = function()&#123; //可以重写父类继承来的方法，会优先调用自己的// console.log(222);//&#125;;var result = new Parent(22);console.log(result.getName());//老明//调用了从Person原型中继承来的方法(继承到了当前对象的原型中) console.log(result.getAge());//22//调用了从Parent原型中扩展来的方法&#125;2、构造继承基本思想借用构造函数的基本思想就是利用call或者apply把父类中通过this指定的属性和方法复制(借用)到子类创建的实例中因为this对象是运行时基于函数的执行环境绑定的。也就是说，在全局中，this等于Windows，而当函数被作为某个对象的方法调用时，this等于那个对象call、apply方法可将与一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象所以，这个借用构造函数就是，new对象的时候(new创建的时候，this指向创建的这个实例)，]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS]]></title>
    <url>%2F2019%2F06%2F05%2FCSS%2F</url>
    <content type="text"><![CDATA[CSS命名规范常规命名头：header内容：content/container尾：footer导航：nav侧栏：sidebar栏目：column页面外围控制整体布局宽度：wrapper左右中：left right center登录条：loginbar标志：logo广告：banner页面主体：main热点：hot新闻：news下载：download子导航：subnav菜单：menu子菜单：submenu搜索：search友情链接：friendlink页脚：footer版权：copyright滚动：scroll内容：content标签页：tab文章列表：list提示信息：msg小技巧：tips栏目标题：title加入：joinus指南：guild服务：service注册：regsiter状态态：status投票：vote合作伙伴：partner注释的写法/ Footer /内容区/ End Footer /id的命名容器: container页头：header内容：content/container页面主体：main页尾：footer导航：nav侧栏：sidebar栏目：column页面外围控制整体布局宽度：wrapper左右中：left right center页面结构容器: container页头：header内容：content/container页面主体：main页尾：footer导航：nav侧栏：sidebar栏目：column页面外围控制整体布局宽度：wrapper左右中：left right center导航导航：nav主导航：mainbav子导航：subnav顶导航：topnav边导航：sidebar左导航：leftsidebar右导航：rightsidebar菜单：menu子菜单：submenu标题: title摘要: summary功能标志：logo广告：banner登陆：login登录条：loginbar注册：regsiter搜索：search功能区：shop标题：title加入：joinus状态：status按钮：btn滚动：scroll标签页：tab文章列表：list提示信息：msg当前的: current小技巧：tips图标: icon注释：note指南：guild服务：service热点：hot新闻：news下载：download投票：vote合作伙伴：partner友情链接：link版权：copyrightclass的命名(1)颜色:使用颜色的名称或者16进制代码,如123.red &#123; color: red; &#125;.f60 &#123; color: #f60; &#125;.ff8600 &#123; color: #ff8600; &#125;(2)字体大小,直接使用”font+字体大小”作为名称,如12.font12px &#123; font-size: 12px; &#125;.font9pt &#123;font-size: 9pt; &#125;(3)对齐样式,使用对齐目标的英文名称,如12.left &#123; float:left; &#125;.bottom &#123; float:bottom; &#125;(4)标题栏样式,使用”类别+功能”的方式命名,如12.barnews &#123; &#125;.barproduct &#123; &#125;注意事项1.一律小写;2.尽量用英文;3.不加中杠和下划线;4.尽量不缩写，除非一看就明白的单词.主要的 master.css模块 module.css基本共用 base.css布局，版面 layout.css主题 themes.css专栏 columns.css文字 font.css表单 forms.css补丁 mend.css打印 print.cssCSS样式字体样式font-family=“微软雅黑”;当指定多种字体时，用“，”分隔每种字体的名称当字体名称包含两个以上分开的单词是，用“”把该字体名称括起来。当样式规则外已经有“”时,用‘’代替“”。color=#ccc;/设置字体颜色/16进制RGBAtext-decoration:underline;/字体加下划线/text-decoration:none;/去下划线/font-size:14px;/字体的大小/font-style:normal正常状态italic斜体字oblique 斜体和正常状态之间font-weight:number(100～900)lighter（细体）bold(粗体)bolder（特粗体）text-transform:uppercase 所有文字大写显示lowercase:所有文字小写显示capitalize 每个单词的头字母大写none 不继承母体的文字变形参数text-decoration:underline 为文字加下划线overline 为文字加上划线line-through 为文字加删除线blink 使文字闪烁none 不显示上叙任何效果可以用font 属性全部定位p{font:italic bold 12pt;}边框与填充样式margin：外边距与边距的距离(margin-top margin-left margin-bottom margin-left)取值可以是：auto默认百分比或者具体的值：取值可以是一个或者两个或者三个或者四个（每个都具有不同的含义）。4:上右下左3：上，左右，下2：上下，左右padding内边距复合属性填充（指用白值填充）和margin的用法一样。border-styleborder-top-style:上边框样式border-right-style:右边框样式border-bottom-style:底边框样式border-left-style:左边框样式取值：none 不现实边框，为默认值dotted 点线（电线）dashed 虚线，也称短线solid 实线double 双实线groove 边框带有立体感的沟槽ridge 边框成脊形inset 使整个表框凹陷，即在边框内嵌入一个立体边框outset 使整个边框凸起，即在边框外嵌入一个立体边框border-color=“#ccc”;/设置边框颜色/border-width：border-top-width:上边框宽度border-right-width:右边框宽度border-bottom-width:底边框宽度border-left-width:左边框宽度取值为：medium 默认宽度thin 细边框thick 粗边框border:1px solid #999;/添加一条边框/border-top：上边框border—right：右边框border—bottom：底边框border-left：左边框背景样式background-color背景颜色background-image背景图片background-repeat:repeat 表示图像从水平和垂直角度平铺no-repeat 不重复平铺背景图片repeat-x 使图片只在水平方向上平铺repeat-y 使图片只在垂直方向上平铺background-attachment 参数fixed 网页滚动时，背景图片相对浏览器而言固定不动scroll 网页滚动时，背景图片相对浏览器而言一起滚动background-postion ：（背景定位）top 相对前景对象顶对齐bottom 相对前景对象底对齐left 相对前景对象左对齐right 相对前景对象右对齐center 相对前景对象中心对齐可以直接用 background 复合属性来确定式样示例：table{background:#001122 url(zhouliang.jpg) no-repeat bottom right}文本样式word-spacing:英文单词间距取值：normal或者是单位像素letter-spacing:英文字母间距取值可以是：normal或者是单位像素line-height:行距可以是精确的值，也可以是百分比text-aglin:文本水平排列left: 左对齐right：右对齐center: 居中justify:相对左右对齐。注意到：text-aglin 是块级属性，只能用于p、blockquqte、ul、h1-h6等表示vertical-align:文本垂直排列top 顶对齐 bottom 底部对齐 text-top 相对文本顶对齐text-bottom相对文本底对齐 baseline:基准线对齐 middle 中心线对齐sub 以下标的形式对齐 sup 以上标的形式对齐,相对于元素行高属性的百分比text-indent：文本缩进缩进距离必须是值或者百分比white-spacenormal：合并连续的多个空格pre：保留原样式nowrap：不换行，直到遇到br标签text-decoraitionnone :表示不对文本进行修饰，也是默认值，underline:表示对文字添加下划线overline:表示添加上划线line-through:表示对文本添加删除线blink:表示文字具有闪烁效果text-transform：文本转换none:表示原有值capitalize:使每个字的第一个字母大写uppercase:大写lowercase:小写定位样式postionabsolute 采用绝对定位（分别用四个边框来定位）relative 采用相对定位（也得用四个边框来设定位置）static 默认值left/top/width/height设置值可以是z-index也就是元素的堆叠,大的在上，小的在下。默认是按照先后顺序取值auto默认值，表示它遵循其父对象的定位属性如果设置为数字,必须是无单位的正整数，可以取负值，但是一般为正数,一般数字为1时间是最底层布局样式visibility 可视性inherit：表示对象继承父本的继承性。visible:表示对象可见hidden：表示对象隐藏视口width=device-width ：表示宽度是设备屏幕的宽度initial-scale=1.0：表示初始的缩放比例minimum-scale=0.5：表示最小的缩放比例maximum-scale=2.0：表示最大的缩放比例user-scalable=yes：表示用户是否可以调整缩放比例display设置或检索对象是否及如何显示block、inline、list-item、noneclip可视区域auto表示对象不裁剪rect(数值表示)(一般有四个设置值：方向定位于上右下左的顺序，一般以左上角(0,0)坐标计算4个偏移数值。其中 任何一个值都可以用auto代替)overflow超出范围isible 扩大浏览器hidden 裁剪掉多余的文本scroll 滚动条auto 当有多余的时候才显示滚动条float 浮动属性left表示文字浮在元素左侧right 表示文字浮在元素右侧none 默认值，表示不浮动。重点clear ：表示指定一个元素周围是都允许有其他元素漂浮在它的周围。left ,right,none,both;指要清除本元素四周的浮动对象page-break-beforealways 是否强制分页page-break-afteralways 打印后设置是否强制分页width和height表示层的宽度与高度设置值为 auto|数值列表样式list-style-type指显示于列表项前的标识符号none 表示不显示列表符号list-style-postion列表缩进inside 列表内容和列表标识符号处在不同垂直位置，在符号内侧outside 列表内容和列表标识符号处在同一垂直位置list-style-image用图片符号作为链接标题none 表示不指定图像url(网页地址) 指定图片位置list-style复合属性：实现以上三种光标样式cursor当点击某个内容时，鼠标显示其他的图形style=”cursor:hand” 手形style=”cursor:crosshair” 十字形CSS尺寸tips任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合:1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了绝对单位in英寸（Inch），绝对长度单位pt绝对长度单位。点（Point）。1in = 2.54cm = 25.4 mm = 72pt = 6pcpc绝对长度单位。派卡（Pica）。相当于我国新四号铅字的尺寸。​ 1in = 2.54cm = 25.4 mm = 72pt = 6pccm绝对长度单位。厘米（Centimeter）。​ 1in = 2.54cm = 25.4 mm = 72pt = 6pcmm绝对长度单位。毫米（Millimeter）。​ 1in = 2.54cm = 25.4 mm = 72pt = 6pc相对长度单位px相对长度单位。像素（Pixel）em相对长度单位。相对于当前对象内文本的字体尺寸ex相对长度单位。相对于字符“x”的高度。此高度通常为字体尺寸的一半。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。rem区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素选择使用什么字体单位主要由你的项目来决定，如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破冰行动-蔡永强]]></title>
    <url>%2F2019%2F06%2F02%2F%E7%A0%B4%E5%86%B0%E8%A1%8C%E5%8A%A8-%E8%94%A1%E6%B0%B8%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[[内容源于网络]我国著名语言艺术家、职场生存大师、实证主义理论家思想家、东山公安局最佳辩手、看破不说破大师、金句boy蔡永强语录言归正传。蔡永强的自述光芒四射，但关键信息点却落在蔡永强与李维民的对话上。先来看这三段对话设计。对话一：李维民：“你让谁秘密接触林三宝？”蔡永强：“就我自己，局里队里没有任何人知道我们以何种方式联络。什么时间什么地点，他们一概不知。”李维民：“为什么？”蔡永强：“刚才说过，公安局是一个情报中心。”对话二：李维民：“你对马云波不相信？”蔡永强：“我有这方面的暗示吗？”对话三：李维民：“你对林三宝车祸身亡怎么看？”蔡永强：“无非两种结论，一种是正常的车祸，他运气差，我们运气也差。另外一种结论，他被杀人灭口了，我们运气更差，因为没有证据。”李维民：“你倾向于哪一边？”蔡永强：“我没有倾向性，证据说话。”李维民：“你有点言不由衷。”蔡永强：“不是每个人都看得见真相，但每个人一定能成为真相。”对话四：李维民：“你怎么看待陈光荣？”蔡永强：“工作能力很强，办案有一套，有资源，有人脉，有个性。”李维民：“全是优点，缺点呢？”蔡永强：“有时候优点，就可能变成缺点。”看出共同点了吗？面对李维民多次蕴风雷于平淡中的询问，他始终没有给出正面肯定的回答，但是每一次回答又没有一句谎话。为什么？因为蔡永强不信任李维民。李维民的每一次提问看上去像是他对蔡永强的质疑，其实又何尝不是蔡永强对李维民的试探？“有个笑话，说谣言和真相是一对双胞胎，谣言性子急，走在前面，大家发现他是冒充的，被拍死了，等真相慢慢出了门，大家发现原来谣言和真相，一模一样。”这段话语意深远！李飞可以在审讯中反复用肯定句进行无证推断，因为他和李维民彼此信任，但是蔡永强不可以，他和李维民之间横亘着一条猜疑链，如果李维民是狼呢？他怀疑马云波，李飞怀疑他，而马云波和李飞又是李维民的嫡系，在没有证据的情况下讲错一句话，被当成谣言拍死的就是他。成年人的成熟是从“忍得住”开始的。还有人觉得蔡永强滴水不漏的说话艺术仅仅是信奉明哲保身吗？他对李维民的试探是他主动出击的方式，一旦付出信任，蔡永强将毅然成为缉毒前线一把最强的火枪。缉毒是以肉饲虎！不图名利，不图权势，每天面对的都是穷凶极恶的亡命之徒，正常人谁会去干这个？信仰的力量，可填山海。致敬和平年代的真心英雄！囚徒困境和猜疑链蔡永强和李飞联手审讯毒贩这场戏真的是目前为止最过瘾、最有戏剧张力、最火花四溅的一场戏，审讯艺术与戏剧艺术的结合妙至毫巅。引用两个名词：囚徒困境和猜疑链。囚徒困境出自博弈论。两个囚徒同时被捕，在无法互相沟通的前提下，如果两个人合作互不揭发，因证据不足，每个人都坐牢一年；如果一人揭发，另一个沉默，揭发者会因为立功而获释或减刑，沉默者则入刑十年；如果互相揭发，两个人都会因为证据确凿而获罪八年。大虾和麻子就是囚徒困境中的这两名犯人。走出囚徒困境的方法其实很简单，保持信任，创建合作。起初大虾和麻子是这样做的，各自保持沉默。按这个情形下去，两人的罪名顶多是吸毒和容留吸毒，无法找到突破性的关键证词。如何让这两个人互相揭发呢？轮到猜疑链发挥作用。猜疑链出自科幻小说《三体》。猜疑链导致文明无法互相判断彼此之间的善恶，并最终驱使双方相互敌视，无法形成共同认知。同样，猜疑链放到人类关系中也可以适用。蔡永强真是深谙人性的高手，合作哪有那么简单？人总是自私自为且不彼此信任的动物。他先通过猜硬币的方式将两人隔离，触发猜疑链，随后李飞借假口供制造大虾已招的假象，毒瘾发作判断力下降的麻子无法判断大虾是否会出卖他，紧接着，蔡永强和李飞迅速跟进对他进行诱导加强，两个人一唱一和默契唱起了双簧，很快就让麻子的心理防线全面崩溃。既然麻子已经吐得干干净净，合作创建失败，眼下的局面对大虾已经没有任何实质性的好处，一味死扛甚至可能会赔上性命，蔡永强此时说出的“我橄榄枝，只给你抛一次”，便是压垮骆驼的最后一根稻草。行云流水，步步推进，成竹在胸，难怪李飞会说庆幸里面坐的不是他。我的眼睛里只能看见一个人，蔡永强队长。这个人我可以夸到词穷，夸到笔墨难言。但是故事落幕，我不想这么简单地夸夸而已了。我想了解他，记住他。他的故事，是这部剧最感动我的部分。第一集 塔寨雨夜整个故事的开始，是一个暴雨之夜的抓捕行动。东山市公安局禁毒大队的两个年轻民警带领三名从盘锦市来的同志夜袭塔寨村，抓捕了一名叫林胜文的制贩毒嫌疑人。本来以为这只是一个简单的抓捕行动，没人想到，就是这次抓捕拉开了广东省乃至全国最大的一次打击毒品战役的序幕。而那个暗中布局拉动绳索的人，就是他。林胜文被抓回来后，蔡队质问李飞为何不在惠东林的岳家抓人，却擅闯塔寨林胜文所在的塔寨村，是东山市禁毒模范村。东山市一切打击毒品相关的行动，到了塔寨全部绕路而行。李飞成功抓捕林胜文回来后，与队长蔡永强发生了对峙。蔡永强质问他为什么擅闯塔寨，句句都是指责，却也句句都是暗示。然而此时的李飞已经对蔡永强失去信任，错过了他话语中的信息。暗示塔寨全村涉毒极为危险蔡永强提到之前的一次行动，由于抓捕时进错了屋，六个警察被村民围困一天一夜。这就是导致东山市禁毒举步维艰的最大原因：宗亲关系盘根错节，宗族之内相互掩护。以往事为鉴，所以蔡队昨夜暗暗安排了全队在村外接应（哥哥叉腰好可爱）就在林胜文被抓捕审讯后的第二天，龙坪市天平司法鉴定中心开出鉴定报告，林胜文因身患“心脏疾病”，符合保释条例。他被保释了。李飞愤怒地质问蔡永强，为什么在申请鉴定的报告上签字？是啊！为什么呢？很快你就会知道了。东山，没好人。在这里，想活下去，太难了。想留着命和手中武器，挣扎去打击犯罪，难上加难。林胜文被火速保释，面对李飞的愤怒质问，蔡队有口难言神图镇楼，哥哥苏到极限的一秒！第二集 杀机重重南井村。养鸡场。蔡永强赶到时，一切都已经晚了。他看见那两个年轻人，一个被毫无尊严地捆绑屠杀，一个满身血污命悬一线。这是一个针对他们两个精心布置的陷阱。而让他们走到了一脚踩进陷阱的如今的开端，正是不久前的那一场夜袭。蔡永强没想到自己算到了一切，却没有算到林胜文这个小虾竟然吐出了“你们领导挣300万”的猛料。而恰恰是他将李飞与自己在立场上割离的决策，让李飞决定对他隐瞒了这个致命的信息。“东山，没好人。”那个年轻人说。心如刀割。一死，一伤。蔡永强终于体会什么叫心如刀割。李飞被送进东山市人民医院。他身上扎着输液管，门外还坐着一名警员。蔡永强带着周恺和另一名队员赶到医院时，看见的是一个踉跄跑出病房的李飞。“李飞！不要动！”他不会傻得要逃走吧？这时候走了跟认了自己有罪有什么区别？蔡永强按住李飞，他这个时候还以为自己能控制住局面，审讯李飞的权力能留在自己手中。“蔡永强，你怀疑我？？？”我不怀疑你。我最信任的就是你。但是你可老实点儿吧！蔡永强把李飞按回病房，以为自己还能控制局面李飞被上手铐了=_=||| 作为一个病人，他太不“老实”。蔡永强一眼就看见乱七八糟的病房和地上散落的碎玻璃片。这不对劲。早先副队陈自力给他打来电话，枪弹检验报告显示，李飞和宋杨身上的枪伤分别是对方的警枪造成的。这明明白白就是在说，是李飞杀害了宋杨。这是个局！设局人什么都算好了，连同宋杨前女友弟弟车上的冰毒，和李飞家里的一百多万现金，一并奉上给你看。而他们禁毒大队，他蔡永强，被排斥在外了。自己的队员出了事，上司却嘱咐“检验报告别让他们拿到”。是谁？罗旭？还是马云波？涉及李飞本人的案子，蔡永强将费力打探来的信息全无保留告知。明白在说：我信任你，你是自己人。码字好累，欣赏一下永强哥哥的长睫毛慰劳下自己！哥哥的睫毛！轻轻抚在我的心上！陈光荣来要李飞。面对这个多年的战友，蔡永强心情非常复杂。情感上，陈光荣是自己多年的战友、朋友，说两人亲如兄弟也不为过；可理智上，蔡永强告诉自己，要和他保持距离。“五·一三案成立了专案组。你的名字，不在专案组名单上。”蔡永强看着陈光荣。你怎么掺和进这件事来？是上面的命令？还是你主动寻来的机会？怀疑曾经一起并肩作战的战友，是痛苦的。无论如何，李飞不能交出去。这个人是自己手下的队员，更是自己把他推出去做那把割破塔寨黑幕的尖刀。若是进了黑白不明的刑侦大队，没准有无数手段在等着他。电话挂断，无果。蔡永强脸上毫无表情，心里却泛起愤怒。对上司，对自己，对眼前这个善恶难辨的前战友。可是不是有句话说吗？把脾气压下去，是本事。愤怒有什么用？关键是怎么解决掉眼下这个麻烦。刚才的电话已经拖延了一点时间，李飞能不能自己跑掉？刚才他是不是就想跑来着？他还戴着手铐吧……要是他还在房里，怎么迅速搜集证据给他翻案？做局的人很可能就是顶头上司……难啊！蔡永强！门打开了。太好了。蔡队一眼识破，却给周恺打眼色不要声张，随后让周恺把地上的可疑玻璃片拿去化验。第三集 一线希望五·一三案，蔡永强被彻底排斥在外了。自从李飞顺利从医院病房溜走，他就再没有消息传回来过。这太正常了。他不信任蔡永强。蔡永强面上总是过分谨慎、明哲保身，林胜文被火速保释后，李飞甚至怀疑蔡永强就是东山毒贩的保护伞。在他被当作重大嫌疑人通缉、朝不保夕之际，他最不可能联系的一个人，就是蔡永强。但蔡永强不是完全没有办法。公安局，是一个信息的集散地。“丰益宾馆”，他得到了这四个字。李飞会去中山吗？副队陈自立带来了一个信息，蔡永强不知是好还是坏。“一提到‘丰益宾馆’，中山的兄弟都讳莫如深，打听不出什么消息。”打听不到消息，就说明了一个答案，同时也是一个暗示。赵学超不接电话了。这说明李飞极有可能去了中山，并且赵学超能找到他。这很好。赵学超此人是李维民的亲信，不论李维民立场如何，他总不会害李飞。蔡队的语气中有无奈，也有一点放心而此时不接电话的赵学超在干什么呢？此时，就在千方百计打探消息的蔡永强所不知道的地方，一个专门为了此案成立的联合调查组成型了，负责人正是广东省公安厅禁毒局副局长李维民，同他一同前来的还有一名公安部禁毒局的处长，左兰。对蔡永强来说，这将是一个千载难逢的机会。联合调查组抵达东山第五集 千载难逢李维民来了，带来了由广东省和公安部两级领导组成的“五·一三案联合调查组”。李维民是谁？广东省公安厅禁毒局副局长，广东省资历最深的老缉毒警，干缉毒的老祖宗。李维民和公安部禁毒局处长左兰的到来让蔡永强看见一个千载难逢的机会，他几乎要按捺不住胸中那团默默烧了多年的暗火，直要让它一把将东山这个烂泥潭燎个干净！！然而就在热血上头的一刻，他忽然冷静了。李维民，是马云波的师父，是一手把马云波带到如今这个位置的人。他完全可靠吗？蔡永强不敢赌。直到李维民的到来掀起了一场波澜，蔡永强才放下了大半的心。有人不想李维民来东山。蔡队和周恺对视一眼，发现事情并不简单( ﹁ ﹁ )就在蔡永强知道了李维民所处的困境之后，左兰处长收到了一个匿名短信，短信里将闹事现场那几个活跃分子的黑历史扒得一干二净。聪明如你肯定当时就猜到这个信息是谁发的啦！即使驽钝如我，随着剧情的发展，这个谜底也被揭开了。蔡永强的一双火眼金睛，仅凭着被“有心人”传上网络的一段短短的视频，就将那几个熟面孔一眼识破。这说明东山的涉毒分子，不论大小，在他的心中全部了如指掌。有蔡队这个强力辅助，李维民才能轻轻松松一举破局李维民来东山，是来调查五·一三案的。而他来之前，李飞就给他提供了一个可怀疑的目标。蔡队知道李飞在怀疑他，他从未怪过李飞调查组抵达东山后，蔡永强和李飞在一墙之隔的两间审讯室同时接受了问询。蔡永强把接待盘锦同志的任务交给李飞，李飞通过水伯查出“黑豆”就是塔寨村林胜文后，立刻向蔡永强请示进村抓人。李飞接了盘锦的案子，认出“黑豆”就是塔寨村林胜文，于是向蔡队汇报请求抓人然而蔡永强一开始以自己在外地为由暗示不同意他立刻去抓人，在他的坚持下又命令他将抓捕林胜文的消息保密，随后林胜文刚抓捕就被火速保释，这让李飞对蔡永强产生了极大的怀疑。林胜文对他吐出“300万保护伞”的消息后，他坚持认为这顶保护伞就是蔡永强。蔡永强的过分谨慎和叮嘱他对队内保密的行为让李飞怀疑该来的终于来了。蔡永强知道，如果不能对当初刻意把自己和李飞宋杨的抓捕行动切割开的行为做出一个合理的解释，将坐实调查组对自己的怀疑。但是能说吗？为什么装作不同意去塔寨抓人？为什么只让李飞宋扬两个人去？为什么明明派了全队人在村外接应保护，却让李飞他们守口如瓶？说不出。在不清楚李维民会对马云波极可能已经腐化的猜想采取什么立场之前，在没有抓到马云波就是保护伞的实质证据之前，蔡永强什么都不能说。不过没关系，河源的案子是早就准备好的借口。自己远在河源，其他队员手里都有案子，让李飞和宋杨去就顺理成章。不知蔡永强想没想到，李飞会将自己嘱咐他们将行动对人保密的话告知给调查组，而周恺在犹豫后，证实了这一点。抓不到马云波的把柄，又摸不准李维民的态度，蔡永强只能用借口敷衍调查组在被问到为何要李宋二人对队员保密时，他犹豫了。没有借口了。要说吗？第六集 滴水不漏“你为什么要向李飞交待，不要跟队里所有人讲。”蔡永强知道，如果这个问题自己做不出合理解释，自己身上的疑点就会一直存在。但是一天抓不到马云波的把柄，他就一天说不出真话。犹豫了几秒，他用技巧回避了。“我不记得我说过这句话。”抓不到马云波的把柄，又摸不准李维民的态度，蔡永强不敢说出自己的真实意图，只能回避。为什么让李飞他们保密？因为要防着马云波。李飞和马云波走得太近了。他不服蔡永强，不信他，怀疑他。但是他信马云波，听马云波的话。李飞因为抓捕林胜文吃了蔡永强一个处分后，马云波一句“这是组织商讨的决定”就打消了他的不平。他给马云波挡过子弹，把马云波当自己的大哥。而蔡永强，这个温吞谨慎，看似明哲保身、小心翼翼的家伙，李飞瞧不起他，也不屑于知道他到底是怎么想的。林胜文的火速保释，和蔡永强在鉴定申请书上的签名，成了李飞怀疑他的要点，而这一点显然引起了调查组的注意。蔡永强才不去管这个签名会不会成为他职业生涯中的一个的黑点，他只对自己说，机会来了。塔寨有人出面要求保释林胜文，蔡永强向马云波请示。他没有证据能够证明马云波已经站在塔寨一边，只好用这个方法去试探他的态度。而马云波会怎么说，蔡永强也预想到了。如果他不同意保释林胜文，他当时就会直接挡回去，但他回答的是：如果符合条件，你自行决定。蔡永强不是主动去申请鉴定林胜文是否够格保释，而是林耀东出面了，他才向马云波请示。结果当然是符合条件。调查组问到林胜文的保释，这简直正中蔡永强的下怀。他找到机会，在话里特别强调了那家给林胜文提供保释条件的“龙坪天平司法鉴定中心”。蔡永强都数不清有多少次，今天抓的嫌疑人，明天就被人保释出去。这个号称“天平”的机构明显有问题，蔡永强已经盯它很久了。今天就趁着调查组的东风，揭一揭它的画皮。法人是谁，什么背景，蔡永强想尽办法去调查。“出具过很多次类似的鉴定报告”、“能量很大，上面总有人替她说话。但背后的势力是谁，我不知道。”但就算他关系再广，也有查不到的人。因为林胜文的火速保释，李飞敏锐地意识到问题出在塔寨村。一定是塔寨村有人出面了，他才会那么快被“捞”出去。李维民终于问出这个让蔡永强谨慎、不忿了多年的问题：“你认为塔寨村有问题吗？”有！问题大了！什么禁毒模范村！东山市戴了多少年的毒帽？这几年里大大小小无数次扫毒行动，到了塔寨全部绕道而行，你说塔寨有没有问题？但是蔡永强能像李飞一样，凭着直觉提出指控吗？他不能。他没有证据。毫无证据之下，贸然指控一个禁毒模范村、一个两级人大代表有问题，这是要犯政治错误的。他蔡永强还想不想留着这个禁毒大队长的位子，在东山继续跟毒贩子们、跟塔寨斗下去了？此时此刻，任何没有证据的指控，都是没有意义的。蔡永强的一切城府和谨慎，都是吃够经验教训学来的。然而李维民似乎铁了心不吃这一套。在他的追问下，蔡永强给出了这场审讯的第二个技巧性回答：滴水不漏第七集（上） 一尘不染蔡永强受到了指控。这不是我自找的吗？他自嘲地想。李飞坚持，蔡永强，还有坚定站在他身边的陈自立和周恺，就是东山毒贩的保护伞。他出身大小毒贩出没的南井村，和毒贩子们沾亲带故，不是亲戚就是同学，走动起来毫不避嫌。今天抓进来的毒贩子，过几天就被“捞”出去了，放他们出去的不是他蔡永强，还能是谁？蔡永强啊蔡永强，一个东山人在东山干缉毒，你真是自找的。当年从村里考上来干警察的时候，蔡永强就想，我到底要不要干缉毒。远的不看，就看看班上那些同学里，有多少个沾上毒品家破人亡？又有多少个为了挣这个脏钱六亲不认丧心病狂？东山，太黑了。在东山干缉毒，太难。往上三辈都是亲戚，出门五步都是同学。白天抓了一个，晚上就有十七八个亲戚朋友拐着弯儿的来家里探消息，送礼，试探能不能“捞人”。越干越孤独。越干心越硬。毒贩子们刀尖舔血挣的是一夜暴富，他干缉毒的拿命去拼挣的是一个月三千块。面对儿子书包里的两万块钱，没冲击吗？蔡杰什么都没说，也没提任何要求，就是装了两万块，在自己还在上小学的儿子的书包里。什么意思？我认识你儿子。今天我能往他书包里塞钱，明天不一定还能干点什么。那天蔡永强盯着那个书包，盯了一宿合不上眼。而今天，这个“东山人”的身份，终于天然地让组织怀疑了。“你能证明我要了吗？”调查组同志怀疑、打量的眼神，让蔡永强有点无奈。知道这么难，为什么还要干缉毒？你是不是傻啊蔡永强！你为的就是那一个月三千块钱的工资吗？你为的就是混到现在亲朋疏远、孤身一人吗？我到底要的是什么？每过一段时间，蔡永强就会问问自己。然后他就听见了自己心里的答案。每一次，都一样。这个答案多少年都没有变过。谁是毒贩，这对我不重要。没有毒品，这对我很重要！看看那些被毒品祸害的老百姓！东山，不应该是这个样子！亲戚朋友不理解，同志战友有怀疑。蔡队跟谁诉过苦？有证据的话，就来指控我吧。蔡永强心想。要是对那些个大大小小的保护伞我也能这么轻轻松松地提出指控，那省了我多少功夫？身是菩提树，心如明镜台。蔡永强不是圣人，可有时候，一个普通人也能做成最伟大的事。第七集（下）处处艰难李飞怀疑指控蔡永强，蔡永强从没怪过他。他责怪自己。但是李飞对马云波的盲目信任，让蔡永强对他有些埋怨。明明咱们大队个个都是好样儿的，为什么他就是信不过？偏偏毫无理由地就信任马云波这个外来的。东山人怎么了？东山人在缉毒这行里就是原罪吗？东山人是最护着自己人的！他能去给马云波挡子弹，把队里大事小情全都跟他讲，还在事情没搞清楚之前，就去马云波面前告自己的状！“告密者”。蔡永强知道队里怎么看李飞。仗着跟副局长的关系，告了自己一状。看在最信任尊敬自己这个队长的周恺的眼里，这几乎等同于背叛。蔡永强不怪李飞，因为他不清楚实情。但是他更无法责怪为自己鸣不平的周恺。凭直觉做判断，有时是李飞的优势，有时却会成为他致命的弱点。马云波再英雄，他也是离你三尺远的副局长。你的兄弟们看着再平庸，关键时刻都是他们在盯你的背后啊！东山这潭水，太黑、太深了。明枪暗箭，防不胜防。不多长十七八个心眼，怎么活得下去？没有一帮过命的兄弟，怎么在一场场行动中全身而退？光凭着一腔孤勇、不顾己身，就能成事吗？蔡队金句。把脾气拿出来，是本事；把脾气压下去，是本事。因为在马云波面前告了自己一状，李飞被队里孤立了。蔡永强可以替他说话，替他在队里斡旋，挽回他的人际关系。实际上，蔡永强是一个很温柔的人，他可以原谅很多在普通人眼里是非常冒犯的事，再说他也从没因为这个怪过李飞。但是这个温柔的人做了一个无情的决定。他什么都没有做。他把李飞从自己的立场中割离开，连带着一起的还有宋杨。他选中了李飞，去做一把尖刀。宋杨死后，蔡永强无数次问过自己，后不后悔？后悔。不仅后悔，而且痛苦。但是重来一次，他骗不了自己，他还是会这么选。李飞和宋杨被全队人孤立，请注意，并不是蔡永强设计的，而是他做出了一个近乎背叛的行为。马云波。这个名字估计是蔡永强每天在脑子里念叨次数最多的一个。当年蔡永强有机会凭功绩升上东山市公安局副局长，可是半路冒出来一个空降兵，结果他就留在了禁毒大队，一留这么多年。这个空降兵就是马云波。省禁毒局副局长李维民嫡系弟子，全省出了名的禁毒英雄。这次他被派到东山来是奔着罗旭的位子去的，奈何深深扎根在疗养院的罗旭就是死占着坑不肯挪，他就成了副局长。马云波以往的禁毒工作太顺了，以至于他到了东山后，第一个看不上眼的就是他蔡永强和他手下这个禁毒大队。“东山如今禁毒形势严峻，你蔡永强，难辞其咎！”马云波新官上任，就借着李飞搭的梯子烧了一把火。看看恺恺的眼神，李飞就是这么被孤立的。马云波不明白为何一个手握国家机器的禁毒大队长，会弯下身段去调节几房村民的冲突矛盾，陪笑送烟，权威形象尽失。他不明白为何一个小小的东山，戴了几年的毒帽子都摘不下去。不就是一些毒贩子，能拧得过公安局的大腿？基层。稳定。宗亲。关系。越是小的地方，越是没有秘密。他们对你没有，你对他们亦然。新官上任，马云波烧到蔡永强头上的一把火，蔡永强能理解。但是如今的马云波，是蔡永强必须想办法拔掉的一颗钉子。保护伞，又多了一顶。第八集 霜刃暗藏马云波刚刚走马上任，就当着全大队的面，点名将蔡永强骂了个颜面扫地。调查组问，马云波当着所有人的面点你名，你是觉得委屈，还是愤怒？其实现在回想起来，蔡永强已经不太记得当时的心情。委屈吗？或许有一点。愤怒吗？也有一些吧。然而这愤怒不是冲着马云波，而是对自己，对自己的那种无力，更准确地说，那应该是一种难堪和羞愧。“我必须承认，他说的有道理。”东山禁毒局面如此艰难，他蔡永强这个禁毒大队长的确难辞其咎。马云波的一把火烧过后，蔡永强忍不住问自己，到底还有哪里没考虑到？为什么没能做得更好？到底有什么办法能把笼罩在东山的重重黑雾一把驱散个干净？蔡永强，你真的能行吗？他开始怀疑自己。怀疑自己的能力，怀疑自己的运气，甚至怀疑……不。他绝不怀疑自己的信仰。一天不行，两天。一年不行，两年。只要扛下去，别被打倒，别放弃寻找时机，总有一天会让他找到机会，把东山这大大小小的毒窝、保护伞，拔个干净。蔡永强此时说的不是客套话，而是真心话。在“唐旭吴刚演技大赏”一楼会详细分析。李飞。蔡永强注意到了这个热血的、聪明的、也有些莽撞的年轻人。他的热情和当年的自己真像啊！还有这小子那惊人的直觉。蔡永强仿佛看见了年轻时候的自己。年长一些后，蔡永强才发觉，那不是“直觉”，而是“观察力”和“潜意识”结合的产物。蔡永强欣赏李飞，不光是因为他的思维方式和自己极像，更是因为他对信仰的忠诚追求，和自己一模一样。而马云波和李飞亲近的关系，让蔡永强产生了一个想法。这个想法一冒头，蔡永强就对自己说：真是可怕。蔡永强，你看看自己是个什么人？然而一念生起，蔡永强再也没办法对它视而不见。它不停地在劝诱：听我的。多少年了？你不想动动塔寨吗？这个年轻人简直是最合适的利刃。他果敢，又有些冲动，最棒的是，有一个公安局副局长能在他的背后给他撑腰。就让他去动一动塔寨！你只需要保证他的安全，他的前途完全不需要你操心。你不是一直在等一个机会吗？李飞就是你的机会呀……这个声音不停、不停地在他心底轻搔，他做出了决定。“你会因为李飞跟马云波的关系，就对他另眼相看吗？”蔡永强，你是个什么人？蔡永强回避了，我猜不出他此时情绪如何。或许有愧疚吧。因为李飞的指控，调查组对蔡三毛的案子寻根究底。蔡三毛到底是怎么死的？这是一个无法回避的问题。顺风顺水的马云波不理解，李维民也很难赞同，身为一名国家机器的代言人，专职打击毒品犯罪的大队长，竟然会在调节几房村民的矛盾上面花上一个多月的时间，左右劝解，陪笑买烟。“这是你的本职工作吗？”在东山，没有基层关系的缉毒干警，是会有麻烦的。东山老百姓可以是庇护毒贩的百姓，也可以是警民一家的百姓。话是良言，可李维民才不上套。问你的是蔡三毛的真正死因，说到基层关系是不是答非所问？蔡永强犹豫了一下，将自己暗中发展线人的举动向他坦白了。不论李维民对马云波立场如何，蔡永强相信他对打击毒品犯罪，是真正的铁腕。十年磨剑，屡屡折戟。直到遇上了李飞，蔡永强终于找到了一把霜刃。及锋而试，可有大功 。]]></content>
      <tags>
        <tag>电视剧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO使用心得]]></title>
    <url>%2F2019%2F05%2F29%2FHEXO-tips%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! U2FsdGVkX19kc1njZRatsm3gRLTfEI41vJrxXA2vG9rOcpJmCIa60nL9xfqskVlVrWu2hXSV0hCzRabbQJ9fYVi77PKvs58fy/AM4Uv5j5M9OqedKCHo6+eIHrrxqRFyWiLtFEFU3p8mXUcTu/jhRUwOYsqL/GCNsC/QyCu4SgQKIA7pmkpEbSZuNnhRtYTYioBAQi8peszAQ18PGQxAyLVJnR6STi8c6Xp+lkTOHzxADy0VJdRJvNZRwffuvVj7IJ9VmjAAzF25A/Z3v54T2C8xysrXmOyLWDQidJbaNGQXAIfFrOk0Nl2WgpVbttEp0GqVR5yVEETVMNTzg3PIYHJTkGIkrwzzwAmG7BIbYxG8aRjsszNvzp25gA8rDXmTYaI3CboFqK/qhggbRFnwbob90DYqAmIvu6N1+Y3iOp+VoVpxnNKDbG+3SHMxPF8aSEUedfrj3wUH8MzG9Wnhg1ApKg5G8eY+74ua0UAuVLuvJ4VH8MdFwclwtPWKkCxHa+D3kRNgC4fLMWbO0vekRPsQEosg45kqe+DtKKrxvJWyDOjH04BOnj9RsbVBDXINAMMtnN04krB+wPa6is4DKQZRh63O6VwCaSEXSdWP28keWGzAaH7vSOfa2obC8xf9pH0kNmr+Yy9E+2QlA2Vh6QjFLlWCz6zhboGDpSUBlwQTSzOBLcwVJu1vdRhNUE9mVJlb1ShAGlJV3vBHfy/8mTSlVm0EsAZ4CCwTegRc7xRgehlpwI4fHw1+UV200m5qjMq80r5hgpIFm4JEw4tWAfW+O/tyzMlrdILIjhmofYBgtK/nQ/D6OTlaSAs2Iu7345giNqeorvvXRRTLCvxkjDzHAnZ8rbY7VPpXVHpLJVfe06O7cbQ2RkpKJicjjJJX3uMTIiCJ0L7CCn/EeGCkSKdzyvW/Vr3qPOO019BgZXUVEVxaT9Vv5GQ2fLBPRZZUuuQbcto0CyTx8Ul8jHXCXexrvBtCZIs+YhEqVJjNZnNtnloQeSouKIpnzGYKr/15pdIYnJ0aY964tbN4C19zMGdrHTRFn8cRKxX5EZjKlME2sH9e4akGOQBEIOz+TdWJAaoVvoQjJt/67WSVgPCY+bAqXyqL2DY2YuADLUchJYoSq0XjVjjjDMenrk8Eihh7CvmcOEAQVuhbMs1VOksHcL6Llusx5hdXzBGAtPWkLtLgvpJLCD6A6gk2RL7Pw/1hCn/lPmdRRGp/74h8vch6ajJ+cTWSxBVwjde02hZqAcoRkWIBQCh2WMVhZpM3PwIzSgeh8md7IzBzaxeVkP4jqOXheDgjoSAPqaY4vKhTdY4eYSE8NJsZsvtkZSUNoz3I9s/uVIFY6oOska8+8rrI3KgXNnxr6FJUeyn9D7H2JbrgpU4i7uYdZOfa21gP2Lz0rl5hJkd55z4SragDRXjdFrsIwkfNAQGRrVHZKuboUMzT65HY22YhaITj6Q6ghQpkwxIMmGq6ZsCJyhVHmS0Y1hRpce3H1DKVaXLfNqoKKMbvY4HM8MY4y+ZzttZ2udfOWMn+x5Nvl+nh+qiH2MTt/FPZptach7+CTohFbWjBPwl37dOHh4VecpRtsayoFm7vChKJij34F+7erFZytWXZoL/NSusNkFt0euqJSY6UOeD8sEcD1UomfUj/H94sj/ixNCHkxhfT9PYwQyqULDWz5hkXNn7PafeViekLV5CrcnLYS3ylyczOr2hpjTrHp9F1gG4vxNc40H4EXvRZQUCs8BBtGkGbQtmTA/gtniLstnChWjksU1mUzjG433OFHQQvioARhhDS3+Z7cy2dBKV0SLMSVU9oTR9RAqGXSDyikOAXX/0m9Jw4yPTRNJ+36maBgB/vaMk2uiTlhNd12SVXGpfIyZ9h/dekzZH0fLWMRZ8RLJcPypE8C2MUT/xaR8VsvjhN7oqtrtG5RwENKuF6zXV44wMWZ2DyP8Qu6OY2n8+ujK5ICXfp39E44WeUtyYdfTcWQPeBt0dzBe4lSGxJSEtSWFQgfuojdPnNKQdkg1DslG3Bci0O9uITGapPEK2yFdRH+Ta69UsPxPDWViWfXr3UQNcLLtFp+q+Y4NHPAC8Gjp7O8+CF4UuZsGSZEI30D5FXbggIrK4Qik6IGmR//OeG7SFswkIb8E7gDchJo6ddLzFRISDa8rxdz9keUFOSNfcLjU+zDtDPRLoqPCh7UGnEOrcQ7qpXlFJTafnjkNQLmKlXmlHQrpbyPWrkOftDf5syhRlziCZqHU+o/K+Pngn8P4vtS6aFBg3WphFNeKwM9t1otCa916mkQiae9YWEqd1dPFzLtRQD66J8aHJpDIHLCwKy4H4kxPTKbUqQ6Az4Hnn5Q2HhNnCOzKwljGKap7FU5zw57QM7DtqLMZ1u4bO7CgiO0wfTDz14fOks1VEX61Sm7gl0U0pQ3mWM2F1+lH2SPuxvU+gTOj8Bu6FyfT+6vEulZzu56C08Kk1B9CE+umkxPf5s8bwwT9dLuxRYcBjWEYgGhaAAdUXLrHTHUgkcM32FKm7uYoCYfKJttGLFPGyNiXOk53nQLNrFGHhufpCTcriP5TxudYp3PQSqszrUYx/33eRF6NhljyWE/DhGRvtnFclFTwvsIwPwhOk5UTuVef8RdDCIjWNk5cD40TjqUl1u5d2ZTAymNueQTpFBMK0vR2tc+DFVVHgvhD42KGdk8LcpuZ/mJcPZeJqZF/jTYhyVJ+QUYC/gSPJ4mzZP5iA9gEGhDyK/dLJnj22Gr8luDiSQ1Kbauc+YNXY7GgZ5bSDtIuZIV5/0/z8YenEZFP+sW2yvklvUr3HDq/8EKoqbzCIksihCRMMeD198mHwEx2aT/erec276gz42h7H+HybF1zQyglq6HztvdwxgtMZbzP28hNqhpLp1EfSaLT2B3sMA6b21rA0T2WFcUd0ysEsD/UUOCFnyqAhbSOQ54NxnuBuPpE3FF9QPDztdsg0SpOA7jBVek8H2hDldvx171mqobwb4kyHx7is71SyGf4KdQIVysYkr6bQJAVnMCj3zBH33Mkig7Flan3DJl7U9DE92mXsQIhugoDyHHQfNuownC4JtNHTjRPo+lRKrSic+/2BSH8VfrXsh0wdflg5HxaXLC1UoTmBitJSlJJAZ2QCEZigiCdJ+VuSHlpJv8cISgwNqqoWhBVtkY/8+uQ12NANplCKA/phudmusTNFVZpBnZMFf6W9FWtx0HNwS8F6/4IyUpkkrqcKb0qhIt0pzhetjQm8lfKBZ8Pyi8vehAkcRjoaucUn7QD3IfpPmFxOc3dCGl6C+gSfhQzGYbXgQEX55z+DNMkLxhYJ9Xs9TjihZfs7stt+fpE3xOpzllHoX8f29iPpKPaKX+cBUhIxi2L8o+Xe/kpgxOI8L7Iv3ds4kpz/uVyFVaqKSOCviwNhtaiHSKtkkFzcxtl8BtoT1bJ0acVUCQAvqA4Ya/icuoVjkkWG2fsK+QzHBj5A+ZI3s5o0RUhGfc+OvKo2xAPVdtje9TvzvU9FmOf9YAfk20nmhIpAqNwTqkL9kHKzo39aRrpZS6ql1DxhWGY9bd8PUBwxbQ96l4A08tumV0L/iki0PebRYty0p6vG8TS1IA92sthpwV5ySlugtzsEmTUyb6dPLxZGAca+jw9OuCY55tguxsJITk/RbPhjZXfqV5jf/MYON4qNx9WJE5AP9YSm0RH01fKodYkb3G6khyN+gr9XBDL5z/KRdVZhOzUR55ERMFkVKIIzAB2Ljpx7fgB87MDrjdbMUIay07vqDbqNZH6lQeYjfbsmzr71RbSqx5RLoxqGWoX2j0yiEi65Z7qm3JNIgwmM3RoeF71h+mZ0W/eVFTDKBGwEn51Tu43B2JHYDBW/L9FWVDL9kvKhsTYnHZdRYkSSgl2OcL36l6mNpheQgOCOgFTGGTh9Z3vYwRYCIrjBnabFCHKIYcLN33t5/wfz2k6mEoP2oVgsgXgguYLU879q6V3Hly1JNRWs22d4Ga7Sq3OJXcd6ODBXwyev/onijLtuIW7keMREVQlc4kAUaabJq2oAsNqpyzl2p2NenZdGVPFa+VKHWd3BnEzihM23IIzz0g7Z6Z8pc0lSxvuk5xnogKj/fkeKXc+2vQXCRHZaGgctzHu1dH44yR8Kw8aQFKAB7p/1wuXrrLfjgV543rYZsl6ud8bp4f62/h92P3EU/0/AfbvAvd47hE0lSjHL3GbNOOTgPeSAzIA2Md8hQ3fBJuENxeDPOVyIXO/7phhIRH1KTCERVZT4JaOf267fC2YjPN954Y38G1Ub2oOCDZVM8NMfTis1zm9d9f/2ZZrLySKToS2Hyd2+ALbe3ljF9Iuipe9P+uk7H/se+fIuH7SJP2sTbYY2gXVsuRX2ES/PgyjFPAKYfqS8GwcAOijC0BU6g+uRCf3sBcPPA4E3qpYrliW6g/IHXt9+RdteLfKn5O+c5KfoYbxY7y8Ryg52He6H50RAyfNZTBP3FFfOJ8QP5TBfKSdebYR5lN1qZadpBxbNK+TkuJhHfB2wh+wO1VuQqxGZwCn2xEnLgLDzzLmYX6vJxovarpx6iKy2sb0XcY1kX3jPh0jaRoXa1fyPHtfCPY6VwRQFsGofDWk1OVyLWk9miqy58p/1eibfivmBmpyrE56T5MxF1ObQ9nOoX/IHmXqSiUOMQATKGa1i1OPCltk2JIs3xwdsx6CbB9nkMvDAJLqDBaUz7BC9yxaYeMr8QWOvsxFSgrI2F8Or2dZ6c+G/sStrot4xj5vVUmVnVdd2hkQzhvmXO7u+kqM80F89KVYgGVBMO6nrLQeDJ4EIZmx8Brl6S7IRjYttLWfQwopDcZrKz7oCHoFFr+fX6jS4w1ncgPGMJJ99AcMWZ69+IGGQ5yqac32mQU2L+RZMawcY5s/VuGg6+3HJDzbshc7FpndkVO/gBlpPjY7MkwgUY2O+2x8hlrrOIo7ApN1D1gEpC3ca3bCtsvWIz0IvNO1L9ybatDJ28NR8DhDihvQH8Bb9+wv5cp7f8gThubmboHq7G/mwpeQpsGQCn+lN9onmM4eSp6yyuwb1Gj2gUf3rhOzV/QY4zKxUx8yzkdH6ao851sfpLBjgkvMJK8SJzLU9XoDdtFy6Ued3n1NNTWZwz0578Y2XCjmO8I1ZXD/8ifPTY+0Xlhz9u1CJtYvIWhsLRU4p4x4rB78yCikrxJsTuXxw+X6UN8cT+FuqJjosVYfI7P8EFdt0ClaVjFiNfc4xoFRZ11ZXoUzknNHKoc6zh7526vegu/rN0sO9OsbO8I7exGPCcIxUL1XpLD0k0RLU8ACVeVRw1sF9eC/Pm503zDfsLq689CwaNnXxYmReFzJKTgb9d3rpMbWxFk9rtHgWIXZ6teXUtO0D8CULWtUcVJVwSviNt4j/vZnOw3t7NfpPUO/zxMRAl9H7apPUSxkzBkMWRJ8m3dr1SIIH7hJiRIQFEJ1szK0qEDmRAFagvBIzMT7WyZEjVbaKqvUkN0/w0/Q65VITmoCnZiiGTKF8b/xricBtWq0gtZSoRU5fWfy9KjehdQlNRIuP5nTN6wTv6fNOd1k7LacGfycWaA0catLGv40UyG24GPv/gprf90h7GyRZSZF6Tkjvyw/QcqlPPoRoSwnY7rUKBYgw9bgL1B+bQpYDJ0GTvqdAJoUyo5RYu9xViaRYb40OAtjdWCpCZxT6UGMpvTiBPh9TQc0LDNcw5SlRiZY1c/clCTq0rEIBH6K4yGNVuYuuLtBXNQs4MA7tCeKRU8XMB+gwq1wPkJyOlB+fYoRJugSR09OXyT+k3xfXYNza1KMDkiAouu2iDOr/e9Ax3KatrysRyRLNci0HpG7rJX2t2FA==]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5笔记]]></title>
    <url>%2F2019%2F05%2F19%2FHTML5%2F</url>
    <content type="text"><![CDATA[HEADmeta标记meta标记用来描述网页，有利于搜索引擎快速找到网站并正确分类注意：对于中文网页需要使用 meta charset=”utf-8”声明编码，否则会出现乱码。有些浏览器(如 360 浏览器)会设置 GBK 为默认编码，则你需要设置为meta charset=”gbk”SEO（Search Engine Optimization）搜索引擎优化开发后上线=》发布=》用户就可以找到你的网站（网址、去搜索）记得网站要去做收录（各大搜索网站收录的地址）收录后，搜索引擎（蜘蛛程序）去爬你的网站目的：记录你的网页内容：title标签、alt、title属性、keywords、descriptionSTYLE / CSS选择器七种选择器ID 选择器， 如 #id{}类选择器， 如 .class{}属性选择器， 如 a[href=”segmentfault.com”]{}伪类选择器， 如 :hover{}伪元素选择器， 如 ::before{}标签选择器， 如 span{}通配选择器， 如 *{}关系选择符E F：包含选择符选择所有被E元素包含的F元素E&gt;F：子选择符选择所有作为E元素的子元素FE+F：相邻选择符选择紧贴在E元素之后的F元素E~F：兄弟选择符选择E元素所有兄弟元素F伪类选择符常用：hover设置元素在其鼠标悬停时的样式。：active设置元素在被用户激活(在鼠标点击与释放之间发生的事件)时的样式：focus设置元素在成为输入焦点(该元素的onfocus事件发生)时的样式E：not（s)匹配不含有s选择符的元素E：first-child匹配第一个子元素：last-child匹配最后一个子元素：nth-child（n）匹配第n个子元素选择器示例示例说明:checkedinput:checked选择所有选中的表单元素:disabledinput:disabled选择所有禁用的表单元素:emptyp:empty选择所有没有子元素的p元素:enabledinput:enabled选择所有启用的表单元素:first-of-typep:first-of-type选择的每个 p 元素是其父元素的第一个 p 元素:in-rangeinput:in-range选择元素指定范围内的值:invalidinput:invalid选择所有无效的元素:last-childp:last-child选择所有p元素的最后一个子元素:last-of-typep:last-of-type选择每个p元素是其母元素的最后一个p元素:not(selector):not(p)选择所有p以外的元素:nth-child(n)p:nth-child(2)选择所有 p 元素的父元素的第二个子元素:nth-last-child(n)p:nth-last-child(2)选择所有p元素倒数的第二个子元素:nth-last-of-type(n)p:nth-last-of-type(2)选择所有p元素倒数的第二个为p的子元素:nth-of-type(n)p:nth-of-type(2)选择所有p元素第二个为p的子元素:only-of-typep:only-of-type选择所有仅有一个子元素为p的元素:only-childp:only-child选择所有仅有一个子元素的p元素:optionalinput:optional选择没有”required”的元素属性:out-of-rangeinput:out-of-range选择指定范围以外的值的元素属性:read-onlyinput:read-only选择只读属性的元素属性:read-writeinput:read-write选择没有只读属性的元素属性:requiredinput:required选择有”required”属性指定的元素属性:rootroot选择文档的根元素:target#news:target选择当前活动#news元素(点击URL包含锚的名字):validinput:valid选择所有有效值的属性:linka:link选择所有未访问链接:visiteda:visited选择所有访问过的链接:activea:active选择正在活动链接:hovera:hover把鼠标放在链接上的状态:focusinput:focus选择元素输入后具有焦点:first-letterp:first-letter选择每个&lt;p 元素的第一个字母:first-linep:first-line选择每个&lt;p 元素的第一行:first-childp:first-child选择器匹配属于任意元素的第一个子元素的 p&gt; 元素:beforep:before在每个&lt;p元素之前插入内容:afterp:after在每个&lt;p元素之后插入内容:lang(language)p:lang(it)为&lt;p元素的lang属性选择一个开始值属性选择符E[att]选择具有att属性的E元素E[att=”val”]选择具有att属性且属性值等于val的E元素E[att~=”val”]选择具有att属性且属性值为一用空格分隔的字词列表，其中一个等于val的E元素E[att^=”val”]选择具有att属性且属性值为以val开头的字符串的E元素E[att$=”val”]选择具有att属性且属性值为以val结尾的字符串的E元素E[att*=”val”]选择具有att属性且属性值为包含val的字符串的E元素E[att|=”val”]选择具有att属性且属性值为以val开头并用连接符”-“分隔的字符串的E元素伪对象选择符E:first-letter/E::first-letter设置对象内的第一个字符的样式E:first-line/E::first-line设置对象内的第一行的样式E:before/E::before设置在对象前（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用E:after/E::after设置在对象后（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用E::placeholder设置对象文字占位符的样式E::selection设置对象被选择时的颜色tipsCSS选择器的使用，应该尽量避免使用 !important 和 内联样式；id通常也是与class区分开使用，前者多用于JS中的结点定位，后者多用于CSS选择器。color尽量使用16进制或RGBA字体：垂直居中：lineheight与height相等vertical-align:middle;文本居中（img未转换成块元素前同样适用）：text-align: center优先级规则：就近原则行内引用 &gt; 页内引用 &gt; 页外引用CSS 优先规则1： 最近的祖先样式比其他祖先样式优先级高。123456&lt;!-- 类名为 son 的 div 的 color 为 blue --&gt;&lt;div style="color: red"&gt; &lt;div style="color: blue"&gt; &lt;div class="son"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;CSS 优先规则2：“直接样式”比”祖先样式”优先级高。1234&lt;!-- 类名为 son 的 div 的 color 为 blue --&gt;&lt;div style="color: red"&gt; &lt;div class="son" style="color: blue"&gt;&lt;/div&gt;&lt;/div&gt;CSS 优先规则3：优先级关系：内联样式 &gt; ID 选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素选择器CSS 优先规则4：计算选择符中 ID 选择器的个数（a），计算选择符中类选择器、属性选择器以及伪类选择器的个数之和（b），计算选择符中标签选择器和伪元素选择器的个数之和（c）。按 a、b、c 的顺序依次比较大小，大的则优先级高，相等则比较下一个。若最后两个的选择符中 a、b、c 都相等，则按照”就近原则”来判断。CSS 优先规则5：属性后插有 !important 的属性拥有最高优先级。若同时插有 !important，则再利用规则 3、4 判断优先级! important （特殊情况使用）!important是CSS1就定义的语法，作用是提高指定样式规则的应用优先权。语法格式{ cssRule !important }，即写在定义的最后面，例如：p{color:red !important;}p{color:blue}tips错误的说法在学习过程中，你可能发现给选择器加权值的说法，即 ID 选择器权值为 100，类选择器权值为 10，标签选择器权值为 1，当一个选择器由多个 ID 选择器、类选择器或标签选择器组成时，则将所有权值相加，然后再比较权值。这种说法其实是有问题的。比如一个由 11 个类选择器组成的选择器和一个由 1 个 ID 选择器组成的选择器指向同一个标签，按理说 110 &gt; 100，应该应用前者的样式，然而事实是应用后者的样式。错误的原因是：选择器的权值不能进位。还是拿刚刚的例子说明。11 个类选择器组成的选择器的总权值为 110，但因为 11 个均为类选择器，所以其实总权值最多不能超过 100， 你可以理解为 99.99，所以最终应用后者样式。CSS 选择符组合方式：后代选择符： .father .child{}子选择符： .father &gt; .child{}相邻选择符: .bro1 + .bro2{}样式被应用的位置越在下面则优先级越高清除CSS中select的下拉箭头样式1234567891011121314151617181920select &#123;/*Chrome和Firefox里面的边框是不一样的，所以复写了一下*/border: solid 1px #000;/*很关键：将默认的select选择框样式清除*/appearance:none;-moz-appearance:none;-webkit-appearance:none;/*在选择框的最右侧中间显示小箭头图片*/background: url("http://ourjs.github.io/static/2015/arrow.png") no-repeat scroll right center transparent;/*为下拉小箭头留出一点位置，避免被文字覆盖*/padding-right: 14px;&#125;/*清除ie的默认选择框样式清除，隐藏下拉箭头*/select::-ms-expand &#123; display: none; &#125;other在布局上面，一开始就要设置的，主要目的去除/初始化所有标签的样式123456*&#123; margin: 0; /*去除默认的外边距*/ padding: 0; /*去除默认的内边距*/ font-size: 14px; /*统一字体大小*/ font-weight: normal; /*都不加粗*/ &#125;id名，一般不用来加样式，一般是用于js添加动态效果id的优先级最高长图片定位12345.img&#123; background:url(1.png) 0 0 no-repeat; width:25px; height:25px;&#125;布局display（元素显示模式）block块对象指的是元素显示为一个方块，默认显示状态下将占据整行，其它的元素只能另起一行显示inline行间对象与block刚好相反，它允许其它元素在同一行显示none隐藏对象inline-blockfloat（元素的浮动）none不浮动right向右浮动left向左浮动浮动的时候元素的显示属性也变化了变为 “行内元素”clear（清除浮动）none默认值允许两两边都可以有浮动对象left不允许左边有浮动对象right不允许右边有浮动对象both不允许有浮动对象position（元素的定位）static无定位默认值absolute绝对定位tips：脱离文档流。通过 top,bottom,left,right 定位。如果父元素 position 为 static 时，将以body坐标原点进行定位。如果父元素 position 为 relative 时，将以父元素进行定位。relative相对定位tips：相对定位（相对自己原来的位置而言）不脱离文档流参考自身静态位置通过 top,bottom,left,right 定位。fixed固定定位tips固定定位实际上只是绝对定位的特殊形式；固定定位的元素是相对于浏览器窗口而固定，而不是相对于其包含元素；即使页面滚动了，它们仍然会处在浏览器窗口中跟原来完全一样的地方。z-index（元素的层叠关系）autonumberreset.css1234567891011121314151617181920212223body,p,ul,ol,li,dl,dt,dd,h1,h2,h3,h4,h5,h6,form,fieldset,legend,input,select,textarea,button,th,td,menu&#123;margin:0;padding:0;&#125;ul,dl,ol&#123;list-style:none;&#125;img,fieldset,input[type="submit"]&#123;border:0 none;&#125;em&#123;font-style:normal;&#125;strong&#123;font-weight:normal;&#125;table&#123;border-collapse:collapse;border-spacing:0;&#125;button,input[type="button"]&#123;cursor:pointer;border:0 none;&#125;a,button,input,img&#123;-webkit-touch-callout:none;&#125;img&#123;pointer-events:none;/*禁止图片的点击事件，例如长按保存图片*/&#125;input,select,textarea&#123;outline:none;&#125;a&#123;text-decoration:none;&#125;.fl&#123; float: left&#125;.fr&#123; float: right&#125;.clear&#123;clear:both;&#125; html,body&#123;/*禁止用户选择元素*/-moz-user-select:none; -webkit-user-select: none;-ms-user-select: none; -khtml-user-select:none; /*禁止元素点击出现半透明黑色背景*/ -webkit-tap-highlight-color:rgba(0, 0, 0, 0); &#125;html &#123;height: 100%;width: 100%;font-family: 'Heiti SC', 'Microsoft YaHei';outline: 0;-webkit-text-size-adjust:none;&#125;body &#123;height: 100%;margin: 0;position: relative;&#125;BODY常见语义标记123456789101112131415161718192021222324252627282930313233&lt;article&gt; &lt;header&gt; &lt;h1&gt;文章标题&lt;/h1&gt; &lt;p&gt;发表时间：1999-01-01 &lt;span&gt;作者：佚名&lt;/span&gt;&lt;/p&gt;&lt;/header&gt; &lt;nav&gt; &lt;a href="#"&gt;HTML&lt;/a&gt; | &lt;a href="#"&gt;CSS&lt;/a&gt; | &lt;a href="#"&gt;JavaScript&lt;/a&gt; &lt;/nav&gt;&lt;p&gt;正文...&lt;/p&gt; &lt;section&gt; &lt;h1&gt;稻草&lt;/h1&gt; &lt;p&gt;夏日的夕阳，激起了小溪的热情，染红了乡间的田野。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;今天我们去星光电影城看了场电影&lt;/p&gt; &lt;aside&gt; &lt;h4&gt;星光电影城&lt;/h4&gt; &lt;p&gt;星光电影城是市内最大的电影城，里面不仅有舒服的观影体验，还有大量的娱乐设施，美食等...&lt;/p&gt; &lt;/aside&gt;&lt;footer&gt; &lt;p&gt;Posted by: hello world&lt;/p&gt; &lt;p&gt;&lt;time pubdate datetime="2012-03-01"&gt;&lt;/time&gt;&lt;/p&gt; &lt;/footer&gt;&lt;/article&gt;标记说明header显示网站名称、主题或者主要信息nav网站的连接菜单aside用于侧边栏article用于定义主内容区section用于章节或段落footer位于页脚，用来放置版权声明、作者等信息figure独立的流内容（图像、图表、照片、代码等等）内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。figcaption定义 figure&gt;元素的标题.应该被置于 “figure”元素的第一个或最后一个子元素的位置div：容器标签span：区块标签embed：定义了一个容器，用来嵌入外部应用或者互动程序（插件）width、height：宽高type：规定嵌入内容的MIME 类型，如视频，外部应用值：MIME_typesrc：URL1&lt;embed src="flash.swf" &gt;base：为页面上的所有链接规定默认地址或默认目标base&gt; 标签必须位于 head&gt; 元素内部base&gt;标签是空标签，没有结束标签，XHTML中要求正确关闭 /&gt;123456789&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;base href="//www.runoob.com/images/"&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; &lt;img src="logo.png"&gt; - 注意这里我们设置了图片的相对地址。能正常显示是因为我们在 head 部分设置了 base 标签，该标签指定了页面上所有链接的默认 URL，所以该图片的访问地址为 "http://www.runoob.com/images/logo.png" &lt;/p&gt;bdo：改变文字方向属性ltr：left to right ：→rtl：right to left ：←1&lt;bdo dir=“rtl”&gt;文本将改变文本方向&lt;/bdo&gt;canvas：图形的绘制通过脚本（通常是JS）来完成canvas&gt; 标签只是图形容器，您必须使用脚本来绘制图形默认情况下 canvas元素没有边框和内容，使用 style 属性来添加边框1&lt;canvas id=“id名” width=“200” height=“100” style="border:1px solid #000;"&gt;&lt;/canvas&gt;12345678&lt;tbody&gt; 标签表格主体（正文）。该标签用于组合 HTML 表格的主体内容。tbody 元素应该与 thead 和 tfoot 元素结合起来使用。thead 元素用于对 HTML 表格中的表头内容进行分组，而 tfoot 元素用于对 HTML 表格中的表注（页脚）内容进行分组。注释：如果您使用 thead、tfoot 以及 tbody 元素，您就必须使用全部的元素。它们的出现次序是：thead、tfoot、tbody，这样浏览器就可以在收到所有数据前呈现页脚了。您必须在 table 元素内部使用这些标签。提示：在默认情况下这些元素不会影响到表格的布局。不过，您可以使用 CSS 使这些元素改变表格的外观。详细描述thead、tfoot 以及 tbody 元素使您有能力对表格中的行进行分组。当您创建某个表格时，您也许希望拥有一个标题行，一些带有数据的行，以及位于底部的一个总计行。这种划分使浏览器有能力支持独立于表格标题和页脚的表格正文滚动。当长的表格被打印时，表格的表头和页脚可被打印在包含表格数据的每张页面上。注释：&lt;thead&gt; 内部必须拥有 &lt;tr&gt; 标签！标记换行1&lt;br&gt;分割线1&lt;hr&gt;让文字按原始代码的排列方式进行显示1&lt;pre&gt;&lt;/pre&gt;表示引用文字，会将标记内的文字换行并缩进1&lt;blockquote&gt;&lt;/blockquote&gt;特殊符号表示&copy; // &amp;copy+;&lt; // &amp;lt+;&gt; // &amp;gt+;&amp; // &amp;amp+;“ // &amp;quot+;&reg; // &amp;reg+;不换行空格 // &amp;nbsp+;半角空格 // &amp;ensp；全角空格 // &amp;emsp；窄空格 // &amp;thinsp；6/1a：链接1234a&#123; text-decoration：none; /*去除下划线*/ text-decoration：underline;/*添加下划线*/&#125;说明：href：定义链接地址title：链接提示信息target：链接打开方式锚点标签用于使用户”跳”到文档的某个部分。a href=”#位置名”&gt;&lt;/aa name=”位置名”&gt;&lt;/a提示：如果没有使用 href 属性，则不能使用 hreflang、media、rel、target 以及 type 属性提示：通常在当前浏览器窗口中显示被链接页面，除非规定了其他 target提示：请使用 CSS 来改变链接的样式img：图像转换为块元素：123img&#123; display: block;&#125;说明：src：定义图像的urlalt：定义图像的替代文本（即图像提示信息）width：设置图像的宽度height：设置图像的高度图像热区1234&lt;img src=&quot;URL&quot; usemap=&quot;# map名称&quot; /&gt;&lt;map name=&quot;map名称&quot;&gt; &lt;area shape=&quot;形状&quot; coords=&quot;坐标值&quot; href=&quot;URL&quot; /&gt;&lt;/map&gt;矩形：(左上角顶点坐标为(x1,y1)，右下角顶点坐标为(x2,y2))1&lt;area shape="rect" coords="x1,y1,x2,y2" href=url&gt;圆形：(圆心坐标为(X1,y1)，半径为r)1&lt;area shape="circle" coords="x1,y1,r" href=url&gt;多边形：(各顶点坐标依次为(x1,y1)、(x2,y2)、(x3,y3) ……)1&lt;area shape="poly" coords="x1,y1,x2,y2 ......" href=url&gt;float：浮动| 值 | 描述 || :—–: | :————————————————–: || left | 元素向左浮动。 || right | 元素向右浮动。 || none | 默认值。元素不浮动，并会显示在其在文本中出现的位置。 || inherit | 规定应该从父元素继承 float 属性的值 |dl：定义列表123456&lt;dl&gt; &lt;dt&gt;计算机&lt;/dt&gt; &lt;dd&gt;用来计算的仪器 ... ...&lt;/dd&gt; &lt;dt&gt;显示器&lt;/dt&gt; &lt;dd&gt;以视觉方式显示信息的装置 ... ...&lt;/dd&gt;&lt;/dl&gt;类似ulul：无序列表1234ul,dl&#123; float: left; /*左浮动：从左到右并排显示*/ list-style: none;/*去小圆圈*/&#125;属性：Typedisc：实心圆（默认）circle：空心圆square：实心方框reversed：倒序ol：有序列表start：排序的起点数值type：用来设置项目前面的标记1：数字（默认）a：小写字母A：大写字母i：小写希腊字母I：大写希腊字母Audio、Video：媒体12345&lt;audio width="320" height="240" controls="controls"&gt; &lt;source src="song.ogg" type="audio/ogg"&gt; &lt;source src="song.mp3" type="audio/mpeg"&gt; 你的浏览器不支持&lt;audio&gt;标签&lt;/audio &gt;音频属性autoplay：自动播放loop：循环播放controls：显示控件preload：预加载（若使用autoplay属性则自动忽略）视频属性同上muted：规定视频的音频输出应该被静音poster[URL]：规定视频未播放时的图像src[URL]：视频链接width &amp; height：宽高table：表格tr（行）、th（表头）、td（单元）、caption（标题）th 所标识的单元格文字会以粗体显示，通常当做表格第一行的标题说明：width、height：宽高border：边框宽度cellpadding：单元内边距cellmargin：单元外边距align：水平leftrightcentervalign：垂直topmiddlebottomcolspan：合并左右列rowspan：合并上下行让单元格文字不换行 nowrap 例：【td nowrap】遇到空白单元格时的处理方式：在其中输入全角空格（&amp;emsp；）或（&amp;nbsp；）即可解决高度=行高，文字会垂直居中图片默认根据宽度对表格进行调整，故时而其下会有间隙，遇此情况IMG CSS : display : block // 将图片改成块元素IMG CSS : display : flex // 弹性布局float : left // 浮动HTML背景设置背景颜色 body bgcolor=”#000000”&gt;设置背景图片 body background=”bg.jpg”&gt;设置页面文字颜色 body text=”#cccccc”&gt;尽量使用十六进制以及RGBA或RGB，利于浏览器渲染背景图CSS设置：12345678910111213141516body &#123; /* 图片地址 */ background-image: url(09.jpg); /* 图片按屏幕大小显示 */ background-size: cover; /* 指定一个固定的背景图片 */ background-attachment: fixed; /* 图片不重复 */ background-repeat: no-repeat; /* 图片显示位置水平居中垂直居中 */ background-position: center center; &#125;iframe内嵌框架1&lt;iframe src="xxx.html" frameborder="0" id="iframe"说明：scrolling：是否显示滚动条yesnoautoframeborder：是否显示边框10样式123456iframe &#123; position: fixed; /*固定定位*/ right: 0; bottom: 0; &#125;JavaScript12345678910111213141516171819202122232425scrolling="no"&gt;&lt;/iframe&gt; &lt;script language="javascript"&gt; var timeIframe; window.onload = function () &#123; timeIframe = setTimeout(GetIframeStatus, 10); &#125; function GetIframeStatus() &#123; var iframe = document.getElementById("iframe"); var iframeWindow = iframe.contentWindow; //内容是否加载完 if (iframeWindow.document.readyState == "complete") &#123; var iframeWidth, iframeHeight; //获取Iframe的内容实际宽度 iframeWidth = iframeWindow.document.documentElement.scrollWidth; //获取Iframe的内容实际高度 iframeHeight = iframeWindow.document.documentElement.scrollHeight; //设置Iframe的宽度 iframe.width = iframeWidth; //设置Iframe的高度 iframe.height = iframeHeight; &#125; else &#123; timeIframe = setTimeout(GetIframeStatus, 10); &#125; &#125; &lt;/script&gt;form表单1234&lt;form name="form1" action="URL" method="get"&gt; 用户名：&lt;input type="text" name="uname" /&gt; 密 码：&lt;input type="password" name="passwd" /&gt;&lt;/form&gt;method（设置发送数据的方式）：post 和 get使用get方式发送数据，数据会直接加载URL之后，安全性比较差，并且有255个字符的字数限制post方式是将数据封装之后再发送，字符串长度没有限制，数据安全性比较高。对于需要保密的信息，通常会采用post方式进行发送action表单提交地址enctype：MIME方式MIME：Multipurpose Internet Mail Extensions多用途互联网邮件扩展类型表单发送的编码方式，只有method=“post”时才有效enctype=”application/x-www-form-urlencoded”：此为默认值，若enctype省略不写，则表示采取此种编码模式enctype=”multipart/form-data”：用于上传文件的时候enctype=”text/plain”：将表单属性发送到电子邮箱时，enctype的值必须设为”text/plain”,否则将会出现乱码marquee：滚动内容（过时）marquee元素已经 过时，请不要再使用。尽管一些浏览器仍然支持它，但它不是必须的。此外，使用这个元素基本上是你可以对你的用户做最糟糕的事情之一，所以请不要这样做。direction ：滚动的方向left（默认）rightupdownbehavior ：滚动的方式scroll：连续滚动slide：滑动一次alternate：来回滚动loop ：循环的次数正整数默认为无限循环scrollamount ：运动速度正整数，默认为6scrolldelay ：停顿时间正整数，默认为0，单位是毫秒align ：元素的垂直对齐方式topmiddle（默认）bottombgcolor ：运动区域的背景色16进制的RGB颜色，默认为白色height、width：运动区域的高度和宽度正整数(单位是像素)百分数默认：width=100% height为标签内元素的高度。hspace、vspace ：元素到区域边界的水平距离和垂直距离正整数，单位是像素。onmouseover=this.stop() onmouseout=this.start() ：当鼠标以上区域的时候滚动停止，当鼠标移开的时候又继续滚动。target（打开方式）_blank：打开新窗口_self ：当前的窗口_parent：上一层窗口（父窗口）_top：最上层窗口框架名称：直接指定窗口或框架名称novalidate：规定当提交表单时不对表单数据（输入）进行验证。1234&lt;form action="demo_form.html" novalidate&gt;E-mail: &lt;input type="email" name="user_email"&gt; &lt;input type="submit"&gt;&lt;/form&gt;autocomplete：规定表单是否应该启用自动完成功能。on：浏览器会基于用户之前键入的值自动完成值。off：用户必须在每次使用时输入值到每个字段中，浏览器不会自动完成输入。input：输入框说明placeholder：显示在输入框的内容readonly：是否只读maxlength：输入字符的最大长度disabled：是否禁用value：输入框中填入的值checkbox ：复选框此时name属性应为xxx [ ]selected ：下拉框默认选中datalist：规定了 input&gt; 元素可能的选项列表。12345678&lt;input list="browsers"&gt; &lt;datalist id="browsers"&gt; &lt;option value="Internet Explorer"&gt; &lt;option value="Firefox"&gt; &lt;option value="Chrome"&gt; &lt;option value="Opera"&gt; &lt;option value="Safari"&gt; &lt;/datalist&gt;提供”自动完成”的特性。用户能看到一个下拉列表，里边的选项是预先定义好的，将作为用户的输入数据。使用 input&gt; 元素的 list 属性来绑定 datalist&gt; 元素。output：作为计算结果输出显示(比如执行脚本的输出)。123456789&lt;form oninput="x.value=parseInt(a.value)+parseInt(b.value)"&gt; 0 &lt;input type="range" id="a" value="50"&gt; 100+ &lt;input type="number" id="b" value="50"&gt; = &lt;output name="x" for="a b"&gt;&lt;/output&gt;&lt;/form&gt;hiddenhidden 属性规定对元素进行隐藏。隐藏的元素不会被显示。如果使用该属性，则会隐藏元素。可以对 hidden 属性进行设置，使用户在满足某些条件时才能看到某个元素（比如选中复选框，等等）。然后，可使用 JavaScript 来删除 hidden 属性，使该元素变得可见。radio：单选name必须相同label：将输入项或选项及其标签文字关联起来使单选文字部分也具有点击效果12345678&lt;p&gt; &lt;!-- 状态的属性，写个名字就可以了 autoplay loop checked选中 required必填--&gt;单选按钮： &lt;input type="radio" name="sex" value="男" id="nan"&gt; &lt;label for="nan"&gt;男生&lt;/label&gt; &lt;input type="radio" name="sex" value="女" checked id="nv"&gt;&lt;label for="nv"&gt;女生&lt;/label&gt;&lt;/p&gt;autocomplete用来设置input组件是否使用自动完成功能onoff自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。适用于 form&gt;，以及下面的 input&gt; 类型：text, search, url, telephone, email, password, datepickers, range 以及 colorautofocus：当页面加载时 input&gt; 元素应该自动获得焦点12345678&lt;form action="demo_form.html"&gt; First name: &lt;input type="text" name="fname" autofocus&gt; &lt;br&gt; Last name: &lt;input type="text" name="lname"&gt;&lt;br&gt; &lt;input type="submit"&gt;&lt;/form&gt;form：input&gt; 元素所属的一个或多个表单。123456789101112131415&lt;form action="demo-form.php" id="form1"&gt; First name: &lt;input type="text" name="fname"&gt; &lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;p&gt; "Last name" 字段没有在 form 表单之内， 但它也是 form 表单的一部分。&lt;/p&gt;Last name: &lt;input type="text" name="lname" form="form1"&gt;&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; IE 不支持 form 属性&lt;/p&gt;required ：必须在提交之前填写输入域（不能为空）。12345678&lt;form action="" method="post" enctype="" &gt; &lt;label for="user"&gt;用户名：&lt;/label&gt; &lt;input type="text" name="user" id="user" required&gt; &lt;br&gt; &lt;label for="password"&gt;密 码：&lt;/label&gt; &lt;input type="password" name="password" id="password" &gt; &lt;input type="submit" name="" value="提交"&gt;&lt;/form&gt;checked：状态属性默认选中accept：用于指定文件类型1accept=&quot;.jpg,.jpeg,.png,.gif&quot;file：文件上传1&lt;input type="file" name="pic2" accept="image/*"&gt;multiple：控制是否上传多文件number // 数字输入框max - 规定允许的最大值。min - 规定允许的最小值。step - 规定合法数字间隔。value - 规定默认值。去除输入框得到焦点时，浏览器出现的蓝色带阴影的边框1234567input&#123; outline: 0;&#125; OR input&#123; focus:outline: none;&#125;enctype=”multipart/form-data”指表单数据有多部分构成，既有文本数据，又有文件等二进制数据默认情况下，enctype的值是application/x-www-form-urlencoded，不能用于文件上传，只有使用了multipart/form-data，才能完整的传递文件数据。application/x-www-form-urlencoded不是不能上传文件，是只能上传文本格式的文件，multipart/form-data是将文件以二进制的形式上传，这样可以实现多种类型的文件上传。值描述button定义可点击的按钮（通常与 JavaScript 一起使用来启动脚本）checkbox定义复选框file定义文件选择字段和 “浏览…” 按钮，供文件上传hidden定义隐藏输入字段image定义图像作为提交按钮password定义密码字段（字段中的字符会被遮蔽）radio定义单选按钮reset定义重置按钮（重置所有的表单值为默认值）submit定义提交按钮text默认。定义一个单行的文本字段（默认宽度为 20 个字符）color(以下为H5新增)定义拾色器date定义 date 控件（包括年、月、日，不包括时间）datetime定义 date 和 time 控件（包括年、月、日、时、分、秒、几分之一秒，基于 UTC 时区）datetime-local定义 date 和 time 控件（包括年、月、日、时、分、秒、几分之一秒，不带时区）email定义用于 e-mail 地址的字段month定义 month 和 year 控件（不带时区）number定义用于输入数字的字段range定义用于精确值不重要的输入数字的控件（比如 slider 控件）search定义用于输入搜索字符串的文本字段tel定义用于输入电话号码的字段time定义用于输入时间的控件（不带时区）url定义用于输入 URL 的字段week定义 week 和 year 控件（不带时区）textarea：定义一个多行的文本输入控件123&lt;textarea rows="10" cols="30"&gt;我是一个文本框。&lt;/textarea&gt;说明autofocus：当页面加载时，文本区域自动获得焦点。cols：文本区域内可见的宽度。值：数字disabled：禁用文本区域。form：文本区域所属的一个或多个表单。123456789101112131415&lt;form action="demo-form.php" id="usrform"&gt; Name: &lt;input type="text" name="usrname"&gt; &lt;input type="submit"&gt;&lt;/form&gt;&lt;br&gt;&lt;textarea rows="4" cols="50" name="comment" form="usrform"&gt;输入内容...&lt;/textarea&gt;&lt;p&gt; 以上的表单在文本框之外，但是它仍是表单中的一部分。&lt;/p&gt;&lt;p&gt; &lt;b&gt;注意：&lt;/b&gt; IE 不支持 form 属性。&lt;/p&gt;maxlength：文本区域允许的最大字符数。值：数字name：文本区域的名称placeholder：提示readonly：规定文本区域为只读。required：规定文本区域是必需的/必填的。rows：规定文本区域内可见的行数。值：数字wrap：当提交表单时，文本区域中的文本应该怎样换行。soft：文本不换行（默认）hard：文本换行（包含换行符）。当使用 “hard” 时，必须指定 cols 属性。select：下拉框12345&lt;select name="city"&gt;&lt;option value="0"&gt;请选择&lt;/option&lt;option value="bj"&gt;北京&lt;/option&gt;&lt;option value="gz"&gt;广州&lt;/option&gt;&lt;/select&gt;说明：name：名称size：下拉框显示的行数multiple：是否多选disabled：是否禁用selected：是否默认选中value：选项的值optgroup：下拉框分组12345678910&lt;select name="city" multiple&gt; &lt;optgroup label="广东"&gt; &lt;option value="1"&gt;广州&lt;/option&gt; &lt;option value="2"&gt;深圳&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label="其他"&gt; &lt;option value="3"&gt;长沙&lt;/option&gt; &lt;option value="4"&gt;香港&lt;/option&gt; &lt;/optgroup&gt;&lt;/select&gt;居中行内元素：text-align：center；定宽块元素：margin：0 auto；居中的三个条件：必须是块元素(不可以是行元素)有明显的宽（width:xxpx）margin：0px auto；文本属性居中align:设置水平对齐方式（left/right/center/justify）valign:设置垂直对齐方式（top/middle/bottom）上面的不常用，下面的常用text-align:设置水平对齐方式left/right/center/justifyvertial-align:设置垂直对齐方式top/middle/bottom水平居中：给div设置一个宽度，然后添加margin:0 auto属性1234div&#123; width:200px; margin:0 auto; &#125;让绝对定位的div居中1234567891011div &#123; position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: bule; &#125;水平垂直居中确定容器的宽高 宽500 高 300 的层 设置元素的外边距1234567891011div &#123; position: relative; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; margin-top: -150px； margin-left: -250px; /* 外边距为自身宽高的一半 */ //margin:-150px 0 0 -250px; /*一样*/ background-color: blue; &#125;未知容器的宽高，利用 transform 属性123456789div &#123; position: absolute; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: blue; &#125;利用 flex 布局12345678910.container &#123; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ &#125; .container div &#123; width: 100px; height: 100px; background-color: blue; &#125;HTML 文本格式化标签标签描述b定义粗体文本em定义着重文本i定义斜体字small定义小号字strong定义加重语气（HTML5 推荐粗体）sub定义下标字sup定义上标字ins定义插入字del定义删除线粗体、斜体、下划线（最好使用CSS语法代替）em/strong/: 我们并不反对使用这个标签，但是如果您只是为了达到某种视觉效果而使用这个标签的话，我们建议您使用 CSS ，这样可能会取得更丰富的效果。small : small 标签定义小型文本（和旁注）。del和ins : &lt;del 和 &lt;ins 一起使用，描述文档中的更新和修正。浏览器通常会在已删除文本上添加一条删除线，在新插入文本下添加一条下划线HTML “计算机输出” 标签标签描述code定义计算机代码kbd定义键盘码samp定义计算机代码样本var定义变量pre定义预格式文本kdb : kbd 标签定义键盘文本。提示: kbd标签已废弃，不推荐使用，但 是可以通过CSS实现丰富的效果code : code标签是一个短语标签，用来定义计算机代码文本samp标签是一个短语标签，用来定义计算机程序的样本文本。var标签是一个短语标签，用来定义变量。abbr 标签用来表示一个缩写词或者首字母缩略词，如”WWW”或者”NATO”通过对缩写词语进行标记，您就能够为浏览器、拼写检查程序、翻译系统以及搜索引擎分度器提供有用的信息。samp/var : 我们并不反对使用这个标签，但是如果您只是为了达到某种视觉效果而使用这个标签的话，我们建议您使用 CSS ，这样可能会取得更丰富的效果。HTML 引文, 引用, 及标签定义标签描述abbr定义缩写address定义地址bdo定义文字方向blockquote定义长的引用q定义短的引用语cite定义引用、引证dfn定义一个定义项目。address标签定义文档作者/所有者的联系信息如果address元素位于 body元素内部，则它表示该文档作者/所有者的联系信息。如果 address元素位于 article 元素内部，则它表示该文章作者/所有者的联系信息。address 元素的文本通常呈现为斜体。大多数浏览器会在该元素的前后添加换行。提示：不应该使用 address 标签来描述邮政地址，除非这些信息是联系信息的组成部分。提示：address 元素通常被包含在footer元素的其他信息中。bdo 指的是 bidi 覆盖（Bi-Directional Override）。 [ ltr : left to right / rtl : right to left ]bdo标签用来覆盖默认的文本方向。bdo元素一般用于把一段文本的方向规定为与周围文本的自然方向相反的方向。方向由必需属性dir指定。bdo元素很少使用，只用于某些多语言文档。在这种文档中，可能有某一段文本使用的语言的阅读方式与文档中其他部分使用的语言的阅读方式不同。blockquote&gt; 标签定义摘自另一个源的块引用。浏览器通常会对 blockquote元素进行缩进。提示：如果标记是不需要段落分隔的短引用，请使用qq&gt; 标签定义一个短的引用。浏览器经常会在这种引用的周围插入引号。提示：请使用blockquote来标记摘自另一个源的块引用。cite&gt; 标签定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等等）的标题。注释：人名不属于作品的标题。dfn&gt; 标签是一个短语标签，用来定义一个定义项目。dfn : 我们并不反对使用这个标签，但是如果您只是为了达到某种视觉效果而使用这个标签的话，我们建议您使用 CSS ，这样可能会取得更丰富的效果。HTML元素分类：inline、inline-block、blockinlinetextarea、span、a、img、input、select行内元素特征：设置宽高无效对margin仅设置左右方向有效，上下无效；padding设置上下左右都有效，即会撑大空间,行内元素尺寸 由内含的内容决定，盒模型中 padding, border 与块级元素并无差异，都是标准的盒模型，但是 margin 却只有水平方向的值，垂直方向并没有起作用。行内元素的水平方向的padding-left,padding-right,margin- left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都 不会产生边距效果。padding设置上下左右都有效，即会撑大空间但是不会产生边距效果。不会自动进行换行元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。inline-block行内块状元素特征：不自动换行能够识别宽高默认排列方式为从左到右blockdiv、p、ul、h1等标题元素、ol、form、table块状元素特征：能够识别宽高margin和padding的上下左右均对其有效可以自动换行多个块状元素标签写在一起，默认排列方式为从上至下inline-block和float的区别文档流（Document flow）:浮动元素会脱离文档流，并使得周围元素环绕这个元素。而inline-block元素仍在文档流内。因此设置inline-block不需要清除浮动。当然，周围元素不会环绕这个元素，你也不可能通过清除inline-block就让一个元素跑到下面去。水平位置（Horizontal position）：很明显你不能通过给父元素设置text-align:center让浮动元素居中。事实上定位类属性设置到父元素上，均不会影响父元素内浮动的元素。但是父元素内元素如果设置了display：inline-block，则对父元素设置一些定位属性会影响到子元素。（这还是因为浮动元素脱离文档流的关系）。垂直对齐（Vertical alignment）：inline-block元素沿着默认的基线对齐。浮动元素紧贴顶部。你可以通过vertical属性设置这个默认基线，但对浮动元素这种方法就不行了。这也是我倾向于inline-block的主要原因。空白（Whitespace）：inline-block包含html空白节点。如果你的html中一系列元素每个元素之间都换行了，当你对这些元素设置inline-block时，这些元素之间就会出现空白。而浮动元素会忽略空白节点，互相紧贴.scrolling=”no”隐藏滚动条html很多标签都有默认样式，因此最好在样式中一开始就给表单标签去除默认的样式问题123&lt;style type="text/css"&gt; input,select,option,textarea&#123;outline: none;&#125;&lt;/style&gt;TIPS1&lt;body onload=&quot;init()&quot;&gt;//打开页面的同时调用initOTHER（应合理分类并及时归类）]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emmet]]></title>
    <url>%2F2019%2F05%2F19%2FEmmet%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[html缩写id（#）,class（.）id指令: #class指令: .div#test1&lt;div id="test"&gt;&lt;/div&gt;div.test1&lt;div class="test"&gt;&lt;/div&gt;子节点（&gt;），兄弟节点（+），上级节点（^）子节点指令: &gt;兄弟节点指令: +上级节点: ^div&gt;ul&gt;li&gt;p1234567&lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;div+ul+p123&lt;div&gt;&lt;/div&gt;&lt;ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;div&gt;ul&gt;li^div(这里的^是接在li后面所以在li的上一级，与ul成了兄弟关系,当然两个^^就是上上级）123456&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;重复（*）重复指令：*div5（号后面添加数字表示重复的元素个数）12345&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;分组（()）分组指令：()div&gt;(ul&gt;li&gt;a)+div&gt;p（括号里面的内容为一个代码块，表示与括号内部嵌套和外面的的层级无关）12345678&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;解释：这里如果不加括号的话，猜想下，a+div这样div就是和a是兄弟关系了，会包含在li里面。懂了吧哈哈123456789&lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=""&gt;&lt;/a&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul属性（[attr]）——id，class都有怎么能少了属性呢属性指令：[]a[href=’###’ name=‘xiaoA’]（中括号内填写属性键值对的形式，并且空格隔开）1&lt;a href="###" name="xiaoA"&gt;&lt;/a&gt;编号 $ul&gt;li.test$*3（$代表一位数，后面更上数字就代表从1递增到填写的数字）12345&lt;ul&gt; &lt;li class="test1"&gt;&lt;/li&gt; &lt;li class="test2"&gt;&lt;/li&gt; &lt;li class="test3"&gt;&lt;/li&gt;&lt;/ul&gt;注意：一个$ 代表一位数，如果想自定义从几开始递增的话就利用：$@+数字数字ul&gt;li.test$@3312345&lt;ul&gt; &lt;li class="test33"&gt;&lt;/li&gt; &lt;li class="test34"&gt;&lt;/li&gt; &lt;li class="test35"&gt;&lt;/li&gt;&lt;/ul&gt;文本（{}）文本指令：{}ul&gt;li.test$*3{测试$}（{里面填写内容，可以和$一起组合使用哦}）12345&lt;ul&gt; &lt;li class="test1"&gt;测试1&lt;/li&gt; &lt;li class="test2"&gt;测试2&lt;/li&gt; &lt;li class="test3"&gt;测试3&lt;/li&gt;&lt;/ul&gt;隐式标签这个标签没有指令，而是部分标签可以不使用输入标签，直接输入指令，即可识别父类标签。例如：.test1&lt;div class="test"&gt;&lt;/div&gt;ul&gt;.test$*312345&lt;ul&gt; &lt;li class="test1"&gt;&lt;/li&gt; &lt;li class="test2"&gt;&lt;/li&gt; &lt;li class="test3"&gt;&lt;/li&gt;&lt;/ul&gt;select&gt;.test$*51234567&lt;select name="" id=""&gt; &lt;option class="test1"&gt;&lt;/option&gt; &lt;option class="test2"&gt;&lt;/option&gt; &lt;option class="test3"&gt;&lt;/option&gt; &lt;option class="test4"&gt;&lt;/option&gt; &lt;option class="test5"&gt;&lt;/option&gt;&lt;/select&gt;等等…隐私标签有如下几个：li：用于 ul 和 ol 中tr：用于 table、tbody、thead 和 tfoot 中td：用于 tr 中option：用于 select 和 optgroup 中CSS缩写值比如要定义元素的宽度，只需输入w100，即可生成1width: 100px;width:30px==&gt;w30+tabHeight:30px==&gt;h30+tabMargin:30px==&gt;mg30+tabPadding:30px==&gt; pd30+tabLine-height:12px==&gt;lh12px+tabBackground==&gt;bg+tabBackground-color==&gt;bgc+tab除了px，也可以生成其他单位，比如输入h10p+m5e，结果如下：121. height: 10%; 2. margin: 5em;单位别名列表：p 表示%e 表示 emx 表示 ex附加属性可能你之前已经了解了一些缩写，比如 @f，可以生成：12341. @font-face &#123; 2. font-family:; 3. src:url(); 4. &#125;一些其他的属性，比如background-image、border-radius、font、@font-face,text-outline、text-shadow等额外的选项，可以通过“+”符号来生成，比如输入@f+，将生成：123456789101. @font-face &#123; 2. font-family: 'FontName'; 3. src: url('FileName.eot'); 4. src: url('FileName.eot?#iefix') format('embedded-opentype'), 5. ​ url('FileName.woff') format('woff'), 6. ​ url('FileName.ttf') format('truetype'), 7. ​ url('FileName.svg#FontName') format('svg'); 8. font-style: normal; 9. font-weight: normal; 10. &#125;模糊匹配如果有些缩写你拿不准，Emmet会根据你的输入内容匹配最接近的语法，比如输入ov:h、ov-h、ovh和oh，生成的代码是相同的：1overflow: hidden;供应商前缀如果输入非W3C标准的CSS属性，Emmet会自动加上供应商前缀，比如输入trs，则会生成：123451. -webkit-transform: ; 2. -moz-transform: ; 3. -ms-transform: ; 4. -o-transform: ; 5. transform: ;你也可以在任意属性前加上“-”符号，也可以为该属性加上前缀。比如输入-super-foo：123451. -webkit-super-foo: ; 2. -moz-super-foo: ; 3. -ms-super-foo: ; 4. -o-super-foo: ; 5. super-foo: ;如果不希望加上所有前缀，可以使用缩写来指定，比如-wm-trf表示只加上-webkit和-moz前缀：1231. -webkit-transform: ; 2. -moz-transform: ; 3. transform: ;前缀缩写如下：w 表示 -webkit-m 表示 -moz-s 表示 -ms-o 表示 -o-渐变输入lg(left, #fff 50%, #000)，会生成如下代码：123451. background-image: -webkit-gradient(linear, 0 0, 100% 0, color-stop(0.5, #fff), to(#000)); 2. background-image: -webkit-linear-gradient(left, #fff 50%, #000); 3. background-image: -moz-linear-gradient(left, #fff 50%, #000); 4. background-image: -o-linear-gradient(left, #fff 50%, #000); 5. background-image: linear-gradient(left, #fff 50%, #000);Tips供给带有单位的值默认地，当展开带有整数值的缩写时，Emmet 输出会带有 px 单位：m10 →margin: 10px;。若是展开的缩写带有浮点娄，输出将带有 em 单位：m1.5 →margin: 1.5em;。不过也可以经由过程在值的后面放置随便率性的字母来明白指定单位： m1.5ex → margin: 1.5ex;， m10foo → margin: 10foo;。若是明白定义了单位，不须要应用连字符分隔各个值： m10ex20em →margin: 10ex 20em;， m10ex-5 → margin: 10ex -5px;。值别号Emmet 有几个常用的别号：p → ％e → emx → ex可以用这些别号来庖代完全的单位：·w100p → width: 100％m10p30e5x → margin: 10％ 30em 5ex色彩值Emmet 付出16进制地色彩值，例如： c＃3 → color: ＃333;。＃ 符号是值的分隔符，所以不须要应用连字符做分隔。例如 bd5＃0s 展开成 border: 5px ＃000 solid: 。5 被从色彩值的 ＃ 到 s （solid的别号）从色彩平分隔出来，因为 s 不是16进制的字符，不须要用 `-` 分隔符。可以以 1个、2个、3个或者6个数字的情势书写色彩值：＃1 → ＃111111＃e0 → ＃e0e0e0＃fc0 → ＃ffcc00当 css.color.short 引用 可用时（默认），类似 ＃ffcc00 如许的值会主动简化成 ＃fc0。也可以按照 css.color.case 引用主动改变大小写。无单位的值一些 CSS 属性被定义为无单位，例如 lh2 → line-height: 2;，fw400 → font-weight: 400;。这些值是: &quot;&quot;z-index、 line-height、 opacity 和 font-weight ，可以哄骗 css.unitlessProperties 引用来覆盖它们。!important 润饰符可以在任何 CSS 缩写后面添加 ! 下标来获得 !important 值：1p!+m10e!将生成12padding: !important;margin: 10em !important;Vendor 前缀CSS3 的新特点为 web 法度员带来了福音：很少的几行代码就能完成几年前近乎不成能实现的任务。但同时这些特点对带来了疾苦：必须为不合的浏览器编写多个雷同的属性。Emmet 的 CSS 解析器有一个很奇妙的特点，可以明显进步编写 CSS3 的体验。每次在 CSS 属性或缩写前添加连字符，Emmet 就主动为每个属性创建带有 vendor 前缀的副本。例如，-bdrs 缩写将展开成：1234//code from http://caibaojian.com/emmet-doc-3.html-webkit-border-radius: ;-moz-border-radius: ;border-radius: ;此外，在支撑 tabstop 的编辑器（例如 Eclipse、 Sublime Text 2、 Espresso 等）中，Emmet 将建树值占位符，法度员可以输入属性值并主动放到全部生成的属性中。它如何工作？展开前面带有连字符的缩写时，Emmet 删除连字符并在 snippets.json 查找残剩的缩写的片段定义。例如 -bdrs 缩写将会在 snippet.json 中查找 bdrs 定义，定义的内容如下：1&quot;bdrs&quot;: &quot;border-radius:|;&quot;也就是说 bdrs 将被展开成 border-radius 属性。若是定义没有找到，缩写本身将被当成 CSS 属性名。经过 CSS 解析器策画出的属性将被输出，它将查找特定的在特定的 vendor 分类是否呈现。这些分类定义设置中的 css.{vendor}Properties 分支。 {vendor} 是浏览器的 vendor 前缀，例如 webkit、 moz 等。若是扩大属性在这些分类中被找到，它们的 vendor 前缀将用作前导属性。不然，所有的前缀将被应用。例如，border-radius 被定义在 css.webkitProperties 和 css.mozProperties中，所以这个属性的输出将带有 webkit 和 moz 前缀。另一种景象，foo 属性没有定义在任何 vendor 分类中，所以在展开 -foo 缩写时，将输出所有可用的前缀：： webkit， moz， ms and o.。它对眼下所实现的那些前沿的 CSS 属性希罕有效。假设 Google Chrome 昨天方才实现了 super-foo ，而你如今就想在项目中应用它。可以应用 -super-foo 属性，展开成果如下：12345-webkit-super-foo: ;-moz-super-foo: ;-ms-super-foo: ;-o-super-foo: ;super-foo: ;默认添加前缀属性在编写 CSS 文件时，也许要查找不带有 vendor 前缀变量的 CSS3 的 “clear” 属性。这会使编写类似 -trf （trf 是 transform 的别号） 如许带有前导连字符的缩写很难堪。这也是为什么默认景象下 Emmet 会有 css.autoInsertVendorPrefixes 选项的原因。这个属性生效，所有定义在 vendor 分类中的 CSS 属性都将被主动供给匹配的 vendor 前缀变量。这意味着，无需应用连字符来为已知的 CSS 属性获取有效的前缀变量，直接展开 bdrs 或 trf 缩写就可以获得有效的 vendor 前缀属性。明白地 vendor 前缀有时可能会想要输出仅带有指定 vendor 前缀属性的 CSS 属性。假定想要输出仅带有 webkit 和 moz 前缀的 transform 属性，可以编写如下缩写：1-wm-trf正如所见到的那样，我们经由过程添加一个字符前缀列表对缩写略作批改。在这种景象下，添加的是 w （webkit） 和 m （moz） 前缀。Emmet 的单字母前缀如下：w: webkitm: mozs: mso: o渐变编写 CSS3 特点的另一个难点是渐变。必须为多个 vendor 前缀多次反复长长地渐变定义。同时，要想覆盖所有支撑渐变的浏览器，就必须应用三种不合的注解：旧的 Webkit，当前支撑 （linear-gradient（top， ...）） 和 W3C-推荐 （linear-gradient（to bottom， ...））。凡是，用户偏向于应用第三方 GUI 来生成渐变定义，然则在编辑器中做同样的工作会更快。Emmet 的 CSS3 渐变生成器可以或许帮你分忧：正像上方显现的那样，可以输入常规地渐变定义如 lg（...） （或 linear-gradient（...）） 函数，并算作一个缩写来展开。若是编写渐变定义来充当属性值，Emmet将解析它并应用它的名字作为新的 CSS 属性的引用。备用值在偏爱设置中，可以使 css.gradient.fallback 选项有效，当渐变定义 background-* CSS 属性展开时，产生一个备用的 background-colorCSS 属性。这个备用属性将包含来自渐变定义的第一个色彩。为个选项默认是封闭的，这是因为它所产生的 background-color 值几乎可以必然须要手动进级，以确保这个靠山的内容可读。若是确切不在乎旧浏览器，就可以打开这个选项。模糊查找若是查阅 总览表，就会发明有很多 CSS 片段要记忆。并且它们中的一项目组为了分隔逻辑变得很长。为了使 CSS 的编写更简单，Emmet 为 CSS 片段实现了模糊查找逻辑：每次输入一个未知的缩写，Emmet 老是试图找到类似的片段定义。例如，作为 ov:h （overflow: hidden;） 缩写的调换，可以输入 ov-h、 ovh 或者干脆输入 oh。拜见下面的示例。演示了 bxz:cb、ovx:h 和 pos:a 片段的不合示例模糊查找只针对预定义的片段名，不支撑片段值或 CSS 属性。这个成果更好猜测和把握匹配。记住 可以创建本身的片段或重定义已存在的片段 来调剂模糊查找的体验生成Lorem ipsum文本Lorem ipsum指一篇常用于排版设计领域的拉丁文文章，主要目的是测试文章或文字在不同字型、版型下看起来的效果。通过Emmet，你只需输入lorem 或 lipsum即可生成这些文字。还可以指定文字的个数，比如lorem10，将生成：引用1Lorem ipsum dolor sit amet, consectetur adipisicing elit. Libero delectus.定制你还可以定制Emmet插件：添加新缩写或更新现有缩写，可修改snippets.json文件更改Emmet过滤器和操作的行为，可修改preferences.json文件定义如何生成HTML或XML代码，可修改syntaxProfiles.json文件]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO写作]]></title>
    <url>%2F2019%2F05%2F19%2FFront-matter%2F</url>
    <content type="text"><![CDATA[Front-matterFront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说：1234---title: Hello Worlddate: 2013/7/13 20:46:25---以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。参数描述默认值layout布局title标题date建立日期文件建立日期updated更新日期文件更新日期comments开启文章的评论功能truetags标签（不适用于分页）categories分类（不适用于分页）permalink覆盖文章网址&nbsp;分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。12345categories:- Diarytags:- PS3- Games分类方法的分歧如果您有过使用WordPress的经验，就很容易误解Hexo的分类方式。WordPress支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。下面的指定方法：categories:- Diary- Life会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。JSON Front-matter除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 --- 代换成 ;;; 即可。123&quot;title&quot;: &quot;Hello World&quot;,&quot;date&quot;: &quot;2013/7/13 20:46:25&quot;;;;你可以执行下列命令来创建一篇新文章。1$ hexo new [layout] &lt;title&gt;您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。布局（Layout）Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。布局路径postsource/_postspagesourcedraftsource/_drafts不要处理我的文章如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。文件名称Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。变量描述:title标题（小写，空格将会被替换为短杠）:year建立的年份，比如， 2015:month建立的月份（有前导零），比如， 04:i_month建立的月份（无前导零），比如， 4:day建立的日期（有前导零），比如， 07:i_day建立的日期（无前导零），比如， 7草稿刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，您可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。1$ hexo publish [layout] &lt;title&gt;草稿默认不会显示在页面中，您可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true来预览草稿。模版（Scaffold）在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：1$ hexo new photo &quot;My Gallery&quot;在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量：变量描述layout布局title标题date文件建立日期]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown文档Typora编辑器用法]]></title>
    <url>%2F2019%2F05%2F10%2FMarkDown%E6%96%87%E6%A1%A3Typora%E7%BC%96%E8%BE%91%E5%99%A8%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、标题使用简单的 ctrl+数字键 就可以快速完成各种级别的标题2、下划线ctrl + u3、删除线alt + shift + 54、字体加粗ctrl + b5、字体倾斜ctrl + i6、无序列表“-” + space + enter嵌套无序列表7、有序列表数字键 + space + enter8、引用“&gt;” + space + enter 或者 ctrl + shift + q9、插入链接ctrl + k10、插入图片本地直接拖拉图片到 md 文件或者配合 MPic完成图片上传图床并复制链接到 md 文件（推荐）或者ctrl + shift + i11、代码块ctrl + shift + f，支持 java，python，groovy 等 绝大多数编程语言12、文章跳转ctrl + home 跳转至文章开头，ctrl + end 跳转至文章末尾，这个就不再演示了13、选中英文单词/中文ctrl + d 或者 ctrl + shift + left/right 左右进行文本选中14、英文错误提示并自动修改15、按行选中ctrl + l16、快速搜索ctrl + f支持区分英文大小写和整个单词搜索，也支持中文搜索17、替换ctrl + h18、快速生成表格ctrl + t19、快速打开笔记ctrl + p20、toc 快速生成目录[toc] + enter21、着重关键字ctrl + shift + 反引号键（tab 键上面那个键）因为主题原因这里看不出来，换个主题就很明显了22、表情符号英文状态下的引号，输入字母自动显示表情符号还有一种方式，使用输入法的快捷键，这里我使用的是微软输入法 ctrl + shift + b23、新建文件ctrl + n，这个就不再演示了24、显示和隐藏侧边栏ctrl + shift + l25、全屏切换f11 这个就不再演示了26、分割线— + enter，这个也不再演示27、高亮显示==文字==，这个也不再演示28、创建表格Ctrl + T29、段落快捷键ctrl + 030、定义脚注文字 [ + ^ + 脚注 + ]31、插入URL链接&lt; + 链接 + &gt;]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
