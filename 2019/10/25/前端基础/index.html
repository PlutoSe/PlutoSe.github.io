<!-- build time:Tue Jan 12 2021 08:41:27 GMT+0000 (Greenwich Mean Time) --><!DOCTYPE html><html class="theme-next pisces" lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><style>.pace .pace-progress{background:#1E92FB;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1E92FB,0 0 5px #1E92FB}.pace .pace-activity{border-top-color:#1E92FB;border-left-color:#1E92FB}</style><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css"><link href="//fonts.cat.net/css?family=Sigmar One:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet" type="text/css"><link href="https://cdn.bootcss.com/social-share.js/1.0.9/css/share.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=0.0.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=0.0.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/logo.png?v=0.0.4"><link rel="mask-icon" href="/images/logo.svg?v=0.0.4" color="#222"><meta name="keywords" content="Silver,blog"><meta name="description" content="HTML 篇图片中 title 和 alt 区别？通常当鼠标滑动到元素上的时候显示alt是的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。Html5 有哪些新特性、移除了哪些元素新增元素：* 绘画`canvas` * 用于媒介回放的`video 和 audio`元素 * 本地离线存储`loca"><meta property="og:type" content="article"><meta property="og:title" content="前端基础"><meta property="og:url" content="http://Sept_Oct.coding.me/2019/10/25/前端基础/index.html"><meta property="og:site_name" content="Silver_Blog"><meta property="og:description" content="HTML 篇图片中 title 和 alt 区别？通常当鼠标滑动到元素上的时候显示alt是的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。Html5 有哪些新特性、移除了哪些元素新增元素：* 绘画`canvas` * 用于媒介回放的`video 和 audio`元素 * 本地离线存储`loca"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2021-01-12T08:40:46.265Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="前端基础"><meta name="twitter:description" content="HTML 篇图片中 title 和 alt 区别？通常当鼠标滑动到元素上的时候显示alt是的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。Html5 有哪些新特性、移除了哪些元素新增元素：* 绘画`canvas` * 用于媒介回放的`video 和 audio`元素 * 本地离线存储`loca"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"0.0.4",sidebar:{position:"right",display:"post",offset:52,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},since:"03/10/2019 11:16:00",onlineAPI:"",site:{title:"Silver_Blog",subtitle:"",author:"SilverFT"},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},leancloud:{enable:!0,appID:"vVP8GnLAUmXadgFMnysWVDkg-9Nh9j0Va",appKey:"W1qwWav1CkVNJEPIUiSSRkqz"},favicon:{visibilitychange:!0,narmal:"/images/logo.png",hidden:"/images/failure.ico",show_text:"(/≧▽≦/)咦！又好了！",hide_text:"(●—●)喔哟，崩溃啦！"}}</script><script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script><link rel="canonical" href="http://Sept_Oct.coding.me/2019/10/25/前端基础/"><title>前端基础 | Silver_Blog</title><script>!function(e,t,a,n,c,s,o){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,s=t.createElement(a),o=t.getElementsByTagName(a)[0],s.async=1,s.src=n,o.parentNode.insertBefore(s,o)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-48084758-7","auto"),ga("send","pageview")</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-right page-post-detail"><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-时间线"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i><br>时间线</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav><div class="site-brand-wrapper" style="background-image:url(/images/header.jpg)"><div class="site-meta"><div class="custom-logo-site-title"><div class="brand"><span class="logo-line-before"><i></i></span><div class="site-title"><div id="animate" class="animate"><span>S</span><span>i</span><span>l</span><span>v</span><span>e</span><span>r</span><span>_</span><span>B</span><span>l</span><span>o</span><span>g</span></div><div id="guide" class="guide"><span>S</span><span>i</span><span>l</span><span>v</span><span>e</span><span>r</span><span>_</span><span>B</span><span>l</span><span>o</span><span>g</span></div></div><span class="logo-line-after"><i></i></span></div></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><div class="site-master" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-master-avatar" itemprop="image" src="/images/injahow.jpg" alt="SilverFT"><h2 class="site-master-description" itemprop="description"></h2></div></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">10月</div><div class="post-day">25</div></div><div class="post-block"><link itemprop="mainEntityOfPage" href="http://Sept_Oct.coding.me/2019/10/25/前端基础/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="SilverFT"><meta itemprop="description" content><meta itemprop="image" content="/images/injahow.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Silver_Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">前端基础</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-25T23:13:29+00:00">2019-10-25 </time></span><span id="/2019/10/25/前端基础/" class="leancloud_visitors" data-flag-title="前端基础"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors&#58;</span> <span class="leancloud-visitors-count"></span> <span>℃</span></span><div class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Words count in article&#58;</span> <span title="Words count in article">13.2k</span></div></div></header><div class="post-body" itemprop="articleBody"><script src="\assets\js\APlayer.min.js"></script><h2 id="HTML-篇"><a href="#HTML-篇" class="headerlink" title="HTML 篇"></a>HTML 篇</h2><h3 id="图片中-title-和-alt-区别？"><a href="#图片中-title-和-alt-区别？" class="headerlink" title="图片中 title 和 alt 区别？"></a>图片中 title 和 alt 区别？</h3><ul><li>通常当鼠标滑动到元素上的时候显示</li><li><code>alt</code>是的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</li></ul><h3 id="Html5-有哪些新特性、移除了哪些元素"><a href="#Html5-有哪些新特性、移除了哪些元素" class="headerlink" title="Html5 有哪些新特性、移除了哪些元素"></a>Html5 有哪些新特性、移除了哪些元素</h3><p>新增元素：</p><pre><code>* 绘画`canvas`
* 用于媒介回放的`video 和 audio`元素
* 本地离线存储`localStorage`长期存储数据，浏览器关闭后数据不丢失
* `sessionStorage`的数据在浏览器关闭后自动删除
* 语义化更好的内容元素，比如`article 、footer、header、nav、section`
* 表单控件 ，`calendar 、 date 、 time 、 email 、 url 、 search`
* 新的技术`webworker 、 websocket 、 Geolocation`
</code></pre><ul><li><p>移除的元素：</p><ul><li>纯表现的元素：<code>basefont 、 big 、 center 、 font 、 s 、 strike 、 tt 、 u</code></li><li>对可用性产生负面影响的元素：<code>frame 、 frameset 、 noframes</code></li></ul></li><li><p>支持 HTML5 新标签：</p><ul><li><code>IE8/IE7/IE6</code>支持通过<code>document.createElement</code>方法产生的标签</li><li>可以利用这一特性让这些浏览器支持<code>HTML5</code>新标签</li><li>浏览器支持新标签后，还需要添加标签默认的样式</li></ul></li></ul><p>-</p><h3 id="浏览器是怎么对-Html5-的离线储存资源进行管理和加载的呢"><a href="#浏览器是怎么对-Html5-的离线储存资源进行管理和加载的呢" class="headerlink" title="浏览器是怎么对 Html5 的离线储存资源进行管理和加载的呢"></a>浏览器是怎么对 Html5 的离线储存资源进行管理和加载的呢</h3><p>如何使用：</p><ul><li>页面头部像下面一样加入一个<code>manifest</code>的属性；</li><li>在<code>cache.manifest</code>文件的编写离线存储的资源</li><li>在离线状态时，操作<code>window.applicationCache</code>进行需求实现</li></ul><p>在线的情况下，浏览器发现<code>html</code>头部有<code>manifest</code>属性，它会请求<code>manifest</code>文件，如果是第一次访问<code>app</code>，那么浏览器就会根据<code>manifest</code>文件的内容下载相应的资源并且进行离线存储。如果已经访问过<code>app</code>并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的<code>manifest</code>文件与旧的<code>manifest</code>文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</p><h3 id="iframe-有那些缺点？"><a href="#iframe-有那些缺点？" class="headerlink" title="iframe 有那些缺点？"></a>iframe 有那些缺点？</h3><ul><li><code>iframe</code>会阻塞主页面的<code>Onload</code>事件</li><li>搜索引擎的检索程序无法解读这种页面，<code>不利于 SEO</code></li><li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li><li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li></ul><h3 id="HTML-W3C-的标准"><a href="#HTML-W3C-的标准" class="headerlink" title="HTML W3C 的标准"></a>HTML W3C 的标准</h3><p>标签闭合、标签小写、不乱嵌套、使用外链 css 和 js 、结构行为表现的分离</p><h3 id="Doctype-作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#Doctype-作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?</h3><ul><li><code>&lt;!DOCTYPE&gt;</code>声明位于文档中的最前面，处于<code>html</code>标签之前。告知浏览器的解析器， 用什么文档类型、规范来解析这个文档</li><li>严格模式的排版和<code>JS</code>运作模式是 以该浏览器支持的最高标准运行</li><li>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作<code>DOCTYPE</code>不存在或格式不正确会导致文档以混杂模式呈现</li></ul><h3 id="HTML-全局属性-global-attribute-有哪些"><a href="#HTML-全局属性-global-attribute-有哪些" class="headerlink" title="HTML 全局属性(global attribute)有哪些"></a>HTML 全局属性(global attribute)有哪些</h3><ul><li><code>class</code>:为元素设置类标识</li><li><code>data-*</code>: 为元素增加自定义属性</li><li><code>draggable</code>: 设置元素是否可拖拽</li><li><code>id</code>: 元素 id ，文档内唯一</li><li><code>lang</code>: 元素内容的的语言</li><li><code>style</code>: 行内 css 样式</li><li><code>title</code>: 元素相关的建议信息</li></ul><h3 id="viewport-的-content-属性作用"><a href="#viewport-的-content-属性作用" class="headerlink" title="viewport 的 content 属性作用"></a>viewport 的 content 属性作用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;&quot; /&gt;</span><br><span class="line">    width viewport的宽度[device-width | pixel_value]width如果直接设置pixel_value数值，大部分的安卓手机不支持，但是ios支持；</span><br><span class="line">    height – viewport 的高度 （范围从 223 到 10,000 ）</span><br><span class="line">    user-scalable [yes | no]是否允许缩放</span><br><span class="line">    initial-scale [数值] 初始化比例（范围从 &gt; 0 到 10）</span><br><span class="line">    minimum-scale [数值] 允许缩放的最小比例</span><br><span class="line">    maximum-scale [数值] 允许缩放的最大比例</span><br><span class="line">    target-densitydpi 值有以下（一般推荐设置中等响度密度或者低像素密度，后者设置具体的值dpi_value，另外webkit内核已不准备再支持此属性）</span><br><span class="line">         -- dpi_value 一般是70-400//没英寸像素点的个数</span><br><span class="line">         -- device-dpi设备默认像素密度</span><br><span class="line">         -- high-dpi 高像素密度</span><br><span class="line">         -- medium-dpi 中等像素密度</span><br><span class="line">         -- low-dpi 低像素密度</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>附带问题：怎样处理 移动端 1px 被 渲染成 2px 问题?</p><p>局部处理：</p><ul><li><code>mate</code>标签中的<code>viewport</code>属性 ，<code>initial-scale</code>设置为 1</li><li><code>rem</code>按照设计稿标准走，外加利用<code>transfrome 的 scale(0.5)</code>缩小一倍即可；</li></ul><p>全局处理：</p><ul><li><code>mate</code>标签中的<code>viewport</code>属性 ，<code>initial-scale</code>设置为 0.5</li><li><code>rem</code>按照设计稿标准走即可</li></ul><h3 id="meta-相关"><a href="#meta-相关" class="headerlink" title="meta 相关"></a>meta 相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; &lt;!--H5标准声明，使用 HTML5 doctype，不区分大小写--&gt;</span><br><span class="line">&lt;head lang=”en”&gt; &lt;!--标准的 lang 属性写法--&gt;</span><br><span class="line">&lt;meta charset=’utf-8′&gt; &lt;!--声明文档使用的字符编码--&gt;</span><br><span class="line">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt; &lt;!--优先使用指定浏览器使用特定的文档模式--&gt;</span><br><span class="line">&lt;meta name=”description” content=”不超过150个字符”/&gt; &lt;!--页面描述--&gt;</span><br><span class="line">&lt;meta name=”keywords” content=””/&gt; &lt;!-- 页面关键词--&gt;</span><br><span class="line">&lt;meta name=”author” content=”name, email@gmail.com”/&gt; &lt;!--网页作者--&gt;</span><br><span class="line">&lt;meta name=”robots” content=”index,follow”/&gt; &lt;!--搜索引擎抓取--&gt;</span><br><span class="line">&lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-sc</span><br><span class="line">&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt; &lt;!--iOS 设备 begin--&gt;</span><br><span class="line">&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt; &lt;!--添加到主屏后的标</span><br><span class="line">是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏--&gt;</span><br><span class="line">&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;</span><br><span class="line">&lt;meta name=”renderer” content=”webkit”&gt; &lt;!-- 启用360浏览器的极速模式(webkit)--&gt;</span><br><span class="line">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt; &lt;!--避免IE使用兼容模式--&gt;</span><br><span class="line">&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt; &lt;!--不让百度转码--&gt;</span><br><span class="line">&lt;meta name=”HandheldFriendly” content=”true”&gt; &lt;!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器--&gt;</span><br><span class="line">&lt;meta name=”MobileOptimized” content=”320″&gt; &lt;!--微软的老式浏览器--&gt;</span><br><span class="line">&lt;meta name=”screen-orientation” content=”portrait”&gt; &lt;!--uc强制竖屏--&gt;</span><br><span class="line">&lt;meta name=”x5-orientation” content=”portrait”&gt; &lt;!--QQ强制竖屏--&gt;</span><br><span class="line">&lt;meta name=”full-screen” content=”yes”&gt; &lt;!--UC强制全屏--&gt;</span><br><span class="line">&lt;meta name=”x5-fullscreen” content=”true”&gt; &lt;!--QQ强制全屏--&gt;</span><br><span class="line">&lt;meta name=”browsermode” content=”application”&gt; &lt;!--UC应用模式--&gt;</span><br><span class="line">&lt;meta name=”x5-page-mode” content=”app”&gt; &lt;!-- QQ应用模式--&gt;</span><br><span class="line">&lt;meta name=”msapplication-tap-highlight” content=”no”&gt; &lt;!--windows phone</span><br><span class="line">设置页面不缓存--&gt;</span><br><span class="line">&lt;meta http-equiv=”pragma” content=”no-cache”&gt;</span><br><span class="line">&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;</span><br><span class="line">&lt;meta http-equiv=”expires” content=”0″&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/kongjiea/article/details/17092413" target="_blank" rel="noopener">了解更多参考：https://blog.csdn.net/kongjiea/article/details/17092413</a></p><h3 id="div-css-的布局较-table-布局有什么优点"><a href="#div-css-的布局较-table-布局有什么优点" class="headerlink" title="div+css 的布局较 table 布局有什么优点"></a>div+css 的布局较 table 布局有什么优点</h3><ul><li>改版的时候更方便 只要改<code>css</code>文件。</li><li>页面加载速度更快、结构化清晰、页面显示简洁。</li><li>表现与结构相分离。</li><li>易于优化<code>（ seo ）</code>搜索引擎更友好，排名更容易靠前。</li></ul><h3 id="src-与-href-的区别"><a href="#src-与-href-的区别" class="headerlink" title="src 与 href 的区别"></a>src 与 href 的区别</h3><ul><li><code>src</code>用于替换当前元素，<code>href</code>用于在当前文档和引用资源之间确立联系。</li><li><code>src</code>是<code>source</code>的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求<code>src</code>资源时会将其指向的资源下载并应用到文档内，例如<code>js</code>脚本，<code>img</code>图片和<code>frame</code>等元素</li></ul><blockquote><p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部</p></blockquote><p>-<code>href 是 Hypertext Reference</code>的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加 -<code>link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;</code>那么浏览器会识别该文档为<code>css</code>文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用<code>link</code>方式来加载<code>css</code>，而不是使用<code>@import</code>方式</p><h2 id="CSS-篇"><a href="#CSS-篇" class="headerlink" title="CSS 篇"></a>CSS 篇</h2><h3 id="link-与-import-的区别"><a href="#link-与-import-的区别" class="headerlink" title="link 与 @import 的区别"></a>link 与 @import 的区别</h3><ul><li><code>link</code>是<code>HTML</code>方式，<code>@import</code>是<code>CSS</code>方式</li><li><code>link</code>最大限度支持并行下载，<code>@import</code>过多嵌套导致串行下载，出现 FOUC (文档样式短暂失效)</li><li><code>link</code>可以通过<code>rel=&quot;alternate stylesheet&quot;</code>指定候选样式</li><li>浏览器对<code>link</code>支持早于<code>@import</code>，可以使用<code>@import</code>对老浏览器隐藏样式</li><li><code>@import</code>必须在样式规则之前，可以在<code>css</code>文件中引用其他文件</li><li>总体来说：<code>link</code>优于<code>@import</code>，<code>link</code>优先级也更高</li></ul><h3 id="BFC-有什么用"><a href="#BFC-有什么用" class="headerlink" title="BFC 有什么用"></a>BFC 有什么用</h3><p>创建规则：</p><pre><code>* 根元素
* 浮动元素（`float`不取值为`none`）
* 绝对定位元素（`position`取值为`absolute`或`fixed`）
* `display`取值为`inline-block 、 table-cell 、 table-caption 、 flex 、inline-flex`之一的元素
* `overflow`不取值为`visible`的元素
</code></pre><ul><li><p>作用</p><ul><li>可以包含浮动元素</li><li>不被浮动元素覆盖</li><li>阻止父子元素的<code>margin</code>折叠</li></ul></li></ul><p>-</p><h3 id="清除浮动的几种方式"><a href="#清除浮动的几种方式" class="headerlink" title="清除浮动的几种方式"></a>清除浮动的几种方式</h3><ul><li>父级<code>div</code>定义<code>height</code></li><li>结尾处加空<code>div</code>标签<code>clear:both</code></li><li>父级<code>div</code>定义伪类<code>:after</code>和<code>zoom</code></li><li>父级<code>div</code>定义<code>overflow:hidden</code></li><li>父级<code>div</code>也浮动，需要定义宽度</li><li>结尾处加<code>br</code>标签<code>clear:both</code></li></ul><h3 id="Css3-新增伪类-伪元素"><a href="#Css3-新增伪类-伪元素" class="headerlink" title="Css3 新增伪类 - 伪元素"></a>Css3 新增伪类 - 伪元素</h3><ul><li><code>p:first-of-type</code>选择属于其父元素的首个<p>元素的每个</p><p>元素。</p></li><li><code>p:last-of-type</code>选择属于其父元素的最后<p>元素的每个</p><p>元素。</p></li><li><code>p:only-of-type</code>选择属于其父元素唯一的<p>元素的每个</p><p>元素。</p></li><li><code>p:only-child</code>选择属于其父元素的唯一子元素的每个<p>元素。</p></li><li><code>p:nth-child(2)</code>选择属于其父元素的第二个子元素的每个<p>元素。</p></li><li><code>:enabled</code>已启用的表单元素。</li><li><code>:disabled</code>已禁用的表单元素。</li><li><code>:checked</code>单选框或复选框被选中。</li><li><code>::before</code>在元素之前添加内容。</li><li><code>::after</code>在元素之后添加内容,也可以用来做清除浮动。</li><li><code>::first-line</code>添加一个特殊的样式到文本的首字母。</li><li><code>::first-letter</code>添加一行特殊样式到首行。</li></ul><p>相信大家也看出来他们的不同，</p><ul><li>伪类语法一个：，它是为了弥补 css 常规类选择器的不足</li><li>伪元素语法两个：，它是凭空创建的一个虚拟容器生成的元素</li></ul><h3 id="IE-盒子模型-、W3C-盒子模型"><a href="#IE-盒子模型-、W3C-盒子模型" class="headerlink" title="IE 盒子模型 、W3C 盒子模型"></a>IE 盒子模型 、W3C 盒子模型</h3><p>W3C 盒模型： 内容(content)、填充( padding )、边界( margin )、 边框( border )；</p><pre><code>* `box-sizing: content-box`
* width = content width;
</code></pre><ul><li><p>IE 盒子模型： IE 的 content 部分把 border 和 padding 计算了进去;</p><ul><li><code>box-sizing: border-box</code></li><li>width = border + padding + content width</li></ul></li></ul><p>-</p><h3 id="display-inline-block-什么时候不会显示间隙？"><a href="#display-inline-block-什么时候不会显示间隙？" class="headerlink" title="display:inline-block 什么时候不会显示间隙？"></a>display:inline-block 什么时候不会显示间隙？</h3><ul><li>移除空格</li><li>使用<code>margin</code>负值</li><li>使用<code>font-size:0</code></li><li><code>letter-spacing</code></li><li><code>word-spacing</code></li></ul><h3 id="行内元素-float-left-后是否变为块级元素？"><a href="#行内元素-float-left-后是否变为块级元素？" class="headerlink" title="行内元素 float:left 后是否变为块级元素？"></a>行内元素 float:left 后是否变为块级元素？</h3><p>行内元素设置成浮动之后变得更加像是<code>inline-block</code>（行内块级元素，设置 成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是 100% ），这时候给行内元素设置<code>padding-top</code>和<code>padding-bottom</code>或者<code>width 、 height</code>都是有效果的</p><h3 id="如果需要手动写动画，你认为最小时间间隔是多久，为什么？"><a href="#如果需要手动写动画，你认为最小时间间隔是多久，为什么？" class="headerlink" title="如果需要手动写动画，你认为最小时间间隔是多久，为什么？"></a>如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h3><p>多数显示器默认频率是 60Hz ，即 1 秒刷新 60 次，所以理论上最小间隔为 1/60*1000ms ＝ 16.7ms</p><h3 id="CSS-不同选择器的权重-CSS-层叠的规则"><a href="#CSS-不同选择器的权重-CSS-层叠的规则" class="headerlink" title="CSS 不同选择器的权重(CSS 层叠的规则)"></a>CSS 不同选择器的权重(CSS 层叠的规则)</h3><ul><li><code>！important</code>规则最重要，大于其它规则</li><li>行内样式规则，加 1000</li><li>对于选择器中给定的各个 ID 属性值，加 100</li><li>对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加 10</li><li>对于选择其中给定的各个元素标签选择器，加 1</li><li>如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则</li></ul><h3 id="stylus-sass-less-区别"><a href="#stylus-sass-less-区别" class="headerlink" title="stylus/sass/less 区别"></a>stylus/sass/less 区别</h3><ul><li>均具有“变量”、“混合”、“嵌套”、“继承”、“颜色混合”五大基本特性</li><li><code>Sass</code>和<code>LESS</code>语法较为严谨，<code>LESS</code>要求一定要使用大括号“{}”，<code>Sass</code>和<code>Stylus</code>可以通过缩进表示层次与嵌套关系</li><li><code>Sass</code>无全局变量的概念，<code>LESS</code>和<code>Stylus</code>有类似于其它语言的作用域概念</li><li><code>Sass</code>是基于<code>Ruby</code>语言的，而<code>LESS</code>和<code>Stylus</code>可以基于<code>NodeJS NPM</code>下载相应库后进行编译；这也是为什么安装 Sass 的时候有时候会报错，需要安装 python 脚本</li></ul><p>优点：就不用我多说了，谁用谁知道，真香。</p><h3 id="rgba-和-opacity-的透明效果有什么不同？"><a href="#rgba-和-opacity-的透明效果有什么不同？" class="headerlink" title="rgba()和 opacity 的透明效果有什么不同？"></a>rgba()和 opacity 的透明效果有什么不同？</h3><ul><li><code>rgba()</code>和<code>opacity</code>都能实现透明效果，但最大的不同是<code>opacity</code>作用于元素，以及元素内的所有内容的透明度，</li><li>而<code>rgba()</code>只作用于元素的颜色或其背景色。（设置 rgba 透明的元素的子元素不会继承透明效果！）</li></ul><h3 id="水平居中的方法"><a href="#水平居中的方法" class="headerlink" title="水平居中的方法"></a>水平居中的方法</h3><ul><li>元素为行内元素，设置父元素<code>text-align:center</code></li><li>如果元素宽度固定，可以设置左右<code>margin 为 auto</code>;</li><li>如果元素为绝对定位，设置父元素<code>position 为 relative</code>，元素设<code>left:0;right:0;margin:auto;</code></li><li>使用<code>flex-box</code>布局，指定<code>justify-content</code>属性为<code>center</code></li><li><code>display</code>设置为<code>tabel-ceil</code></li></ul><h3 id="垂直居中的方法"><a href="#垂直居中的方法" class="headerlink" title="垂直居中的方法"></a>垂直居中的方法</h3><ul><li>将显示方式设置为表格，<code>display:table-cell</code>,同时设置<code>vertial-align：middle</code></li><li>使用<code>flex</code>布局，设置为<code>align-item：center</code></li><li>绝对定位中设置<code>bottom:0,top:0</code>,并设置<code>margin:auto</code></li><li>绝对定位中固定高度时设置<code>top:50%，margin-top</code>值为高度一半的负值</li><li>文本垂直居中设置<code>line-height</code>为<code>height</code>值</li></ul><h2 id="浏览器-篇"><a href="#浏览器-篇" class="headerlink" title="浏览器 篇"></a>浏览器 篇</h2><h3 id="浏览器内核的理解"><a href="#浏览器内核的理解" class="headerlink" title="浏览器内核的理解"></a>浏览器内核的理解</h3><ul><li>主要分两个部分：<code>渲染引擎</code>、<code>js引擎</code></li><li><code>渲染引擎：</code>负责取得网页的内容（html css img …），以及计算网页的显示方式，然后会输出至显示器或者打印机。浏览器的内核不同对于网页的语法解释也不同，所以渲染的效果也不一样</li><li><code>js引擎：</code>解析和执行 javascript 来实现网页的动态效果</li><li>最开始渲染引擎和 js 引擎并没有区分的很明确，后来 js 引擎越来越独立，内核就倾向于只值渲染引擎</li><li><code>IE : trident</code>内核</li><li><code>Firefox ： gecko</code>内核</li><li><code>Safari : webkit</code>内核</li><li><code>Opera</code>:以前是<code>presto</code>内核，<code>Opera</code>现已改用<code>Google - Chrome</code>的<code>Blink</code>内核</li><li><code>Chrome:Blink</code>(基于<code>webkit</code>，<code>Google与Opera Software</code>共同开发)</li></ul><h3 id="HTTP-请求-作用？"><a href="#HTTP-请求-作用？" class="headerlink" title="HTTP 请求+作用？"></a>HTTP 请求+作用？</h3><ul><li><code>Get</code>方法：发送一个请求来获取服务器资源</li><li><code>POST</code>方法：向服务器提交数据</li><li><code>PUT</code>方法：与<code>POST</code>方法很像，也是提交数据，但<code>PUT</code>制定了资源在服务器上的位置，常用在修改数据</li><li><code>HEAD</code>方法：只请求页面的首部信息</li><li><code>DELETE</code>方法：删除服务器上的资源</li><li><code>OPTIONS</code>方法：用于获取当前<code>URL</code>支持的请求方式</li><li><code>TRACE</code>方法：用于激活一个远程的应用层请求消息回路</li><li><code>CONNECT</code>方法：把请求链接转换到透明的<code>TCP/IP</code>的通道</li></ul><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p><code>1XX</code>：信息状态码</p><pre><code>* `100 continue`继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息
</code></pre><ul><li><p><code>2XX</code>：成功状态码</p><ul><li><code>200 ok</code>正常返回信息</li><li><code>201 created</code>请求成功并且服务器创建了新资源</li><li><code>202 accepted</code>服务器已经接收请求，但尚未处理</li></ul></li><li><p><code>3XX</code>：重定向</p><ul><li><code>301 move per</code>请求的网页已经永久重定向</li><li><code>302 found</code>临时重定向</li><li><code>303 see other</code>临时冲重定向，且总是使用 get 请求新的 url</li><li><code>304 not modified</code>自从上次请求后，请求的网页未修改过</li></ul></li><li><p><code>4XX</code>：客户端错误</p><ul><li><code>400 bad request</code>服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求</li><li><code>401 unauthorized</code>请求未授权</li><li><code>403 forbidden</code>禁止访问</li></ul></li><li><ul><li><code>404 not found</code>找不到如何与 url 匹配的资源</li></ul></li></ul><p><code>5XX</code>：服务器错误</p><pre><code>* `500 internal server error`最常见的服务器端的错误
* `503 service unacailable`服务器端暂时无法处理请求（可能是过载活维护）
</code></pre><p>-</p><h3 id="从浏览器地址栏输入-URL-后发生了什么？"><a href="#从浏览器地址栏输入-URL-后发生了什么？" class="headerlink" title="从浏览器地址栏输入 URL 后发生了什么？"></a>从浏览器地址栏输入 URL 后发生了什么？</h3><h4 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h4><ul><li>1.的浏览器根据请求的<code>URL</code>交给<code>DNS</code>域名解析，找到真实<code>IP</code>，向服务器发起请求；</li><li>2.服务器交给后台处理完成后返回数据，浏览器接收文件<code>（ HTML、JS、CSS 、图象等）</code>；</li><li>3.浏览器对加载到的资源<code>（ HTML、JS、CSS 等）</code>进行语法解析，建立相应的内部数据结构<code>（如 HTML 的 DOM ）</code>；</li><li>4.载入解析到的资源文件，渲染页面，完成。</li></ul><h4 id="详细版"><a href="#详细版" class="headerlink" title="详细版"></a>详细版</h4><ul><li>1.从浏览器接收<code>url</code>到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</li><li>2.开启网络线程到发出一个完整的<code>HTTP</code>请求（这一部分涉及到 dns 查询，<code>TCP/IP</code>请求，五层因特网协议栈等知识）</li><li>3.从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</li><li>4.后台和前台的<code>HTTP</code>交互（这一部分包括<code>HTTP</code>头部、响应码、报文结构、<code>cookie</code>等知识，可以提下静态资源的<code>cookie</code>优化，以及编码解码，如<code>gzip</code>压缩等）</li><li>5.单独拎出来的缓存问题，<code>HTTP</code>的缓存（这部分包括<code>http缓存头部</code>，<code>ETag ， catchcontrol</code>等）</li><li>6.浏览器接收到<code>HTTP</code>数据包后的解析流程（解析<code>html</code>-词法分析然后解析成<code>dom</code>树、解析<code>css</code>生成<code>css</code>规则树、合并成<code>render</code>树，然后<code>layout 、 painting</code>渲染、复合图层的合成、<code>GPU</code>绘制、外链资源的处理、<code>loaded 和 DOMContentLoaded</code>等）</li><li>7.<code>CSS</code>的可视化格式模型（元素的渲染规则，如包含块，控制框，<code>BFC</code>， IFC 等概念）</li><li>8.<code>JS</code>引擎解析过程（<code>JS</code>的解释阶段，预处理阶段，执行阶段生成执行上下文，<code>VO</code>，作用域链、回收机制等等）</li><li>9.其它（可以拓展不同的知识模块，如跨域，<code>web</code>安全，<code>hybrid</code>模式等等内容）</li></ul><h4 id="详细升级版"><a href="#详细升级版" class="headerlink" title="详细升级版"></a>详细升级版</h4><ul><li><p>1.在浏览器地址栏输入<code>URL</code></p><p>2.浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤</p><pre><code>* 2.1 如果资源未缓存，发起新请求
* 2.2 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。
</code></pre><p>2.3 检验新鲜通常有两个<code>HTTP</code>头进行控制<code>Expires</code>和<code>Cache-Control</code>：</p><pre><code>    * 2.3.1`HTTP1.0`提供`Expires`，值为一个绝对时间表示缓存新鲜日期
    * 2.3.2`HTTP1.1`增加了`Cache-Control: max-age=`,值为以秒为单位的最大新鲜时间
* *
</code></pre></li><li><p>3.浏览器解析<code>URL</code>获取协议，主机，端口，<code>path</code></p></li><li><p>4.浏览器组装一个<code>HTTP（GET）</code>请求报文</p><p>5.浏览器获取主机<code>ip地址</code>，过程如下：</p><pre><code>* 5.1 浏览器缓存
* 5.2 本机缓存
* 5.3 hosts文件
* 5.4 路由器缓存
* 5.5 ISP DNS缓存
* 5.6 DNS递归查询（可能存在负载均衡导致每次IP不一致）
</code></pre></li><li><p>6.打开一个<code>socket</code>与目标<code>IP地址</code>，端口建立 TCP 链接，<code>三次握手</code>如下：</p><ul><li>6.1 客户端发送一个<code>TCP的SYN=1，Seq=X</code>的包到服务器端口</li><li>6.2 服务器发回<code>SYN=1，ACK=x+1,Seq=Y</code>的相应包</li><li>6.3 客户端发送<code>ACK=Y+1，Seq=z</code></li></ul></li><li><ul><li>7.<code>TCP</code>链接建立后发送<code>HTTP</code>请求</li></ul></li><li>8.服务器接收请求后解析，将请求转发到服务器程序，如虚拟主机使用<code>HTTP Host</code>头部判断请求的服务程序</li><li>9.服务器检测<code>HTTP</code>请求头是否包含缓存验证信息，如果验证缓存新鲜，返回 304 等对应状态</li><li>10.出合理程序读取完整请求并准备<code>HTTP</code>相应，可能需要查询数据库等操作</li><li><p>11.服务器将相应报文通过<code>TCP</code>链接发送回浏览器</p><p>12.浏览器接收<code>HTTP</code>相应，然后根据情况选择关闭<code>TCP</code>链接或者保留重用，关闭 TCP 链接的四次握手如下：</p><pre><code>* 12.1 主动方发送`Fin=1,ACK=z,Seq=x`报文
* 12.2 被动方发送`ACK=X+1,Seq=Y`报文
* 12.3 被动方发送`Fin=1,ACK=X,Seq=Y`报文
* 12.4 主动方发送`ACK=Y,Seq=x`报文
</code></pre></li><li><ul><li>13.浏览器检查相应状态码</li></ul></li><li>14.如果资源可缓存，进行缓存</li><li>15.对相应进行解码</li><li>16.根据资源类型决定如何处理</li><li><p>17.解析<code>HTML</code>文档，构建<code>DOM</code>树，下载资源，构建<code>CSSOM</code>树，执行 js 脚本，这些操作每月严格的先后顺序</p><p>18.构建 DOM 树：</p><pre><code>* 18.1 Tokenizing：根据HTML规范将字符流解析为标记
* 18.2 Lexing：词法分析将标记转换为对象并定义属性和规则
* 18.3 DOM construction：根据HTML标记关系将对象组成DOM树
</code></pre></li><li><ul><li><p>19.解析过程中遇到图片、样式表、js 文件，启动下载</p><p>20.构建<code>CSSOM</code>树：</p><pre><code>* 20.1`Tokenizing`：字符流转换为标记流
* 20.2`Node`：根据标记创建节点
* 20.3`CSSOM`：节点创建CSSOM树
</code></pre></li></ul></li><li><ul><li>根据<code>DOM树和CSSOM树</code>构建渲染树</li></ul><ul><li>21.1 从<code>DOM树</code>的根节点遍历所有可见节点，不可见节点包括：1）<code>script , meta</code>这样本身不可见的标签。2)被 css 隐藏的节点，如 display: none</li><li>21.2 对每一个可见节点，找到恰当的<code>CSSOM</code>规则并应用</li><li>21.3 发布可视节点的内容和计算样式</li></ul></li><li><p>22.js 解析如下</p><ul><li>22.1 浏览器创建<code>Document对象</code>并解析<code>HTML</code>，将解析到的元素和文本节点添加到文档中，此时<code>document.readystate为loading</code></li><li>22.2 HTML 解析器遇到没有<code>async和defer的script时</code>，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用<code>document.write()</code>把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容</li><li>22.3 当解析器遇到设置了<code>async属性的script</code>时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用<code>document.write()</code>，它们可以访问自己 script 和之前的文档元素</li><li>22.4 当文档完成解析，<code>document.readState变成interactive</code></li><li>22.5 所有<code>defer脚本</code>会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用<code>document.write()</code></li><li>22.6 浏览器在<code>Document</code>对象上触发<code>DOMContentLoaded事件</code></li><li>22.7 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，<code>document.readState变为complete，window触发load事件</code></li></ul></li><li><ul><li>23.显示页面（HTML 解析过程中会逐步显示页面）</li></ul></li></ul><h3 id="cookies-，-sessionStorage-和-localStorage-的区别"><a href="#cookies-，-sessionStorage-和-localStorage-的区别" class="headerlink" title="cookies ， sessionStorage 和 localStorage 的区别"></a>cookies ， sessionStorage 和 localStorage 的区别</h3><ul><li><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）</li><li><code>cookie</code>数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递（优化点）</li><li><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li></ul><p>存储大小：</p><pre><code>* `cookie`数据大小不能超过4k
* `sessionStorage 和 localStorage`虽然也有存储大小的限制，但比 cookie 大得多，可以达到5M或更大
</code></pre><ul><li><ul><li>有期时间：</li></ul></li></ul><p><code>localStorage</code>存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</p><p><code>sessionStorage</code>数据在当前浏览器窗口关闭后自动删除</p><p><code>cookie 设置的 cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</p><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><blockquote><p>浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下</p></blockquote><ul><li>先根据这个资源的一些<code>http header</code>判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；</li><li>当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些<code>request header</code>验证这个资源是否命中协商缓存，称为<code>http</code>再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；</li><li>强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。</li><li>当协商缓存也没命中时，服务器就会将资源发送回客户端。</li><li>当<code>ctrl+f5</code>强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li><li>当<code>f5</code>刷新网页时，跳过强缓存，但是会检查协商缓存；</li></ul><p><a href="https://juejin.cn/post/6844903763665240072#heading-5" target="_blank" rel="noopener">强缓存-协商缓存：这篇文章介绍挺细的：https://juejin.cn/post/6844903763665240072#heading-5</a></p><h2 id="JS-篇"><a href="#JS-篇" class="headerlink" title="JS 篇"></a>JS 篇</h2><h3 id="说几条写-JavaScript-的基本规范"><a href="#说几条写-JavaScript-的基本规范" class="headerlink" title="说几条写 JavaScript 的基本规范"></a>说几条写 JavaScript 的基本规范</h3><ul><li>不要在同一行声明多个变量</li><li>请是用 ===/!== 来比较<code>true/false</code>或者数值</li><li>使用对象字面量替代<code>new Array</code>这种形式</li><li>不要使用全局函数</li><li><code>Switch</code>语句必须带有<code>default</code>分支</li><li><code>If</code>语句必须使用大括号</li><li><code>for-in</code>循环中的变量 应该使用<code>let</code>关键字明确限定作用域，从而避免作用域污染</li></ul><h3 id="绕不过去的闭包"><a href="#绕不过去的闭包" class="headerlink" title="绕不过去的闭包"></a>绕不过去的闭包</h3><ul><li>闭包就是能够读取其他函数内部变量的函数</li><li>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个</li><li>函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域</li></ul><p>闭包的特性：</p><pre><code>* 函数内再嵌套函数
* 内部函数可以引用外层的参数和变量
* 参数和变量不会被垃圾回收机制回收
</code></pre><ul><li><ul><li>优点：能够实现封装和缓存等</li></ul></li><li>缺点：消耗内存、使用不当会内存溢出，</li><li>解决方法：在退出函数之前，将不使用的局部变量全部删除</li></ul><h3 id="说说你对作用域链的理解"><a href="#说说你对作用域链的理解" class="headerlink" title="说说你对作用域链的理解"></a>说说你对作用域链的理解</h3><ul><li>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到<code>window</code>对象即被终止，作用域链向下访问变量是不被允许的。</li><li>简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期</li></ul><h3 id="JavaScript-原型，原型链-有什么特点？"><a href="#JavaScript-原型，原型链-有什么特点？" class="headerlink" title="JavaScript 原型，原型链 ? 有什么特点？"></a>JavaScript 原型，原型链 ? 有什么特点？</h3><ul><li>每个对象都会在其内部初始化一个属性，就是<code>prototype</code>(原型)，当我们访问一个对象的属性时,如果这个对象内部不存在这个属性，那么他就会去<code>prototype</code>里找这个属性，这个<code>prototype</code>又会有自己的<code>prototype</code>，于是就这样一直找下去，也就是我们平时所说的原型链的概念</li><li>关系：<code>instance.constructor.prototype = instance._proto_</code></li><li>特点：<code>JavaScript</code>对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变当我们需要一个属性的时，<code>Javascript</code>引擎会先看当前对象中是否有这个属性， 如果没有的,就会查找他的<code>Prototype</code>对象是否有这个属性，如此递推下去，一直检索到<code>Object</code>内建对象</li></ul><h3 id="请解释什么是事件委托-事件代理"><a href="#请解释什么是事件委托-事件代理" class="headerlink" title="请解释什么是事件委托/事件代理"></a>请解释什么是事件委托/事件代理</h3><ul><li>事件代理<code>（ Event Delegation ）</code>，又称之为事件委托。是<code>JavaScript</code>中常用的绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是<code>DOM</code>元素的事件冒泡。使用事件代理的好处是可以提高性能</li><li>可以大量节省内存占用，减少事件注册，比如在<code>table</code>上代理所有<code>td 的 click</code>事件就非常棒</li><li>可以实现当新增子对象时无需再次对其绑定</li></ul><h3 id="Javascript-如何实现继承？"><a href="#Javascript-如何实现继承？" class="headerlink" title="Javascript 如何实现继承？"></a>Javascript 如何实现继承？</h3><ul><li>构造继承</li><li>原型继承</li><li>实例继承</li><li>拷贝继承</li><li>原型<code>prototype</code>机制或<code>apply 和 call</code>方法去实现较简单，建议使用构造函数与原型混合方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">this.name = &apos;wang&apos;;</span><br><span class="line">&#125;</span><br><span class="line">function Child()&#123;</span><br><span class="line"> this.age = 28;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Parent();//继承了Parent，通过原型</span><br><span class="line">var demo = new Child();</span><br><span class="line">alert(demo.age);</span><br><span class="line">alert(demo.name);//得到被继承的属性</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="谈谈-This-对象的理解"><a href="#谈谈-This-对象的理解" class="headerlink" title="谈谈 This 对象的理解"></a>谈谈 This 对象的理解</h3><ul><li><code>this</code>总是指向函数的直接调用者（而非间接调用者）</li><li>如果有<code>new</code>关键字，<code>this</code>指向<code>new</code>出来的那个对象</li><li>在事件中，<code>this</code>指向触发这个事件的对象，特殊的是，<code>IE</code>中的<code>attachEvent 中的this</code>总是指向全局对象<code>Window</code></li></ul><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><blockquote><p><code>W3C</code>中定义事件的发生经历三个阶段：捕获阶段（<code>capturing</code>）、目标阶段 （<code>targetin</code>）、冒泡阶段（<code>bubbling</code>）</p></blockquote><ul><li>冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发</li><li>捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发</li><li><code>DOM</code>事件流：同时支持两种事件模型：捕获型事件和冒泡型事件</li><li>阻止冒泡：在<code>W3c</code>中，使用<code>stopPropagation()</code>方法；在 IE 下设置<code>cancelBubble =true</code></li><li>阻止捕获：阻止事件的默认行为，例如<code>click - a</code>后的跳转。在<code>W3c</code>中，使用<code>preventDefault()</code>方法，在 IE 下设置<code>window.event.returnValue = false</code></li></ul><h3 id="new-操作符具体干了什么呢"><a href="#new-操作符具体干了什么呢" class="headerlink" title="new 操作符具体干了什么呢?"></a>new 操作符具体干了什么呢?</h3><ul><li>创建一个空对象，并且<code>this</code>变量引用该对象，同时还继承了该函数的原型</li><li>属性和方法被加入到<code>this</code>引用的对象中</li><li>新创建的对象由<code>this</code>所引用，并且最后隐式的返回<code>this</code></li></ul><h3 id="Ajax-原理"><a href="#Ajax-原理" class="headerlink" title="Ajax 原理"></a>Ajax 原理</h3><ul><li><code>Ajax</code>的原理简单来说是在用户和服务器之间加了—个中间层( AJAX 引擎)，通过<code>XmlHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>javascript</code>来操作<code>DOM</code>而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据</li><li><code>Ajax</code>的过程只涉及<code>JavaScript 、 XMLHttpRequest 和 DOM 。 XMLHttpRequest</code>是<code>ajax</code>的核心机制</li></ul><h3 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题?"></a>如何解决跨域问题?</h3><blockquote><p>首先了解下浏览器的同源策略 同源策略<code>/SOP（Same origin policy）</code>是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到<code>XSS 、 CSFR</code>等攻击。所谓同源是指<code>&quot;协议+域名+端口&quot;</code>三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源</p></blockquote><ul><li>通过<code>jsonp</code>跨域</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var script = document.createElement(&apos;script&apos;);</span><br><span class="line">script.type = &apos;text/javascript&apos;;</span><br><span class="line">// 传参并指定回调执行函数为onBack</span><br><span class="line">script.src = &apos;http://www.....:8080/login?user=admin&amp;callback=onBack&apos;;</span><br><span class="line">document.head.appendChild(script);</span><br><span class="line">// 回调执行函数</span><br><span class="line">function onBack(res) &#123;</span><br><span class="line"> alert(JSON.stringify(res));</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><code>document.domain + iframe</code>跨域</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//父窗口：(http://www.domain.com/a.html)</span><br><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> document.domain = &apos;domain.com&apos;;</span><br><span class="line"> var user = &apos;admin&apos;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//子窗口：(http://child.domain.com/b.html)</span><br><span class="line">document.domain = &apos;domain.com&apos;;</span><br><span class="line">// 获取父窗口中变量</span><br><span class="line">alert(&apos;get js data from parent ---&gt; &apos; + window.parent.user);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><code>nginx</code>代理跨域</li><li><code>nodejs</code>中间件代理跨域</li><li>后端在头部信息里面设置安全域名</li></ul><h3 id="说说你对-AMD-和-Commonjs-的理解"><a href="#说说你对-AMD-和-Commonjs-的理解" class="headerlink" title="说说你对 AMD 和 Commonjs 的理解"></a>说说你对 AMD 和 Commonjs 的理解</h3><ul><li><code>CommonJS</code>是服务器端模块的规范，<code>Node.js</code>采用了这个规范。<code>CommonJS</code>规范加载模</li></ul><p>块是同步的，也就是说，只有加载完成，才能执行后面的操作。<code>AMD</code>规范则是非同步加载 模块，允许指定回调函数</p><ul><li><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对</li></ul><p><code>module.exports 或 exports</code>的属性赋值来达到暴露模块对象的目的</p><h3 id="js-的-7-种基本数据类型"><a href="#js-的-7-种基本数据类型" class="headerlink" title="js 的 7 种基本数据类型"></a>js 的 7 种基本数据类型</h3><p><code>Undefined 、 Null 、Boolean 、Number 、String 、Bigint 、Symbol</code><a href="https://juejin.cn/user/501033034600989" target="_blank" rel="noopener">感谢：字符搬运工 同学纠正</a></p><h3 id="介绍-js-有哪些内置对象"><a href="#介绍-js-有哪些内置对象" class="headerlink" title="介绍 js 有哪些内置对象"></a>介绍 js 有哪些内置对象</h3><ul><li><code>Object</code>是<code>JavaScript</code>中所有对象的父对象</li><li>数据封装类对象：<code>Object 、 Array 、 Boolean 、 Number 和 String</code></li><li>其他对象：<code>Function 、 Arguments 、 Math 、 Date 、 RegExp 、 Error</code></li></ul><h3 id="JS-有哪些方法定义对象"><a href="#JS-有哪些方法定义对象" class="headerlink" title="JS 有哪些方法定义对象"></a>JS 有哪些方法定义对象</h3><ul><li>对象字面量：<code>var obj = {}</code>;</li><li>构造函数：<code>var obj = new Object()</code>;</li><li>Object.create():<code>var obj = Object.create(Object.prototype);</code></li></ul><h3 id="你觉得-jQuery-源码有哪些写的好的地方"><a href="#你觉得-jQuery-源码有哪些写的好的地方" class="headerlink" title="你觉得 jQuery 源码有哪些写的好的地方"></a>你觉得 jQuery 源码有哪些写的好的地方</h3><ul><li><code>jquery</code>源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入<code>window</code>对象参数，可以使<code>window</code>对象作为局部变量使用，好处是当<code>jquery</code>中访问<code>window</code>对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问<code>window</code>对象。同样，传入<code>undefined</code>参数，可以缩短查找<code>undefined</code>时的作用域链</li><li><code>jquery</code>将一些原型属性和方法封装在了<code>jquery.prototype</code>中，为了缩短名称，又赋值给了<code>jquery.fn</code>，这是很形象的写法</li><li>有一些数组或对象的方法经常能使用到，<code>jQuery</code>将其保存为局部变量以提高访问速度</li><li><code>jquery</code>实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率</li></ul><h3 id="null，undefined-的区别"><a href="#null，undefined-的区别" class="headerlink" title="null，undefined 的区别"></a>null，undefined 的区别</h3><ul><li><code>undefined</code>表示不存在这个值。</li><li><code>undefined</code>:是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。尝试读取时会返回<code>undefined</code></li><li>例如变量被声明了，但没有赋值时，就等于<code>undefined</code></li><li><code>null</code>表示一个对象被定义了，值为“空值”</li><li><code>null</code>: 是一个对象(空对象, 没有任何属性和方法)</li><li>例如作为函数的参数，表示该函数的参数不是对象；</li><li>在验证<code>null</code>时，一定要使用 === ，因为 == 无法分别<code>null 和 undefined</code></li></ul><h3 id="谈谈你对-ES6-的理解"><a href="#谈谈你对-ES6-的理解" class="headerlink" title="谈谈你对 ES6 的理解"></a>谈谈你对 ES6 的理解</h3><ul><li>新增模板字符串（为<code>JavaScript</code>提供了简单的字符串插值功能）</li><li>箭头函数</li><li><code>for-of</code>（用来遍历数据—例如数组中的值。）</li><li><code>arguments</code>对象可被不定参数和默认参数完美代替。</li><li><code>ES6</code>将<code>promise</code>对象纳入规范，提供了原生的<code>Promise</code>对象。</li><li>增加了<code>let 和 const</code>命令，用来声明变量。</li><li>还有就是引入<code>module</code>模块的概念</li></ul><p><a href="https://es6.ruanyifeng.com/#docs/style" target="_blank" rel="noopener">更多 ES 新语法：阮一峰的 ES 入门：https://es6.ruanyifeng.com/#docs/style</a></p><h3 id="面向对象编程思想"><a href="#面向对象编程思想" class="headerlink" title="面向对象编程思想"></a>面向对象编程思想</h3><ul><li>基本思想是使用对象，类，继承，封装等基本概念来进行程序设计</li><li>易维护</li><li>易扩展</li><li>开发工作的重用性、继承性高，降低重复工作量。</li><li>缩短了开发周期</li></ul><h3 id="如何通过-JS-判断一个数组"><a href="#如何通过-JS-判断一个数组" class="headerlink" title="如何通过 JS 判断一个数组"></a>如何通过 JS 判断一个数组</h3><ul><li><code>instanceof</code>运算符是用来测试一个对象是否在其原型链原型构造函数的属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">arr instanceof Array; // true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><code>isArray</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray([]) //true</span><br><span class="line">Array.isArray(1) //false</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><code>constructor</code>属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">arr.constructor == Array; //true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><code>Object.prototype</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call([]) == &apos;[object Array]&apos;</span><br><span class="line">// 写个方法</span><br><span class="line">var isType = function (obj) &#123;</span><br><span class="line"> return Object.prototype.toString.call(obj).slice(8,-1);</span><br><span class="line"> //return Object.prototype.toString.apply([obj]).slice(8,-1);</span><br><span class="line">&#125;</span><br><span class="line">isType([])  //Array</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="异步编程的实现方式"><a href="#异步编程的实现方式" class="headerlink" title="异步编程的实现方式"></a>异步编程的实现方式</h3><p>回调函数</p><pre><code>* 优点：简单、容易理解
* 缺点：不利于维护，代码耦合高
</code></pre><ul><li><p>事件监听(采用时间驱动模式，取决于某个事件是否发生)</p><ul><li>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li><li>缺点：事件驱动型，流程不够清晰</li></ul></li><li><p>发布/订阅(观察者模式)</p><ul><li>类似于事件监听，但是可以通过‘消息中心‘，了解现在有多少发布者，多少订阅者</li></ul></li><li><p><code>Promise</code>对象</p><ul><li>优点：可以利用<code>then</code>方法，进行链式写法；可以书写错误时的回调函数；</li><li>缺点：编写和理解，相对比较难</li></ul></li><li><p><code>Generator</code>函数</p><ul><li>优点：函数体内外的数据交换、错误处理机制</li><li>缺点：流程管理不方便</li></ul></li><li><p><code>async</code>函数</p><ul><li>优点：内置执行器、更好的语义、更广的适用性、返回的是<code>Promise</code>、结构清晰。</li><li>缺点：错误处理机制</li></ul></li></ul><p>-</p><h3 id="对原生-Javascript-了解方向"><a href="#对原生-Javascript-了解方向" class="headerlink" title="对原生 Javascript 了解方向"></a>对原生 Javascript 了解方向</h3><p>数据类型、运算、对象、<code>Function</code>、继承、闭包、作用域、原型链、事件、<code>RegExp</code>、<code>JSON</code>、<code>Ajax</code>、<code>DOM</code>、<code>BOM</code>、内存泄漏、跨域、异步装载、模板引擎、<code>前端MVC</code>、路由、模块化、<code>Canvas</code>、<code>ECMAScript</code></p><h3 id="sort-快速打乱数组"><a href="#sort-快速打乱数组" class="headerlink" title="sort 快速打乱数组"></a>sort 快速打乱数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6,7,8,9,10];</span><br><span class="line">arr.sort(()=&gt; Math.random() - 0.5)</span><br><span class="line">//利用sort return 大于等于0不交换位置，小于0交换位置</span><br><span class="line">// [5, 8, 4, 3, 2, 9, 10, 6, 1, 7]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="数组去重操作"><a href="#数组去重操作" class="headerlink" title="数组去重操作"></a>数组去重操作</h3><ul><li><code>ES6 Set</code></li><li><code>for</code>循环<code>indexOf</code></li><li><code>for</code>循环<code>includes</code></li><li><code>sort</code></li></ul><p><a href="https://juejin.cn/post/6844904035619700750" target="_blank" rel="noopener">详细操作前往：https://juejin.cn/post/6844904035619700750</a></p><h3 id="JS-原生拖拽节点"><a href="#JS-原生拖拽节点" class="headerlink" title="JS 原生拖拽节点"></a>JS 原生拖拽节点</h3><ul><li>给需要拖拽的节点绑定<code>mousedown , mousemove , mouseup</code>事件</li><li><code>mousedown</code>事件触发后，开始拖拽</li><li><code>mousemove</code>时，需要通过<code>event.clientX 和 clientY</code>获取拖拽位置，并实时更新位置</li><li><code>mouseup</code>时，拖拽结束</li><li>需要注意浏览器边界值，设置拖拽范围</li></ul><h3 id="深拷贝、浅拷贝"><a href="#深拷贝、浅拷贝" class="headerlink" title="深拷贝、浅拷贝"></a>深拷贝、浅拷贝</h3><ul><li>所有的基础数据类型的赋值操作都是深拷贝</li><li>通常利用上面这点，来对引用数据类型做递归深拷贝</li><li>浅拷贝：<code>Object.assign</code>或者 扩展运算符</li></ul><p>深拷贝：<code>JSON.parse(JSON.stringify(object))</code>深层递归</p><pre><code>* 局限性：会忽略 undefined，不能序列化函数，不能解决循环引用的对象
</code></pre><p>-</p><p><a href="https://juejin.cn/post/6906369563793817607" target="_blank" rel="noopener">详细信息更多：https://juejin.cn/post/6906369563793817607**</a></p><h3 id="节流防抖"><a href="#节流防抖" class="headerlink" title="节流防抖"></a>节流防抖</h3><ul><li>节流：每隔一段时间执行一次，通常用在高频率触发的地方，降低频率。–如：鼠标滑动 拖拽</li><li>防抖：一段时间内连续触发，不执行，直到超出限定时间执行最后一次。–如：<code>input</code>模糊搜索</li></ul><p><a href="https://juejin.cn/post/6844903592898330638" target="_blank" rel="noopener">更多节流、防抖，细节介绍：https://juejin.cn/post/6844903592898330638</a></p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><blockquote><p>当执行<code>JS</code>代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境</p></blockquote><p><code>js b() // call b console.log(a) // undefined var a = &#39;Hello world&#39; function b() { console.log(&#39;call b&#39;) }</code></p><blockquote><p>变量提升 这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，<code>JS</code>解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为<code>undefined</code>，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b() // call b second</span><br><span class="line">function b() &#123;</span><br><span class="line"> console.log(&apos;call b fist&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function b() &#123;</span><br><span class="line"> console.log(&apos;call b second&apos;)</span><br><span class="line">&#125;</span><br><span class="line">var b = &apos;Hello world&apos;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="js-单线程"><a href="#js-单线程" class="headerlink" title="js 单线程"></a>js 单线程</h3><ul><li>单线程 - 只有一个线程，只能做一件事</li></ul><p>原因 - 避免<code>DOM</code>渲染的冲突</p><pre><code>* 浏览器需要渲染`DOM`
* `JS`可以修改`DOM`结构
* `JS`执行的时候，浏览器`DOM`渲染会暂停
* 两段`JS`也不能同时执行（都修改`DOM`就冲突了）
* `webworker`支持多线程，但是不能访问`DOM`
</code></pre><ul><li><ul><li>解决方案 - 异步</li></ul></li></ul><h3 id="说说-event-loop"><a href="#说说-event-loop" class="headerlink" title="说说 event loop"></a>说说 event loop</h3><blockquote><p>首先，<code>js</code>是单线程的，主要的任务是处理用户的交互，而用户的交互无非就 是响应<code>DOM</code>的增删改，使用事件队列的形式，一次事件循环只处理一个事件 响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件， 那么事件队列的事件从哪里被<code>push</code>进来的呢。那就是另外一个线程叫事件触 发线程做的事情了，他的作用主要是在定时触发器线程、异步<code>HTTP</code>请求线程 满足特定条件下的回调函数<code>push</code>到事件队列中，等待<code>js</code>引擎空闲的时候去 执行，当然<code>js</code>引擎执行过程中有优先级之分，首先<code>js</code>引擎在一次事件循环中， 会先执行 js 线程的主任务，然后会去查找是否有微任务<code>microtask（promise）</code>，如果有那就优先执行微任务，如果没有，在去查找 宏任务<code>macrotask（setTimeout、setInterval）</code>进行执行</p></blockquote><p><a href="https://juejin.cn/post/6844903598573240327" target="_blank" rel="noopener">更详细的介绍前往：https://juejin.cn/post/6844903598573240327</a></p><h3 id="描述下-this"><a href="#描述下-this" class="headerlink" title="描述下 this"></a>描述下 this</h3><blockquote><p><code>this</code>，函数执行的上下文，可以通过<code>apply ， call ， bind</code>改变<code>this</code>的指向。对于匿名函数或者直接调用的函数来说，this 指向全局上下文（浏览 器为<code>window，NodeJS为 global</code>），剩下的函数调用，那就是谁调用它，<code>this</code>就指向谁。当然还有<code>es6</code>的箭头函数，箭头函数的指向取决于该箭头函 数声明的位置，在哪里声明，<code>this</code>就指向哪里</p></blockquote><h3 id="ajax、axios、fetch-区别"><a href="#ajax、axios、fetch-区别" class="headerlink" title="ajax、axios、fetch 区别"></a>ajax、axios、fetch 区别</h3><p>ajax：</p><ul><li>本身是针对<code>MVC</code>的编程,不符合现在前端<code>MVVM</code>的浪潮</li><li>基于原生的<code>XHR</code>开发，<code>XHR</code>本身的架构不清晰，已经有了<code>fetch</code>的替代方案</li><li><code>JQuery</code>整个项目太大，单纯使用<code>ajax</code>却要引入整个<code>JQuery</code>非常的不合理（采取个性化打包的方案又不能享受<code>CDN</code>服务）</li></ul><p>axios：</p><ul><li>从浏览器中创建<code>XMLHttpRequest</code></li><li>从<code>node.js</code>发出<code>http</code>请求</li><li>支持<code>Promise API</code></li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换<code>JSON</code>数据</li><li>客户端支持防止<code>CSRF/XSRF</code></li></ul><p>fetch：</p><ul><li>只对网络请求报错，对 400 ， 500 都当做成功的请求，需要封装去处理</li><li>默认不会带<code>cookie</code>，需要添加配置项（尴尬）</li><li>本身无自带<code>abort</code>，无法超时控制，可以使用 AbortController 解决取消请求问题。</li><li>没有办法原生监测请求的进度，而<code>XHR</code>可以</li></ul><p><a href="http://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html" target="_blank" rel="noopener">更多 fetch 知识前往：阮一峰 fetch</a></p><h2 id="优化-篇"><a href="#优化-篇" class="headerlink" title="优化 篇"></a>优化 篇</h2><h3 id="SEO-优化"><a href="#SEO-优化" class="headerlink" title="SEO 优化"></a>SEO 优化</h3><ul><li>合理的<code>title 、 description 、 keywords</code>：搜索对着三项的权重逐个减小，<code>title</code>值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面<code>title</code>要有所不同；<code>description</code>把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面<code>description</code>有所不同；<code>keywords</code>列举出重要关键词即可</li><li>语义化的<code>HTML</code>代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容<code>HTML</code>代码放在最前：搜索引擎抓取<code>HTML</code>顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用<code>js</code>输出：爬虫不会执行 js 获取内容</li><li>少用<code>iframe</code>：搜索引擎不会抓取<code>iframe</code>中的内容</li><li>非装饰性图片必须加<code>alt</code></li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li></ul><h3 id="server-优化"><a href="#server-优化" class="headerlink" title="server 优化"></a>server 优化</h3><ul><li>减少<code>HTTP</code>请求，合并文件、雪碧图</li><li>减少<code>DNS</code>查询，使用缓存</li><li>减少<code>Dom</code>元素的数量</li><li>使用<code>CDN</code></li><li>配置<code>ETag</code>,http 缓存的手段</li><li>对组件使用<code>Gzip</code>压缩</li><li>减少<code>cookie</code>的大小</li></ul><h3 id="css-优化"><a href="#css-优化" class="headerlink" title="css 优化"></a>css 优化</h3><ul><li>将样式表放在页面顶部</li><li>使用<code>less scss</code>表达式</li><li>使用<code>link</code>不适用<code>@import</code>引入样式</li><li>压缩<code>css</code></li><li>禁止使用<code>gif</code>图片实现<code>loading</code>效果（降低 CPU 消耗，提升渲染性能）</li><li>使用<code>CSS3</code>代码代替<code>JS</code>动画（尽可能避免重绘重排以及回流）</li><li>对于一些小图标，可以使用<code>base64</code>位编码，以减少网络请求。</li><li>页面头部的<code>&lt;style&gt; &lt;script&gt;</code>会阻塞页面；（因为 Renderer 进程中 JS 线程和渲染线程是互斥的）</li><li>当需要设置的样式很多时设置<code>className</code>而不是直接操作<code>style</code></li></ul><h3 id="js-方面"><a href="#js-方面" class="headerlink" title="js 方面"></a>js 方面</h3><ul><li>将脚本放到页面底部</li><li>将<code>js</code>外部引入</li><li>压缩<code>js</code></li><li>使用<code>Eslint</code>语法检测</li><li>减少<code>Dom</code>的操作</li><li>熟练使用设计模式</li><li>禁止使用<code>iframe</code>（阻塞父文档<code>onload</code>事件）</li><li>页面中空的<code>href 和 src</code>会阻塞页面其他资源的加载</li><li>网页<code>gzip ， CDN</code>托管，<code>data</code>缓存 ，图片服务器</li></ul><h3 id="webpack-优化点"><a href="#webpack-优化点" class="headerlink" title="webpack 优化点"></a>webpack 优化点</h3><ul><li>代码压缩插件<code>UglifyJsPlugin</code></li><li>服务器启用<code>gzip</code>压缩</li><li>按需加载资源文件<code>require.ensure</code></li><li>优化<code>devtool</code>中的<code>source-map</code></li><li>剥离<code>css</code>文件，单独打包</li><li>去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致</li><li>开发环境不做无意义的工作如提取<code>css</code>计算文件 hash 等</li><li>配置<code>devtool</code></li><li>优化构建时的搜索路径 指明需要构建目录及不需要构建目录</li></ul><h3 id="其他优化点"><a href="#其他优化点" class="headerlink" title="其他优化点"></a>其他优化点</h3><p>为什么利用多个域名来存储网站资源会更有效？</p><ul><li><code>CDN</code>缓存更方便</li><li>突破浏览器并发限制</li><li>节约<code>cookie</code>带宽</li><li>节约主域名的连接数，优化页面响应速度</li><li>防止不必要的安全问题</li></ul><h2 id="Other-篇"><a href="#Other-篇" class="headerlink" title="Other 篇"></a>Other 篇</h2><h3 id="从用户刷新网页开始，一次-js-请求一般情况下有哪些地方会有缓存处理？"><a href="#从用户刷新网页开始，一次-js-请求一般情况下有哪些地方会有缓存处理？" class="headerlink" title="从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？"></a>从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？</h3><ul><li><code>dns</code>缓存</li><li><code>cdn</code>缓存</li><li>浏览器缓存</li><li>服务器缓存</li></ul><h3 id="常见-web-安全及防护原理"><a href="#常见-web-安全及防护原理" class="headerlink" title="常见 web 安全及防护原理"></a>常见 web 安全及防护原理</h3><p><code>sql</code>注入原理：就是通过把<code>SQL</code>命令插入到<code>Web</code>表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的<code>SQL</code>命令</p><pre><code>* 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双 &quot;-&quot; 进行转换等
* 永远不要使用动态拼装SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取
* 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接
* 不要把机密信息明文存放，请加密或者 hash 掉密码和敏感的信息
</code></pre><ul><li><p><code>XSS</code>防范方法：<code>Xss(cross-site scripting)</code>攻击指的是攻击者往<code>Web</code>页面里插入恶意<code>html</code>标签或者<code>javascript</code>代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取<code>cookie</code>中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点</p><ul><li>首先代码里对用户输入的地方和变量都需要仔细检查长度和对 ”&lt;”,”&gt;”,”;”,”’” 等字符做过滤；其次任何内容写到页面之前都必须加以<code>encode</code>，避免不小心把<code>html tag</code>弄出来。这一个层面做好，至少可以堵住超过一半的<code>XSS</code>攻击</li></ul></li><li><p><code>XSS与CSRF</code>有什么区别：<code>XSS</code>是获取信息，不需要提前知道其他用户页面的代码和数据包。<code>CSRF</code>是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次<code>CSRF</code>攻击，受害者必须依次完成两个步骤，1.登录受信任网站 A ，并在本地生成<code>Cookie</code>。2.在不登出 A 的情况下，访问危险网站 B</p><ul><li>服务端的<code>CSRF</code>方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数</li><li>通过验证码的方法</li></ul></li></ul><p>-</p><h3 id="用过哪些设计模式"><a href="#用过哪些设计模式" class="headerlink" title="用过哪些设计模式"></a>用过哪些设计模式</h3><ul><li>单例模式</li><li>策略模式</li><li>代理模式</li><li>迭代器模式</li><li>发布—订阅模式</li></ul><p><a href="https://www.cnblogs.com/imwtr/p/9451129.html" target="_blank" rel="noopener">更多设计模式 15 种：https://www.cnblogs.com/imwtr/p/9451129.html</a></p><h3 id="Node-的应用场景"><a href="#Node-的应用场景" class="headerlink" title="Node 的应用场景"></a>Node 的应用场景</h3><p>特点</p><pre><code>* 它是一个`javascript`运行环境
* 依赖于`chrome V8`引擎进行代码解释
* 事件驱动
* 非阻塞 I/o
* 单进程，单线程
</code></pre><ul><li><p>优点</p><ul><li>对于文件的读写处理效率极高</li><li>高并发（<code>node</code>最重要的优点）</li></ul></li><li><p>缺点</p><ul><li>只支持单核<code>CPU</code>，不能充分利用<code>CPU</code></li><li>可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li></ul></li></ul><p>-</p><h3 id="那些操作会造成内存泄漏？"><a href="#那些操作会造成内存泄漏？" class="headerlink" title="那些操作会造成内存泄漏？"></a>那些操作会造成内存泄漏？</h3><ul><li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li><li><code>setTimeout</code>的第一个参数使用字符串而非函数的话，会引发内存泄漏</li><li>闭包使用不当</li></ul><h3 id="简单介绍下-webpack"><a href="#简单介绍下-webpack" class="headerlink" title="简单介绍下 webpack"></a>简单介绍下 webpack</h3><p><code>WebPack</code>是一个模块打包工具，你可以使用<code>WebPack</code>管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包<code>Web</code>开发中所用到的<code>HTML 、 Javascript 、 CSS</code>以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，<code>webpack</code>有对应的模块加载器。<code>webpack</code>模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。</p><h3 id="谈谈你对-gulp-的了解"><a href="#谈谈你对-gulp-的了解" class="headerlink" title="谈谈你对 gulp 的了解"></a>谈谈你对 gulp 的了解</h3><ul><li><code>gulp</code>是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成</li><li><code>gulp</code>的核心概念：流</li><li>流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向</li><li><code>gulp</code>正是通过流和代码优于配置的策略来尽量简化任务编写的工作</li></ul><p><code>Gulp</code>的特点：</p><pre><code>* 易于使用：通过代码优于配置的策略，`gulp`让简单的任务简单，复杂的任务可管理
* 构建快速 利用`Node.js`流的威力，你可以快速构建项目并减少频繁的 IO 操作
* 易于学习 通过最少的`API`，掌握`gulp`毫不费力，构建工作尽在掌握：如同一系列流管道
</code></pre><p>-</p><h3 id="渐进增强和优雅降级"><a href="#渐进增强和优雅降级" class="headerlink" title="渐进增强和优雅降级"></a>渐进增强和优雅降级</h3><ul><li>渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li><li>优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容</li></ul><h3 id="谈一谈你理解的函数式编程"><a href="#谈一谈你理解的函数式编程" class="headerlink" title="谈一谈你理解的函数式编程"></a>谈一谈你理解的函数式编程</h3><ul><li>简单说，”函数式编程”是一种”编程范式”<code>（programming paradigm）</code>，也就是如何编写程序的方法论</li><li>它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是”第一等公民”、只用”表达式”</li></ul><p><a href="https://zhuanlan.zhihu.com/p/57708956" target="_blank" rel="noopener">想了解更多，移步这里：https://zhuanlan.zhihu.com/p/57708956</a></p><h3 id="Vue-的双向绑定数据的原理"><a href="#Vue-的双向绑定数据的原理" class="headerlink" title="Vue 的双向绑定数据的原理"></a>Vue 的双向绑定数据的原理</h3><p><code>vue.js</code>则是采用数据劫持结合发布者-订阅者模式的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter ， getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调</p><h3 id="写个简单-Loader"><a href="#写个简单-Loader" class="headerlink" title="写个简单 Loader"></a>写个简单 Loader</h3><blockquote><p><code>loader</code>就是一个<code>node</code>模块，它输出了一个函数。当某种资源需要用这个<code>loader</code>转换时，这个函数会被调用。并且，这个函数可以通过提供给它的<code>this</code>上下文访问<code>Loader API 。 reverse-txt-loader</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 定义</span><br><span class="line">module.exports = function(src) &#123;</span><br><span class="line"> //src是原文件内容（abcde），下面对内容进行处理，这里是反转</span><br><span class="line"> var result = src.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line"> //返回JavaScript源码，必须是String或者Buffer</span><br><span class="line"> return `module.exports = &apos;$&#123;result&#125;&apos;`;</span><br><span class="line">&#125;</span><br><span class="line">//使用</span><br><span class="line">&#123;</span><br><span class="line">test: /\.txt$/,</span><br><span class="line">use: [&#123;</span><br><span class="line">&apos;./path/reverse-txt-loader&apos;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>作者：@baby 张</p><p>链接：<a href="https://juejin.cn/post/6914831351271292936" target="_blank" rel="noopener">https://juejin.cn/post/6914831351271292936</a></p><p>来源：掘金</p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">--------本文结束 <i class="fa fa-telegram" aria-hidden="true"></i> 感谢阅读--------</div></div></div><div></div><div class="post-share">分享到：</div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div></div><button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'><span>Donate</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/wechatpay.png" alt="SilverFT WeChat Pay"><p>WeChat Pay</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.png" alt="SilverFT Alipay"><p>Alipay</p></div></div></div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/10/24/网络基础知识/" rel="next" title="网络基础知识"><i class="fa fa-chevron-left"></i> 网络基础知识</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/11/07/超好听的合唱音乐/" rel="prev" title="超好听的合唱音乐">超好听的合唱音乐 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="vcomments"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/card.jpg" alt="SilverFT"><p class="site-author-name" itemprop="name"><span style="opacity:.2">FT </span>Silver</p><p class="site-description motion-element" itemprop="description"><span style="opacity:.6">未来怎么样，要用力走下去才知道</span></p></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/PlutoSe" target="_blank" title="GitHub" data-balloon="GitHub" data-balloon-pos="up"><i class="fa fa-fw fa-github"></i></a></span></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">32</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">5</span> <span class="site-state-item-name">tags</span></div></nav><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank"><img src="/images/cc-by-nc-sa.png" alt="Creative Commons"></a></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML-篇"><span class="nav-number">1.</span> <span class="nav-text">HTML 篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图片中-title-和-alt-区别？"><span class="nav-number">1.1.</span> <span class="nav-text">图片中 title 和 alt 区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Html5-有哪些新特性、移除了哪些元素"><span class="nav-number">1.2.</span> <span class="nav-text">Html5 有哪些新特性、移除了哪些元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器是怎么对-Html5-的离线储存资源进行管理和加载的呢"><span class="nav-number">1.3.</span> <span class="nav-text">浏览器是怎么对 Html5 的离线储存资源进行管理和加载的呢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iframe-有那些缺点？"><span class="nav-number">1.4.</span> <span class="nav-text">iframe 有那些缺点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML-W3C-的标准"><span class="nav-number">1.5.</span> <span class="nav-text">HTML W3C 的标准</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Doctype-作用-严格模式与混杂模式如何区分？它们有何意义"><span class="nav-number">1.6.</span> <span class="nav-text">Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML-全局属性-global-attribute-有哪些"><span class="nav-number">1.7.</span> <span class="nav-text">HTML 全局属性(global attribute)有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#viewport-的-content-属性作用"><span class="nav-number">1.8.</span> <span class="nav-text">viewport 的 content 属性作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#meta-相关"><span class="nav-number">1.9.</span> <span class="nav-text">meta 相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#div-css-的布局较-table-布局有什么优点"><span class="nav-number">1.10.</span> <span class="nav-text">div+css 的布局较 table 布局有什么优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#src-与-href-的区别"><span class="nav-number">1.11.</span> <span class="nav-text">src 与 href 的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS-篇"><span class="nav-number">2.</span> <span class="nav-text">CSS 篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#link-与-import-的区别"><span class="nav-number">2.1.</span> <span class="nav-text">link 与 @import 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BFC-有什么用"><span class="nav-number">2.2.</span> <span class="nav-text">BFC 有什么用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#清除浮动的几种方式"><span class="nav-number">2.3.</span> <span class="nav-text">清除浮动的几种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Css3-新增伪类-伪元素"><span class="nav-number">2.4.</span> <span class="nav-text">Css3 新增伪类 - 伪元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IE-盒子模型-、W3C-盒子模型"><span class="nav-number">2.5.</span> <span class="nav-text">IE 盒子模型 、W3C 盒子模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#display-inline-block-什么时候不会显示间隙？"><span class="nav-number">2.6.</span> <span class="nav-text">display:inline-block 什么时候不会显示间隙？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#行内元素-float-left-后是否变为块级元素？"><span class="nav-number">2.7.</span> <span class="nav-text">行内元素 float:left 后是否变为块级元素？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果需要手动写动画，你认为最小时间间隔是多久，为什么？"><span class="nav-number">2.8.</span> <span class="nav-text">如果需要手动写动画，你认为最小时间间隔是多久，为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS-不同选择器的权重-CSS-层叠的规则"><span class="nav-number">2.9.</span> <span class="nav-text">CSS 不同选择器的权重(CSS 层叠的规则)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stylus-sass-less-区别"><span class="nav-number">2.10.</span> <span class="nav-text">stylus/sass/less 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rgba-和-opacity-的透明效果有什么不同？"><span class="nav-number">2.11.</span> <span class="nav-text">rgba()和 opacity 的透明效果有什么不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#水平居中的方法"><span class="nav-number">2.12.</span> <span class="nav-text">水平居中的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垂直居中的方法"><span class="nav-number">2.13.</span> <span class="nav-text">垂直居中的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器-篇"><span class="nav-number">3.</span> <span class="nav-text">浏览器 篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器内核的理解"><span class="nav-number">3.1.</span> <span class="nav-text">浏览器内核的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-请求-作用？"><span class="nav-number">3.2.</span> <span class="nav-text">HTTP 请求+作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-状态码"><span class="nav-number">3.3.</span> <span class="nav-text">HTTP 状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从浏览器地址栏输入-URL-后发生了什么？"><span class="nav-number">3.4.</span> <span class="nav-text">从浏览器地址栏输入 URL 后发生了什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础版本"><span class="nav-number">3.4.1.</span> <span class="nav-text">基础版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#详细版"><span class="nav-number">3.4.2.</span> <span class="nav-text">详细版</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#详细升级版"><span class="nav-number">3.4.3.</span> <span class="nav-text">详细升级版</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cookies-，-sessionStorage-和-localStorage-的区别"><span class="nav-number">3.5.</span> <span class="nav-text">cookies ， sessionStorage 和 localStorage 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器缓存"><span class="nav-number">3.6.</span> <span class="nav-text">浏览器缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS-篇"><span class="nav-number">4.</span> <span class="nav-text">JS 篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#说几条写-JavaScript-的基本规范"><span class="nav-number">4.1.</span> <span class="nav-text">说几条写 JavaScript 的基本规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绕不过去的闭包"><span class="nav-number">4.2.</span> <span class="nav-text">绕不过去的闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说说你对作用域链的理解"><span class="nav-number">4.3.</span> <span class="nav-text">说说你对作用域链的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-原型，原型链-有什么特点？"><span class="nav-number">4.4.</span> <span class="nav-text">JavaScript 原型，原型链 ? 有什么特点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#请解释什么是事件委托-事件代理"><span class="nav-number">4.5.</span> <span class="nav-text">请解释什么是事件委托/事件代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Javascript-如何实现继承？"><span class="nav-number">4.6.</span> <span class="nav-text">Javascript 如何实现继承？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#谈谈-This-对象的理解"><span class="nav-number">4.7.</span> <span class="nav-text">谈谈 This 对象的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件模型"><span class="nav-number">4.8.</span> <span class="nav-text">事件模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-操作符具体干了什么呢"><span class="nav-number">4.9.</span> <span class="nav-text">new 操作符具体干了什么呢?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ajax-原理"><span class="nav-number">4.10.</span> <span class="nav-text">Ajax 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何解决跨域问题"><span class="nav-number">4.11.</span> <span class="nav-text">如何解决跨域问题?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说说你对-AMD-和-Commonjs-的理解"><span class="nav-number">4.12.</span> <span class="nav-text">说说你对 AMD 和 Commonjs 的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js-的-7-种基本数据类型"><span class="nav-number">4.13.</span> <span class="nav-text">js 的 7 种基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-js-有哪些内置对象"><span class="nav-number">4.14.</span> <span class="nav-text">介绍 js 有哪些内置对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS-有哪些方法定义对象"><span class="nav-number">4.15.</span> <span class="nav-text">JS 有哪些方法定义对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#你觉得-jQuery-源码有哪些写的好的地方"><span class="nav-number">4.16.</span> <span class="nav-text">你觉得 jQuery 源码有哪些写的好的地方</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null，undefined-的区别"><span class="nav-number">4.17.</span> <span class="nav-text">null，undefined 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#谈谈你对-ES6-的理解"><span class="nav-number">4.18.</span> <span class="nav-text">谈谈你对 ES6 的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象编程思想"><span class="nav-number">4.19.</span> <span class="nav-text">面向对象编程思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何通过-JS-判断一个数组"><span class="nav-number">4.20.</span> <span class="nav-text">如何通过 JS 判断一个数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步编程的实现方式"><span class="nav-number">4.21.</span> <span class="nav-text">异步编程的实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对原生-Javascript-了解方向"><span class="nav-number">4.22.</span> <span class="nav-text">对原生 Javascript 了解方向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort-快速打乱数组"><span class="nav-number">4.23.</span> <span class="nav-text">sort 快速打乱数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组去重操作"><span class="nav-number">4.24.</span> <span class="nav-text">数组去重操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS-原生拖拽节点"><span class="nav-number">4.25.</span> <span class="nav-text">JS 原生拖拽节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深拷贝、浅拷贝"><span class="nav-number">4.26.</span> <span class="nav-text">深拷贝、浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#节流防抖"><span class="nav-number">4.27.</span> <span class="nav-text">节流防抖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量提升"><span class="nav-number">4.28.</span> <span class="nav-text">变量提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js-单线程"><span class="nav-number">4.29.</span> <span class="nav-text">js 单线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说说-event-loop"><span class="nav-number">4.30.</span> <span class="nav-text">说说 event loop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#描述下-this"><span class="nav-number">4.31.</span> <span class="nav-text">描述下 this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ajax、axios、fetch-区别"><span class="nav-number">4.32.</span> <span class="nav-text">ajax、axios、fetch 区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优化-篇"><span class="nav-number">5.</span> <span class="nav-text">优化 篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SEO-优化"><span class="nav-number">5.1.</span> <span class="nav-text">SEO 优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#server-优化"><span class="nav-number">5.2.</span> <span class="nav-text">server 优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#css-优化"><span class="nav-number">5.3.</span> <span class="nav-text">css 优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js-方面"><span class="nav-number">5.4.</span> <span class="nav-text">js 方面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webpack-优化点"><span class="nav-number">5.5.</span> <span class="nav-text">webpack 优化点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他优化点"><span class="nav-number">5.6.</span> <span class="nav-text">其他优化点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Other-篇"><span class="nav-number">6.</span> <span class="nav-text">Other 篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从用户刷新网页开始，一次-js-请求一般情况下有哪些地方会有缓存处理？"><span class="nav-number">6.1.</span> <span class="nav-text">从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见-web-安全及防护原理"><span class="nav-number">6.2.</span> <span class="nav-text">常见 web 安全及防护原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用过哪些设计模式"><span class="nav-number">6.3.</span> <span class="nav-text">用过哪些设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-的应用场景"><span class="nav-number">6.4.</span> <span class="nav-text">Node 的应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#那些操作会造成内存泄漏？"><span class="nav-number">6.5.</span> <span class="nav-text">那些操作会造成内存泄漏？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单介绍下-webpack"><span class="nav-number">6.6.</span> <span class="nav-text">简单介绍下 webpack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#谈谈你对-gulp-的了解"><span class="nav-number">6.7.</span> <span class="nav-text">谈谈你对 gulp 的了解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#渐进增强和优雅降级"><span class="nav-number">6.8.</span> <span class="nav-text">渐进增强和优雅降级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#谈一谈你理解的函数式编程"><span class="nav-number">6.9.</span> <span class="nav-text">谈一谈你理解的函数式编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-的双向绑定数据的原理"><span class="nav-number">6.10.</span> <span class="nav-text">Vue 的双向绑定数据的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写个简单-Loader"><span class="nav-number">6.11.</span> <span class="nav-text">写个简单 Loader</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-image"></div><div class="footer-inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客共86.9k字,</span> 你是第<span id="busuanzi_value_site_uv"></span>个访问者, 共被访问<span id="busuanzi_value_page_pv"></span>次.</div><p>博客已萌萌哒运行<span id="since"></span><span class="my-face">(●'◡'●)ﾉ♥</span></p><p>关于本站：没什么有趣的东西，有趣的是来这的你！</p><p>© <span itemprop="copyrightYear">2021</span> Silver_Blog Blog</p><p>Made by <span class="author" itemprop="copyrightHolder">SilverFT</span></p><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div><canvas id="evanyou"></canvas></div><script type="text/javascript" src="/js/sagiri.min.js?v=0.0.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script></body></html><!-- rebuild by neat -->